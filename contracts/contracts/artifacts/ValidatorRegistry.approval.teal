#pragma version 10

// This TEAL was generated by TEALScript v0.86.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// createApplication(uint64)void
*abi_route_createApplication:
	// poolTemplateAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64)void
	callsub createApplication
	int 1
	return

// createApplication(poolTemplateAppID: uint64): void
createApplication:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:140
	// this.NumValidators.value = 0
	byte 0x6e756d56 // "numV"
	int 0
	app_global_put

	// contracts/validatorRegistry.algo.ts:141
	// this.StakingPoolTemplateAppID.value = poolTemplateAppID
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	frame_dig -1 // poolTemplateAppID: uint64
	app_global_put

	// contracts/validatorRegistry.algo.ts:142
	// this.NumStakers.value = 0
	byte 0x6e756d5374616b657273 // "numStakers"
	int 0
	app_global_put

	// contracts/validatorRegistry.algo.ts:143
	// this.TotalAlgoStaked.value = 0
	byte 0x7374616b6564 // "staked"
	int 0
	app_global_put
	retsub

// gas()void
*abi_route_gas:
	// execute gas()void
	callsub gas
	int 1
	return

// gas(): void
//
// gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
gas:
	proto 0 0
	retsub

// minBalanceForAccount(contracts: number, extraPages: number, assets: number, localInts: number, localBytes: number, globalInts: number, globalBytes: number): uint64
minBalanceForAccount:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:160
	// minBal = ALGORAND_ACCOUNT_MIN_BALANCE
	int 100000
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:161
	// minBal += contracts * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -1 // contracts: number
	int 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:162
	// minBal += extraPages * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -2 // extraPages: number
	int 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:163
	// minBal += assets * ASSET_HOLDING_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -3 // assets: number
	int 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:164
	// minBal += localInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -4 // localInts: number
	int 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:165
	// minBal += globalInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -6 // globalInts: number
	int 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:166
	// minBal += localBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -5 // localBytes: number
	int 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:167
	// minBal += globalBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -7 // globalBytes: number
	int 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:168
	// return minBal;
	frame_dig 0 // minBal: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// costForBoxStorage(totalNumBytes: number): uint64
costForBoxStorage:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:175
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
	int 2500
	frame_dig -1 // totalNumBytes: number
	int 400
	*
	+
	retsub

// getMbrAmounts()(uint64,uint64,uint64,uint64)
*abi_route_getMbrAmounts:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMbrAmounts()(uint64,uint64,uint64,uint64)
	callsub getMbrAmounts
	concat
	log
	int 1
	return

// getMbrAmounts(): MbrAmounts
//
// Returns the MBR amounts needed for various actions:
// [
// AddValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
// AddPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
// PoolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
// AddStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
// ]
getMbrAmounts:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:191
	// return {
	//             AddValidatorMbr: this.costForBoxStorage(1 /* v prefix */ + len<ValidatorID>() + len<ValidatorInfo>()),
	//             AddPoolMbr: this.minBalanceForAccount(
	//                 1,
	//                 0,
	//                 0,
	//                 0,
	//                 0,
	//                 StakingPool.schema.global.numUint,
	//                 StakingPool.schema.global.numByteSlice
	//             ),
	//             PoolInitMbr:
	//                 ALGORAND_ACCOUNT_MIN_BALANCE +
	//                 this.costForBoxStorage(7 /* 'stakers' name */ + len<StakedInfo>() * MAX_STAKERS_PER_POOL),
	//             AddStakerMbr:
	//                 // how much to charge for first time a staker adds stake - since we add a tracking box per staker
	//                 this.costForBoxStorage(
	//                     3 /* 'sps' prefix */ + len<Address>() + len<ValidatorPoolKey>() * MAX_POOLS_PER_STAKER
	//                 ), // size of key + all values
	//         };
	int 530
	callsub costForBoxStorage
	itob
	int 1
	int 8
	int 0
	dupn 3
	int 1
	callsub minBalanceForAccount
	itob
	concat
	int 100000
	int 6407
	callsub costForBoxStorage
	+
	itob
	concat
	int 179
	callsub costForBoxStorage
	itob
	concat
	retsub

// getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_getProtocolConstraints:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub getProtocolConstraints
	concat
	log
	int 1
	return

// getProtocolConstraints(): Constraints
//
// Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
getProtocolConstraints:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:218
	// return {
	//             EpochPayoutMinsMax: MIN_PAYOUT_MINS,
	//             EpochPayoutMinsMin: MAX_PAYOUT_MINS,
	//             MinPctToValidatorWFourDecimals: MIN_PCT_TO_VALIDATOR,
	//             MaxPctToValidatorWFourDecimals: MAX_PCT_TO_VALIDATOR,
	//             MinEntryStake: MIN_ALGO_STAKE_PER_POOL,
	//             MaxAlgoPerPool: MAX_ALGO_PER_POOL,
	//             MaxNodes: MAX_NODES,
	//             MaxPoolsPerNode: MAX_POOLS_PER_NODE,
	//         };
	byte 0x00000000000027600000000000000001000000000000000000000000000f424000000000000f424000002d79883d200000000000000000040000000000000003
	retsub

// getNumValidators()uint64
*abi_route_getNumValidators:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNumValidators()uint64
	callsub getNumValidators
	itob
	concat
	log
	int 1
	return

// getNumValidators(): uint64
//
// Returns the current number of validators
getNumValidators:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:235
	// return this.NumValidators.value;
	byte 0x6e756d56 // "numV"
	app_global_get
	retsub

// getValidatorConfig(uint64)(uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8)
*abi_route_getValidatorConfig:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorConfig(uint64)(uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8)
	callsub getValidatorConfig
	concat
	log
	int 1
	return

// getValidatorConfig(validatorID: ValidatorID): ValidatorConfig
getValidatorConfig:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:240
	// return this.ValidatorList(validatorID).value.Config;
	int 0
	int 191
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorState(uint64)(uint16,uint64,uint64)
*abi_route_getValidatorState:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorState(uint64)(uint16,uint64,uint64)
	callsub getValidatorState
	concat
	log
	int 1
	return

// getValidatorState(validatorID: ValidatorID): ValidatorCurState
getValidatorState:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:245
	// return this.ValidatorList(validatorID).value.State;
	int 191 // headOffset
	int 18
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorOwnerAndManager(uint64)(address,address)
*abi_route_getValidatorOwnerAndManager:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorOwnerAndManager(uint64)(address,address)
	callsub getValidatorOwnerAndManager
	concat
	log
	int 1
	return

// getValidatorOwnerAndManager(validatorID: ValidatorID): [Address, Address]
getValidatorOwnerAndManager:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:250
	// return [
	//             this.ValidatorList(validatorID).value.Config.Owner,
	//             this.ValidatorList(validatorID).value.Config.Manager,
	//         ];
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	int 40
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	concat
	retsub

// getPools(uint64)(uint64,uint16,uint64)[]
*abi_route_getPools:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPools(uint64)(uint64,uint16,uint64)[]
	callsub getPools
	dup
	len
	int 18
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// getPools(validatorID: ValidatorID): PoolInfo[]
//
// Return list of all pools for this validator.
// @param {uint64} validatorID
// @return {PoolInfo[]} - array of pools
// Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns
getPools:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:264
	// retData: PoolInfo[] = []
	byte 0x
	frame_bury 0 // retData: PoolInfo[]

	// contracts/validatorRegistry.algo.ts:265
	// poolSet = clone(this.ValidatorList(validatorID).value.Pools)
	int 209 // headOffset
	int 216
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 1 // poolSet: (uint64,uint16,uint64)[12]

	// contracts/validatorRegistry.algo.ts:266
	// for (let i = 0; i < poolSet.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_0:
	// contracts/validatorRegistry.algo.ts:266
	// i < poolSet.length
	frame_dig 2 // i: uint64
	int 12
	<
	bz *for_0_end

	// *if0_condition
	// contracts/validatorRegistry.algo.ts:267
	// poolSet[i].PoolAppID === 0
	frame_dig 1 // poolSet: (uint64,uint16,uint64)[12]
	frame_dig 2 // i: uint64
	int 18
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	int 0
	==
	bz *if0_end

	// *if0_consequent
	b *for_0_end

*if0_end:
	// contracts/validatorRegistry.algo.ts:271
	// retData.push(poolSet[i])
	frame_dig 0 // retData: PoolInfo[]
	frame_dig 1 // poolSet: (uint64,uint16,uint64)[12]
	frame_dig 2 // i: uint64
	int 18
	* // acc * typeLength
	int 18
	extract3
	concat
	frame_bury 0 // retData: PoolInfo[]

*for_0_continue:
	// contracts/validatorRegistry.algo.ts:266
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// contracts/validatorRegistry.algo.ts:273
	// return retData;
	frame_dig 0 // retData: PoolInfo[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getPoolAppID(uint64,uint64)uint64
*abi_route_getPoolAppID:
	// The ABI return prefix
	byte 0x151f7c75

	// poolID: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPoolAppID(uint64,uint64)uint64
	callsub getPoolAppID
	itob
	concat
	log
	int 1
	return

// getPoolAppID(validatorID: uint64, poolID: uint64): uint64
getPoolAppID:
	proto 2 1

	// contracts/validatorRegistry.algo.ts:280
	// assert(poolID !== 0 && poolID <= this.ValidatorList(validatorID).value.Pools.length)
	frame_dig -2 // poolID: uint64
	int 0
	!=
	dup
	bz *skip_and0
	frame_dig -2 // poolID: uint64
	int 12
	<=
	&&

*skip_and0:
	assert

	// contracts/validatorRegistry.algo.ts:281
	// return this.ValidatorList(validatorID).value.Pools[poolID - 1].PoolAppID;
	int 209 // headOffset
	frame_dig -2 // poolID: uint64
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 0
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	retsub

// getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)
*abi_route_getPoolInfo:
	// The ABI return prefix
	byte 0x151f7c75

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)
	callsub getPoolInfo
	concat
	log
	int 1
	return

// getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo
getPoolInfo:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:286
	// return this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1];
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 18
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	retsub

// doesStakerNeedToPayMBR(address)bool
*abi_route_doesStakerNeedToPayMBR:
	// The ABI return prefix
	byte 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute doesStakerNeedToPayMBR(address)bool
	callsub doesStakerNeedToPayMBR
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// doesStakerNeedToPayMBR(staker: Address): boolean
//
// Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
// @param staker
doesStakerNeedToPayMBR:
	proto 1 1

	// *if1_condition
	// contracts/validatorRegistry.algo.ts:295
	// this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	bz *if1_end

	// *if1_consequent
	// contracts/validatorRegistry.algo.ts:296
	// return false;
	int 0
	retsub

*if1_end:
	// contracts/validatorRegistry.algo.ts:298
	// return true;
	int 1
	retsub

// getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]
*abi_route_getStakedPoolsForAccount:
	// The ABI return prefix
	byte 0x151f7c75

	// staker: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]
	callsub getStakedPoolsForAccount
	dup
	len
	int 24
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// getStakedPoolsForAccount(staker: Address): ValidatorPoolKey[]
//
// Retrieves the staked pools for an account.
//
// @param {Address} staker - The account to retrieve staked pools for.
// @return {ValidatorPoolKey[]} - The array of staked pools for the account.
getStakedPoolsForAccount:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// *if2_condition
	// contracts/validatorRegistry.algo.ts:308
	// !this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	!
	bz *if2_end

	// *if2_consequent
	// contracts/validatorRegistry.algo.ts:309
	// return [];
	byte 0x
	retsub

*if2_end:
	// contracts/validatorRegistry.algo.ts:311
	// retData: ValidatorPoolKey[] = []
	byte 0x
	frame_bury 0 // retData: ValidatorPoolKey[]

	// contracts/validatorRegistry.algo.ts:312
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_get
	assert
	frame_bury 1 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:313
	// for (let i = 0; i < poolSet.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_1:
	// contracts/validatorRegistry.algo.ts:313
	// i < poolSet.length
	frame_dig 2 // i: uint64
	int 6
	<
	bz *for_1_end

	// *if3_condition
	// contracts/validatorRegistry.algo.ts:314
	// poolSet[i].ID !== 0
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	int 0
	!=
	bz *if3_end

	// *if3_consequent
	// contracts/validatorRegistry.algo.ts:315
	// retData.push(poolSet[i])
	frame_dig 0 // retData: ValidatorPoolKey[]
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3
	concat
	frame_bury 0 // retData: ValidatorPoolKey[]

*if3_end:

*for_1_continue:
	// contracts/validatorRegistry.algo.ts:313
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_1

*for_1_end:
	// contracts/validatorRegistry.algo.ts:318
	// return retData;
	frame_dig 0 // retData: ValidatorPoolKey[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getNodePoolAssignments(uint64)((uint64[3])[4])
*abi_route_getNodePoolAssignments:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getNodePoolAssignments(uint64)((uint64[3])[4])
	callsub getNodePoolAssignments
	concat
	log
	int 1
	return

// getNodePoolAssignments(validatorID: uint64): NodePoolAssignmentConfig
getNodePoolAssignments:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:323
	// assert(this.ValidatorList(validatorID).exists)
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:325
	// return this.ValidatorList(validatorID).value.NodePoolAssignments;
	int 425 // headOffset
	int 96
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_extract
	retsub

// getNFDRegistryID()uint64
*abi_route_getNFDRegistryID:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNFDRegistryID()uint64
	callsub getNFDRegistryID
	itob
	concat
	log
	int 1
	return

// getNFDRegistryID(): uint64
getNFDRegistryID:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:329
	// return this.NFDRegistryAppID;
	pushint TMPL_NFDRegistryAppID
	retsub

// addValidator(pay,string,(uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8))uint64
*abi_route_addValidator:
	// The ABI return prefix
	byte 0x151f7c75

	// config: (uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8)
	txna ApplicationArgs 2
	dup
	len
	int 191
	==
	assert

	// nfdName: string
	txna ApplicationArgs 1
	extract 2 0

	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute addValidator(pay,string,(uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8))uint64
	callsub addValidator
	itob
	concat
	log
	int 1
	return

// addValidator(mbrPayment: PayTxn, nfdName: string, config: ValidatorConfig): uint64
//
// Adds a new validator
// @param mbrPayment payment from caller which covers mbr increase of new validator storage
// @param nfdName (Optional) Name of nfd (used as double-check against id specified in config)
// @param config ValidatorConfig struct
// @returns validator ID
addValidator:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:339
	// this.validateConfig(config)
	frame_dig -3 // config: ValidatorConfig
	callsub validateConfig

	// contracts/validatorRegistry.algo.ts:340
	// assert(config.Owner !== Address.zeroAddress)
	frame_dig -3 // config: ValidatorConfig
	extract 8 32
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:341
	// assert(config.Manager !== Address.zeroAddress)
	frame_dig -3 // config: ValidatorConfig
	extract 40 32
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:342
	// assert(this.txn.sender === config.Owner, 'sender must be owner to add new validator')
	txn Sender
	frame_dig -3 // config: ValidatorConfig
	extract 8 32
	==

	// sender must be owner to add new validator
	assert

	// contracts/validatorRegistry.algo.ts:344
	// verifyPayTxn(mbrPayment, { amount: this.getMbrAmounts().AddValidatorMbr })
	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 0 8
	btoi
	==
	assert

	// contracts/validatorRegistry.algo.ts:347
	// validatorID = this.NumValidators.value + 1
	byte 0x6e756d56 // "numV"
	app_global_get
	int 1
	+
	frame_bury 0 // validatorID: uint64

	// contracts/validatorRegistry.algo.ts:348
	// this.NumValidators.value = validatorID
	byte 0x6e756d56 // "numV"
	frame_dig 0 // validatorID: uint64
	app_global_put

	// contracts/validatorRegistry.algo.ts:350
	// this.ValidatorList(validatorID).create()
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	int 521
	box_create
	pop

	// contracts/validatorRegistry.algo.ts:351
	// this.ValidatorList(validatorID).value.Config = config
	int 0
	frame_dig -3 // config: ValidatorConfig
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:352
	// this.ValidatorList(validatorID).value.Config.ID = validatorID
	int 0
	frame_dig 0 // validatorID: uint64
	itob
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// *if4_condition
	// contracts/validatorRegistry.algo.ts:354
	// config.NFDForInfo !== 0
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	int 0
	!=
	bz *if4_end

	// *if4_consequent
	// contracts/validatorRegistry.algo.ts:356
	// sendAppCall({
	//                 applicationID: AppID.fromUint64(this.NFDRegistryAppID),
	//                 applicationArgs: ['is_valid_nfd_appid', nfdName, itob(config.NFDForInfo)],
	//             })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:357
	// applicationID: AppID.fromUint64(this.NFDRegistryAppID)
	pushint TMPL_NFDRegistryAppID
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:358
	// applicationArgs: ['is_valid_nfd_appid', nfdName, itob(config.NFDForInfo)]
	byte 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig -2 // nfdName: string
	itxn_field ApplicationArgs
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:361
	// assert(
	//                 this.txn.sender === (AppID.fromUint64(config.NFDForInfo).globalState('i.owner.a') as Address),
	//                 'If specifying NFD, account adding validator must be owner'
	//             )
	txn Sender
	frame_dig -3 // config: ValidatorConfig
	extract 72 8
	btoi
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex
	assert
	==

	// If specifying NFD, account adding validator must be owner
	assert

*if4_end:
	// contracts/validatorRegistry.algo.ts:366
	// return validatorID;
	frame_dig 0 // validatorID: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// changeValidatorManager(uint64,address)void
*abi_route_changeValidatorManager:
	// manager: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorManager(uint64,address)void
	callsub changeValidatorManager
	int 1
	return

// changeValidatorManager(validatorID: ValidatorID, manager: Address): void
changeValidatorManager:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:370
	// assert(this.txn.sender === this.ValidatorList(validatorID).value.Config.Owner)
	txn Sender
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	assert

	// contracts/validatorRegistry.algo.ts:371
	// this.ValidatorList(validatorID).value.Config.Manager = manager
	int 40
	frame_dig -2 // manager: Address
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorNFD(uint64,uint64,string)void
*abi_route_changeValidatorNFD:
	// nfdName: string
	txna ApplicationArgs 3
	extract 2 0

	// nfdAppID: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorNFD(uint64,uint64,string)void
	callsub changeValidatorNFD
	int 1
	return

// changeValidatorNFD(validatorID: ValidatorID, nfdAppID: uint64, nfdName: string): void
//
// Changes the NFD for a validator in the ValidatorList contract.
// Only the owner or manager of the validator can make this change.
//
// @param {ValidatorID} validatorID - The ID of the validator to update.
// @param {uint64} nfdAppID - The application ID of the NFD to assign to the validator.
// @param {string} nfdName - The name of the NFD (which must match)
changeValidatorNFD:
	proto 3 0

	// contracts/validatorRegistry.algo.ts:384
	// assert(
	//             this.txn.sender === this.ValidatorList(validatorID).value.Config.Owner ||
	//                 this.txn.sender === this.ValidatorList(validatorID).value.Config.Manager
	//         )
	txn Sender
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz *skip_or0
	txn Sender
	int 40
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	||

*skip_or0:
	assert

	// contracts/validatorRegistry.algo.ts:389
	// sendAppCall({
	//             applicationID: AppID.fromUint64(this.NFDRegistryAppID),
	//             applicationArgs: ['is_valid_nfd_appid', nfdName, itob(nfdAppID)],
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:390
	// applicationID: AppID.fromUint64(this.NFDRegistryAppID)
	pushint TMPL_NFDRegistryAppID
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:391
	// applicationArgs: ['is_valid_nfd_appid', nfdName, itob(nfdAppID)]
	byte 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig -3 // nfdName: string
	itxn_field ApplicationArgs
	frame_dig -2 // nfdAppID: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:394
	// assert(
	//             this.txn.sender === (AppID.fromUint64(nfdAppID).globalState('i.owner.a') as Address),
	//             'If specifying NFD, account adding validator must be owner'
	//         )
	txn Sender
	frame_dig -2 // nfdAppID: uint64
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex
	assert
	==

	// If specifying NFD, account adding validator must be owner
	assert

	// contracts/validatorRegistry.algo.ts:398
	// this.ValidatorList(validatorID).value.Config.NFDForInfo = nfdAppID
	int 72
	frame_dig -2 // nfdAppID: uint64
	itob
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorCommissionAddress(uint64,address)void
*abi_route_changeValidatorCommissionAddress:
	// commissionAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorCommissionAddress(uint64,address)void
	callsub changeValidatorCommissionAddress
	int 1
	return

// changeValidatorCommissionAddress(validatorID: ValidatorID, commissionAddress: Address): void
//
// Change the commission address that validator rewards are sent to.  Can only be changed by that validator owner
changeValidatorCommissionAddress:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:405
	// assert(this.txn.sender === this.ValidatorList(validatorID).value.Config.Owner)
	txn Sender
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	assert

	// contracts/validatorRegistry.algo.ts:406
	// assert(commissionAddress !== Address.zeroAddress)
	frame_dig -2 // commissionAddress: Address
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:407
	// this.ValidatorList(validatorID).value.Config.ValidatorCommissionAddress = commissionAddress
	int 142
	frame_dig -2 // commissionAddress: Address
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace
	retsub

// changeValidatorRewardInfo(uint64,address,uint64,uint64,uint64)void
*abi_route_changeValidatorRewardInfo:
	// RewardPerPayout: uint64
	txna ApplicationArgs 5
	btoi

	// RewardTokenID: uint64
	txna ApplicationArgs 4
	btoi

	// CreatorNFTMinBalance: uint64
	txna ApplicationArgs 3
	btoi

	// MustHoldCreatorNFT: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeValidatorRewardInfo(uint64,address,uint64,uint64,uint64)void
	callsub changeValidatorRewardInfo
	int 1
	return

// changeValidatorRewardInfo(validatorID: ValidatorID, MustHoldCreatorNFT: Address, CreatorNFTMinBalance: uint64, RewardTokenID: uint64, RewardPerPayout: uint64): void
//
// Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
// The validator may want to adjust the tokens or amounts.
// TODO: should there be limits on how often it can be changed?
changeValidatorRewardInfo:
	proto 5 0

	// contracts/validatorRegistry.algo.ts:423
	// assert(
	//             this.txn.sender === this.ValidatorList(validatorID).value.Config.Owner ||
	//                 this.txn.sender === this.ValidatorList(validatorID).value.Config.Manager
	//         )
	txn Sender
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz *skip_or1
	txn Sender
	int 40
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	||

*skip_or1:
	assert

	// contracts/validatorRegistry.algo.ts:427
	// this.ValidatorList(validatorID).value.Config.MustHoldCreatorNFT = MustHoldCreatorNFT
	int 80
	frame_dig -2 // MustHoldCreatorNFT: Address
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:428
	// this.ValidatorList(validatorID).value.Config.CreatorNFTMinBalance = CreatorNFTMinBalance
	int 112
	frame_dig -3 // CreatorNFTMinBalance: uint64
	itob
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:429
	// this.ValidatorList(validatorID).value.Config.RewardTokenID = RewardTokenID
	int 120
	frame_dig -4 // RewardTokenID: uint64
	itob
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:430
	// this.ValidatorList(validatorID).value.Config.RewardPerPayout = RewardPerPayout
	int 128
	frame_dig -5 // RewardPerPayout: uint64
	itob
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace
	retsub

// addPool(pay,uint64,uint64)(uint64,uint64,uint64)
*abi_route_addPool:
	// The ABI return prefix
	byte 0x151f7c75

	// nodeNum: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute addPool(pay,uint64,uint64)(uint64,uint64,uint64)
	callsub addPool
	concat
	log
	int 1
	return

// addPool(mbrPayment: PayTxn, validatorID: ValidatorID, nodeNum: uint64): ValidatorPoolKey
//
// Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
// The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
// @param {PayTxn} mbrPayment payment from caller which covers mbr increase of adding a new pool
// @param {uint64} validatorID is ID of validator to pool to (must be owner or manager)
// @param {uint64} nodeNum is node number to add to
// @returns {ValidatorPoolKey} pool key to created pool
addPool:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:443
	// verifyPayTxn(mbrPayment, { amount: this.getMbrAmounts().AddPoolMbr, receiver: this.app.address })
	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 8 8
	btoi
	==
	assert

	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/validatorRegistry.algo.ts:445
	// assert(this.ValidatorList(validatorID).exists)
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:448
	// assert(
	//             this.txn.sender === this.ValidatorList(validatorID).value.Config.Owner ||
	//                 this.txn.sender === this.ValidatorList(validatorID).value.Config.Manager
	//         )
	txn Sender
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz *skip_or2
	txn Sender
	int 40
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	||

*skip_or2:
	assert

	// contracts/validatorRegistry.algo.ts:453
	// numPools = this.ValidatorList(validatorID).value.State.NumPools
	int 191
	int 2
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // numPools: uint16

	// *if5_condition
	// contracts/validatorRegistry.algo.ts:454
	// (numPools as uint64) >= MAX_POOLS
	frame_dig 0 // numPools: uint16
	int 12
	>=
	bz *if5_end

	// *if5_consequent
	err // 'already at max pool size'

*if5_end:
	// contracts/validatorRegistry.algo.ts:457
	// numPools += 1
	frame_dig 0 // numPools: uint16
	int 1
	+
	frame_bury 0 // numPools: uint16

	// contracts/validatorRegistry.algo.ts:460
	// sendAppCall({
	//             onCompletion: OnCompletion.NoOp,
	//             approvalProgram: AppID.fromUint64(this.StakingPoolTemplateAppID.value).approvalProgram,
	//             clearStateProgram: AppID.fromUint64(this.StakingPoolTemplateAppID.value).clearStateProgram,
	//             globalNumUint: AppID.fromUint64(this.StakingPoolTemplateAppID.value).globalNumUint,
	//             globalNumByteSlice: AppID.fromUint64(this.StakingPoolTemplateAppID.value).globalNumByteSlice,
	//             extraProgramPages: AppID.fromUint64(this.StakingPoolTemplateAppID.value).extraProgramPages,
	//             applicationArgs: [
	//                 // creatingContractID, validatorID, poolID, minEntryStake, maxStakeAllowed
	//                 method('createApplication(uint64,uint64,uint64,uint64,uint64)void'),
	//                 itob(this.app.id),
	//                 itob(validatorID),
	//                 itob(numPools as uint64),
	//                 itob(this.ValidatorList(validatorID).value.Config.MinEntryStake),
	//                 itob(this.ValidatorList(validatorID).value.Config.MaxAlgoPerPool),
	//             ],
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:461
	// onCompletion: OnCompletion.NoOp
	int 0 // NoOp
	itxn_field OnCompletion

	// contracts/validatorRegistry.algo.ts:462
	// approvalProgram: AppID.fromUint64(this.StakingPoolTemplateAppID.value).approvalProgram
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppApprovalProgram
	pop
	itxn_field ApprovalProgram

	// contracts/validatorRegistry.algo.ts:463
	// clearStateProgram: AppID.fromUint64(this.StakingPoolTemplateAppID.value).clearStateProgram
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppClearStateProgram
	pop
	itxn_field ClearStateProgram

	// contracts/validatorRegistry.algo.ts:464
	// globalNumUint: AppID.fromUint64(this.StakingPoolTemplateAppID.value).globalNumUint
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppGlobalNumUint
	pop
	itxn_field GlobalNumUint

	// contracts/validatorRegistry.algo.ts:465
	// globalNumByteSlice: AppID.fromUint64(this.StakingPoolTemplateAppID.value).globalNumByteSlice
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppGlobalNumByteSlice
	pop
	itxn_field GlobalNumByteSlice

	// contracts/validatorRegistry.algo.ts:466
	// extraProgramPages: AppID.fromUint64(this.StakingPoolTemplateAppID.value).extraProgramPages
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppExtraProgramPages
	pop
	itxn_field ExtraProgramPages

	// contracts/validatorRegistry.algo.ts:467
	// applicationArgs: [
	//                 // creatingContractID, validatorID, poolID, minEntryStake, maxStakeAllowed
	//                 method('createApplication(uint64,uint64,uint64,uint64,uint64)void'),
	//                 itob(this.app.id),
	//                 itob(validatorID),
	//                 itob(numPools as uint64),
	//                 itob(this.ValidatorList(validatorID).value.Config.MinEntryStake),
	//                 itob(this.ValidatorList(validatorID).value.Config.MaxAlgoPerPool),
	//             ]
	method "createApplication(uint64,uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs
	txna Applications 0
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // validatorID: ValidatorID
	itob
	itxn_field ApplicationArgs
	frame_dig 0 // numPools: uint16
	itob
	itxn_field ApplicationArgs
	int 174
	int 8
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs
	int 182
	int 8
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:478
	// this.ValidatorList(validatorID).value.State.NumPools = numPools
	int 191
	frame_dig 0 // numPools: uint16
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:481
	// this.ValidatorList(validatorID).value.Pools[numPools - 1].PoolAppID = this.itxn.createdApplicationID.id
	int 209 // headOffset
	frame_dig 0 // numPools: uint16
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 0
	+
	itxn CreatedApplicationID
	itob
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:482
	// this.addPoolToNode(validatorID, this.itxn.createdApplicationID.id, nodeNum)
	frame_dig -3 // nodeNum: uint64
	itxn CreatedApplicationID
	frame_dig -2 // validatorID: ValidatorID
	callsub addPoolToNode

	// contracts/validatorRegistry.algo.ts:485
	// return { ID: validatorID, PoolID: numPools as uint64, PoolAppID: this.itxn!.createdApplicationID.id };
	frame_dig -2 // validatorID: ValidatorID
	itob
	frame_dig 0 // numPools: uint16
	itob
	concat
	itxn CreatedApplicationID
	itob
	concat

	// set the subroutine return value
	frame_bury 0
	retsub

// addStake(pay,uint64,uint64)(uint64,uint64,uint64)
*abi_route_addStake:
	// The ABI return prefix
	byte 0x151f7c75

	// tokenToVerify: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// stakedAmountPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute addStake(pay,uint64,uint64)(uint64,uint64,uint64)
	callsub addStake
	concat
	log
	int 1
	return

// addStake(stakedAmountPayment: PayTxn, validatorID: ValidatorID, tokenToVerify: uint64): ValidatorPoolKey
//
// Adds stake to a validator pool.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorID} validatorID - The ID of the validator.
// @param {uint64} tokenToVerify - only if validator requires a token to enter, this is ID of token to offer up as
// matching the validators requirement. If set, ensures staker posseses token (and optionally correct amount) and
// that the token was created by the correct creator.
// @returns {ValidatorPoolKey} - The key of the validator pool.
addStake:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 6

	// contracts/validatorRegistry.algo.ts:499
	// assert(this.ValidatorList(validatorID).exists)
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:501
	// staker = this.txn.sender
	txn Sender
	frame_bury 0 // staker: address

	// contracts/validatorRegistry.algo.ts:505
	// verifyPayTxn(stakedAmountPayment, {
	//             sender: staker,
	//             receiver: this.app.address,
	//         })
	// verify sender
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	frame_dig 0 // staker: address
	==
	assert

	// verify receiver
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// *if6_condition
	// contracts/validatorRegistry.algo.ts:513
	// this.ValidatorList(validatorID).value.Config.MustHoldCreatorNFT !== globals.zeroAddress
	int 80
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	global ZeroAddress
	!=
	bz *if6_end

	// *if6_consequent
	// contracts/validatorRegistry.algo.ts:514
	// assert(tokenToVerify !== 0)
	frame_dig -3 // tokenToVerify: uint64
	int 0
	!=
	assert

	// contracts/validatorRegistry.algo.ts:515
	// balRequired = this.ValidatorList(validatorID).value.Config.CreatorNFTMinBalance
	int 112
	int 8
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // balRequired: uint64

	// *if7_condition
	// contracts/validatorRegistry.algo.ts:516
	// balRequired === 0
	frame_dig 1 // balRequired: uint64
	int 0
	==
	bz *if7_end

	// *if7_consequent
	// contracts/validatorRegistry.algo.ts:517
	// balRequired = 1
	int 1
	frame_bury 1 // balRequired: uint64

*if7_end:
	// contracts/validatorRegistry.algo.ts:519
	// assert(
	//                 staker.assetBalance(AssetID.fromUint64(tokenToVerify)) === balRequired,
	//                 'must have required minimum balance of validator defined token to add stake'
	//             )
	frame_dig 0 // staker: address
	frame_dig -3 // tokenToVerify: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 1 // balRequired: uint64
	==

	// must have required minimum balance of validator defined token to add stake
	assert

	// contracts/validatorRegistry.algo.ts:523
	// assert(
	//                 AssetID.fromUint64(tokenToVerify).creator ===
	//                     this.ValidatorList(validatorID).value.Config.MustHoldCreatorNFT,
	//                 'specified asset must be created by creator that the validator defined as a requirement to stake'
	//             )
	frame_dig -3 // tokenToVerify: uint64
	asset_params_get AssetCreator
	pop
	int 80
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==

	// specified asset must be created by creator that the validator defined as a requirement to stake
	assert

*if6_end:
	// contracts/validatorRegistry.algo.ts:530
	// realAmount = stakedAmountPayment.amount
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_bury 2 // realAmount: uint64

	// contracts/validatorRegistry.algo.ts:531
	// mbrAmtLeftBehind: uint64 = 0
	int 0
	frame_bury 3 // mbrAmtLeftBehind: uint64

	// *if8_condition
	// contracts/validatorRegistry.algo.ts:533
	// !this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig 0 // staker: address
	concat
	box_len
	swap
	pop
	!
	bz *if8_end

	// *if8_consequent
	// contracts/validatorRegistry.algo.ts:536
	// mbrAmtLeftBehind = this.getMbrAmounts().AddStakerMbr
	callsub getMbrAmounts
	extract 24 8
	btoi
	frame_bury 3 // mbrAmtLeftBehind: uint64

	// contracts/validatorRegistry.algo.ts:537
	// realAmount -= mbrAmtLeftBehind
	frame_dig 2 // realAmount: uint64
	frame_dig 3 // mbrAmtLeftBehind: uint64
	-
	frame_bury 2 // realAmount: uint64

	// contracts/validatorRegistry.algo.ts:538
	// this.StakerPoolSet(staker).create()
	byte 0x737073 // "sps"
	frame_dig 0 // staker: address
	concat
	int 144
	box_create
	pop

*if8_end:
	// contracts/validatorRegistry.algo.ts:542
	// findRet = this.findPoolForStaker(validatorID, staker, realAmount)
	frame_dig 2 // realAmount: uint64
	frame_dig 0 // staker: address
	frame_dig -2 // validatorID: ValidatorID
	callsub findPoolForStaker
	frame_bury 4 // findRet: ((uint64,uint64,uint64),bool,bool)

	// contracts/validatorRegistry.algo.ts:543
	// poolKey = findRet[0]
	// contracts/validatorRegistry.algo.ts:544
	// isNewStakerToValidator = findRet[1]
	frame_dig 4 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	int 192
	getbit
	frame_bury 5 // isNewStakerToValidator: bool

	// contracts/validatorRegistry.algo.ts:545
	// isNewStakerToProtocol = findRet[2]
	frame_dig 4 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	int 193
	getbit
	frame_bury 6 // isNewStakerToProtocol: bool

	// *if9_condition
	// contracts/validatorRegistry.algo.ts:546
	// poolKey.PoolID === 0
	frame_dig 4 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	int 0
	==
	bz *if9_end

	// *if9_consequent
	err // 'No pool available with free stake.  Validator needs to add another pool'

*if9_end:
	// contracts/validatorRegistry.algo.ts:551
	// this.updateStakerPoolSet(staker, poolKey)
	frame_dig 4 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24
	frame_dig 0 // staker: address
	callsub updateStakerPoolSet

	// contracts/validatorRegistry.algo.ts:554
	// this.callPoolAddStake(
	//             stakedAmountPayment,
	//             poolKey,
	//             mbrAmtLeftBehind,
	//             isNewStakerToValidator,
	//             isNewStakerToProtocol
	//         )
	frame_dig 6 // isNewStakerToProtocol: bool
	frame_dig 5 // isNewStakerToValidator: bool
	frame_dig 3 // mbrAmtLeftBehind: uint64
	frame_dig 4 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24
	frame_dig -1 // stakedAmountPayment: PayTxn
	callsub callPoolAddStake

	// contracts/validatorRegistry.algo.ts:561
	// return poolKey;
	frame_dig 4 // findRet: ((uint64,uint64,uint64),bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 24

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 6
	retsub

// verifyPoolKeyCaller(poolKey: ValidatorPoolKey): void
verifyPoolKeyCaller:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:568
	// assert(this.ValidatorList(poolKey.ID).exists)
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:569
	// assert((poolKey.PoolID as uint64) < 2 ** 16)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 2
	int 16
	exp
	<
	assert

	// contracts/validatorRegistry.algo.ts:570
	// assert(poolKey.PoolID > 0 && (poolKey.PoolID as uint16) <= this.ValidatorList(poolKey.ID).value.State.NumPools)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 0
	>
	dup
	bz *skip_and1
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 191
	int 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	<=
	&&

*skip_and1:
	assert

	// contracts/validatorRegistry.algo.ts:573
	// assert(
	//             poolKey.PoolAppID === this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].PoolAppID,
	//             "The passed in app id doesn't match the passed in ids"
	//         )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 0
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	==

	// The passed in app id doesn't match the passed in ids
	assert

	// contracts/validatorRegistry.algo.ts:578
	// assert(this.txn.sender === AppID.fromUint64(poolKey.PoolAppID).address)
	txn Sender
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// contracts/validatorRegistry.algo.ts:580
	// assert(poolKey.ID === (AppID.fromUint64(poolKey.PoolAppID).globalState('validatorID') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	byte 0x76616c696461746f724944 // "validatorID"
	app_global_get_ex
	assert
	==
	assert

	// contracts/validatorRegistry.algo.ts:581
	// assert(poolKey.PoolID === (AppID.fromUint64(poolKey.PoolAppID).globalState('poolID') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	byte 0x706f6f6c4944 // "poolID"
	app_global_get_ex
	assert
	==
	assert
	retsub

// stakeUpdatedViaRewards((uint64,uint64,uint64),uint64)void
*abi_route_stakeUpdatedViaRewards:
	// amountToAdd: uint64
	txna ApplicationArgs 2
	btoi

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute stakeUpdatedViaRewards((uint64,uint64,uint64),uint64)void
	callsub stakeUpdatedViaRewards
	int 1
	return

// stakeUpdatedViaRewards(poolKey: ValidatorPoolKey, amountToAdd: uint64): void
//
// stakeUpdatedViaRewards is called by Staking Pools to inform the validator (us) that a particular amount of total
// stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App ID is validated against our pool list as well.
// @param poolKey - ValidatorPoolKey type
// @param amountToAdd - amount this validator's total stake increased via rewards
stakeUpdatedViaRewards:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:592
	// this.verifyPoolKeyCaller(poolKey)
	frame_dig -1 // poolKey: ValidatorPoolKey
	callsub verifyPoolKeyCaller

	// contracts/validatorRegistry.algo.ts:595
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalAlgoStaked += amountToAdd
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToAdd: uint64
	+
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:596
	// this.ValidatorList(poolKey.ID).value.State.TotalAlgoStaked += amountToAdd
	int 201
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToAdd: uint64
	+
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:598
	// this.TotalAlgoStaked.value += amountToAdd
	byte 0x7374616b6564 // "staked"
	app_global_get
	frame_dig -2 // amountToAdd: uint64
	+
	byte 0x7374616b6564 // "staked"
	swap
	app_global_put

	// contracts/validatorRegistry.algo.ts:601
	// this.reverifyNFDOwnership(poolKey.ID)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	callsub reverifyNFDOwnership
	retsub

// stakeRemoved((uint64,uint64,uint64),address,uint64,bool)void
*abi_route_stakeRemoved:
	// stakerRemoved: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// amountRemoved: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute stakeRemoved((uint64,uint64,uint64),address,uint64,bool)void
	callsub stakeRemoved
	int 1
	return

// stakeRemoved(poolKey: ValidatorPoolKey, staker: Address, amountRemoved: uint64, stakerRemoved: boolean): void
//
// stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removed
// from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App ID is validated against our pool list as well.
// @param poolKey - ValidatorPoolKey type - [validatorID, PoolID] compound type
// @param staker
// @param amountRemoved
// @param stakerRemoved
stakeRemoved:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// *if10_condition
	// contracts/validatorRegistry.algo.ts:614
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if10_end

	// *if10_consequent
	// contracts/validatorRegistry.algo.ts:615
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if10_end:
	// contracts/validatorRegistry.algo.ts:617
	// this.verifyPoolKeyCaller(poolKey)
	frame_dig -1 // poolKey: ValidatorPoolKey
	callsub verifyPoolKeyCaller

	// contracts/validatorRegistry.algo.ts:621
	// assert(amountRemoved > 0)
	frame_dig -3 // amountRemoved: uint64
	int 0
	>
	assert

	// contracts/validatorRegistry.algo.ts:624
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalAlgoStaked -= amountRemoved
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:625
	// this.ValidatorList(poolKey.ID).value.State.TotalAlgoStaked -= amountRemoved
	int 201
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:626
	// this.TotalAlgoStaked.value -= amountRemoved
	byte 0x7374616b6564 // "staked"
	app_global_get
	frame_dig -3 // amountRemoved: uint64
	-
	byte 0x7374616b6564 // "staked"
	swap
	app_global_put

	// *if11_condition
	// contracts/validatorRegistry.algo.ts:628
	// stakerRemoved
	frame_dig -4 // stakerRemoved: boolean
	bz *if11_end

	// *if11_consequent
	// contracts/validatorRegistry.algo.ts:630
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalStakers -= 1
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 8 // headOffset
	+
	int 209 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 8 // headOffset
	+
	int 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	int 1
	-
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:632
	// removeRet = this.removeFromStakerPoolSet(staker, <ValidatorPoolKey>{
	//                 ID: poolKey.ID,
	//                 PoolID: poolKey.PoolID,
	//                 PoolAppID: poolKey.PoolAppID,
	//             })
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	callsub removeFromStakerPoolSet
	frame_bury 0 // removeRet: (bool,bool)

	// contracts/validatorRegistry.algo.ts:637
	// stakerOutOfThisValidator = removeRet[0]
	frame_dig 0 // removeRet: (bool,bool)
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	frame_bury 1 // stakerOutOfThisValidator: bool

	// contracts/validatorRegistry.algo.ts:638
	// stakerOutOfProtocol = removeRet[1]
	frame_dig 0 // removeRet: (bool,bool)
	store 255 // full array
	load 255 // full array
	int 1
	getbit
	frame_bury 2 // stakerOutOfProtocol: bool

	// *if12_condition
	// contracts/validatorRegistry.algo.ts:640
	// stakerOutOfThisValidator
	frame_dig 1 // stakerOutOfThisValidator: bool
	bz *if12_end

	// *if12_consequent
	// contracts/validatorRegistry.algo.ts:641
	// this.ValidatorList(poolKey.ID).value.State.TotalStakers -= 1
	int 193
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	int 1
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

*if12_end:
	// *if13_condition
	// contracts/validatorRegistry.algo.ts:644
	// stakerOutOfProtocol
	frame_dig 2 // stakerOutOfProtocol: bool
	bz *if13_end

	// *if13_consequent
	// contracts/validatorRegistry.algo.ts:645
	// this.NumStakers.value -= 1
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 1
	-
	byte 0x6e756d5374616b657273 // "numStakers"
	swap
	app_global_put

*if13_end:

*if11_end:
	retsub

// findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)
*abi_route_findPoolForStaker:
	// The ABI return prefix
	byte 0x151f7c75

	// amountToStake: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)
	callsub findPoolForStaker
	concat
	log
	int 1
	return

// findPoolForStaker(validatorID: ValidatorID, staker: Address, amountToStake: uint64): [ValidatorPoolKey, boolean, boolean]
//
// Finds the pool for a staker based on the provided validator ID, staker address, and amount to stake.
// First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
// to new pool if necessary.
//
// @param {ValidatorID} validatorID - The ID of the validator.
// @param {Address} staker - The address of the staker.
// @param {uint64} amountToStake - The amount to stake.
// @returns {ValidatorPoolKey, boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
// to this validator, and true/false if staker is new to the protocol.
findPoolForStaker:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts/validatorRegistry.algo.ts:666
	// isNewStakerToValidator = true
	int 1
	frame_bury 0 // isNewStakerToValidator: bool

	// contracts/validatorRegistry.algo.ts:667
	// isNewStakerToProtocol = true
	int 1
	frame_bury 1 // isNewStakerToProtocol: bool

	// contracts/validatorRegistry.algo.ts:671
	// maxPerPool = this.ValidatorList(validatorID).value.Config.MaxAlgoPerPool
	int 182
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // maxPerPool: uint64

	// *if14_condition
	// contracts/validatorRegistry.algo.ts:674
	// this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig -2 // staker: Address
	concat
	box_len
	swap
	pop
	bz *if14_end

	// *if14_consequent
	// contracts/validatorRegistry.algo.ts:675
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -2 // staker: Address
	concat
	box_get
	assert
	frame_bury 3 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:676
	// assert(validatorID !== 0)
	frame_dig -1 // validatorID: ValidatorID
	int 0
	!=
	assert

	// contracts/validatorRegistry.algo.ts:677
	// for (let i = 0; i < poolSet.length; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_2:
	// contracts/validatorRegistry.algo.ts:677
	// i < poolSet.length
	frame_dig 4 // i: uint64
	int 6
	<
	bz *for_2_end

	// *if15_condition
	// contracts/validatorRegistry.algo.ts:678
	// globals.opcodeBudget < 300
	global OpcodeBudget
	int 300
	<
	bz *if15_end

	// *if15_consequent
	// contracts/validatorRegistry.algo.ts:679
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if15_end:
	// *if16_condition
	// contracts/validatorRegistry.algo.ts:681
	// poolSet[i].ID === 0
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	int 0
	==
	bz *if16_end

	// *if16_consequent
	b *for_2_continue

*if16_end:
	// contracts/validatorRegistry.algo.ts:684
	// isNewStakerToProtocol = false
	int 0
	frame_bury 1 // isNewStakerToProtocol: bool

	// *if17_condition
	// contracts/validatorRegistry.algo.ts:685
	// poolSet[i].ID === validatorID
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	frame_dig -1 // validatorID: ValidatorID
	==
	bz *if17_end

	// *if17_consequent
	// contracts/validatorRegistry.algo.ts:687
	// isNewStakerToValidator = false
	int 0
	frame_bury 0 // isNewStakerToValidator: bool

	// *if18_condition
	// contracts/validatorRegistry.algo.ts:689
	// this.ValidatorList(validatorID).value.Pools[poolSet[i].PoolID - 1].TotalAlgoStaked +
	//                             amountToStake <=
	//                         maxPerPool
	int 209 // headOffset
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 8 // headOffset
	+
	int 8
	extract3
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 2 // maxPerPool: uint64
	<=
	bz *if18_end

	// *if18_consequent
	// contracts/validatorRegistry.algo.ts:693
	// return [poolSet[i], isNewStakerToValidator, isNewStakerToProtocol];
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3
	byte 0x00
	int 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	int 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

*if18_end:

*if17_end:

*for_2_continue:
	// contracts/validatorRegistry.algo.ts:677
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_2

*for_2_end:

*if14_end:
	// contracts/validatorRegistry.algo.ts:700
	// assert(
	//             amountToStake >= this.ValidatorList(validatorID).value.Config.MinEntryStake,
	//             'must stake at least the minimum for this pool'
	//         )
	frame_dig -3 // amountToStake: uint64
	int 174
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	>=

	// must stake at least the minimum for this pool
	assert

	// contracts/validatorRegistry.algo.ts:706
	// pools = clone(this.ValidatorList(validatorID).value.Pools)
	int 209 // headOffset
	int 216
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 5 // pools: (uint64,uint16,uint64)[12]

	// contracts/validatorRegistry.algo.ts:707
	// curNumPools = this.ValidatorList(validatorID).value.State.NumPools as uint64
	int 191
	int 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 6 // curNumPools: uint64

	// contracts/validatorRegistry.algo.ts:708
	// for (let i = 0; i < curNumPools; i += 1)
	int 0
	frame_bury 7 // i: uint64

*for_3:
	// contracts/validatorRegistry.algo.ts:708
	// i < curNumPools
	frame_dig 7 // i: uint64
	frame_dig 6 // curNumPools: uint64
	<
	bz *for_3_end

	// *if19_condition
	// contracts/validatorRegistry.algo.ts:709
	// pools[i].TotalAlgoStaked + amountToStake <= maxPerPool
	frame_dig 5 // pools: (uint64,uint16,uint64)[12]
	frame_dig 7 // i: uint64
	int 18
	* // acc * typeLength
	int 10 // headOffset
	+
	int 8
	extract3
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 2 // maxPerPool: uint64
	<=
	bz *if19_end

	// *if19_consequent
	// contracts/validatorRegistry.algo.ts:710
	// return [
	//                     { ID: validatorID, PoolID: i + 1, PoolAppID: pools[i].PoolAppID },
	//                     isNewStakerToValidator,
	//                     isNewStakerToProtocol,
	//                 ];
	frame_dig -1 // validatorID: ValidatorID
	itob
	frame_dig 7 // i: uint64
	int 1
	+
	itob
	concat
	frame_dig 5 // pools: (uint64,uint16,uint64)[12]
	frame_dig 7 // i: uint64
	int 18
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	itob
	concat
	byte 0x00
	int 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	int 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

*if19_end:

*for_3_continue:
	// contracts/validatorRegistry.algo.ts:708
	// i += 1
	frame_dig 7 // i: uint64
	int 1
	+
	frame_bury 7 // i: uint64
	b *for_3

*for_3_end:
	// contracts/validatorRegistry.algo.ts:718
	// return [{ ID: validatorID, PoolID: 0, PoolAppID: 0 }, isNewStakerToValidator, isNewStakerToProtocol];
	frame_dig -1 // validatorID: ValidatorID
	itob
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x00
	int 0
	frame_dig 0 // isNewStakerToValidator: bool
	setbit
	int 1
	frame_dig 1 // isNewStakerToProtocol: bool
	setbit
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// movePoolToNode(uint64,uint64,uint64)void
*abi_route_movePoolToNode:
	// nodeNum: uint64
	txna ApplicationArgs 3
	btoi

	// poolAppID: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute movePoolToNode(uint64,uint64,uint64)void
	callsub movePoolToNode
	int 1
	return

// movePoolToNode(validatorID: ValidatorID, poolAppID: uint64, nodeNum: uint64): void
//
// Find the specified pool (in any node number) and move it to the specified node.
// The pool account is forced offline if moved so prior node will still run for 320 rounds but
// new key goes online on new node soon after (320 rounds after it goes online)
// No-op if success, asserts if not found or can't move  (no space in target)
// Only callable by owner or manager
movePoolToNode:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:730
	// assert(
	//             this.txn.sender === this.ValidatorList(validatorID).value.Config.Owner ||
	//                 this.txn.sender === this.ValidatorList(validatorID).value.Config.Manager
	//         )
	txn Sender
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz *skip_or3
	txn Sender
	int 40
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	||

*skip_or3:
	assert

	// contracts/validatorRegistry.algo.ts:735
	// nodePoolAssignments = clone(this.ValidatorList(validatorID).value.NodePoolAssignments)
	int 425 // headOffset
	int 96
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // nodePoolAssignments: ((uint64[3])[4])

	// contracts/validatorRegistry.algo.ts:736
	// assert(nodeNum >= 1 && nodeNum <= MAX_NODES)
	frame_dig -3 // nodeNum: uint64
	int 1
	>=
	dup
	bz *skip_and2
	frame_dig -3 // nodeNum: uint64
	int 4
	<=
	&&

*skip_and2:
	assert

	// contracts/validatorRegistry.algo.ts:738
	// for (let srcNodeIdx = 0; srcNodeIdx < MAX_NODES; srcNodeIdx += 1)
	int 0
	frame_bury 1 // srcNodeIdx: uint64

*for_4:
	// contracts/validatorRegistry.algo.ts:738
	// srcNodeIdx < MAX_NODES
	frame_dig 1 // srcNodeIdx: uint64
	int 4
	<
	bz *for_4_end

	// contracts/validatorRegistry.algo.ts:739
	// for (let i = 0; i < MAX_POOLS_PER_NODE; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_5:
	// contracts/validatorRegistry.algo.ts:739
	// i < MAX_POOLS_PER_NODE
	frame_dig 2 // i: uint64
	int 3
	<
	bz *for_5_end

	// *if20_condition
	// contracts/validatorRegistry.algo.ts:740
	// nodePoolAssignments.Nodes[srcNodeIdx].PoolAppIDs[i] === poolAppID
	frame_dig 0 // nodePoolAssignments: ((uint64[3])[4])
	int 0
	frame_dig 1 // srcNodeIdx: uint64
	int 24
	* // acc * typeLength
	+
	int 0
	+
	frame_dig 2 // i: uint64
	int 8
	* // acc * typeLength
	+
	int 8
	extract3
	btoi
	frame_dig -2 // poolAppID: uint64
	==
	bz *if20_end

	// *if20_consequent
	// contracts/validatorRegistry.algo.ts:741
	// assert(nodeNum - 1 !== srcNodeIdx, "can't move to same node")
	frame_dig -3 // nodeNum: uint64
	int 1
	-
	frame_dig 1 // srcNodeIdx: uint64
	!=

	// can't move to same node
	assert

	// contracts/validatorRegistry.algo.ts:743
	// this.ValidatorList(validatorID).value.NodePoolAssignments.Nodes[srcNodeIdx].PoolAppIDs[i] = 0
	int 425
	frame_dig 1 // srcNodeIdx: uint64
	int 24
	* // acc * typeLength
	+
	int 0
	+
	frame_dig 2 // i: uint64
	int 8
	* // acc * typeLength
	+
	byte 0x0000000000000000
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:746
	// sendMethodCall<typeof StakingPool.prototype.goOffline>({
	//                         applicationID: AppID.fromUint64(poolAppID),
	//                     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "goOffline()void"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:747
	// applicationID: AppID.fromUint64(poolAppID)
	frame_dig -2 // poolAppID: uint64
	itxn_field ApplicationID

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:751
	// this.addPoolToNode(validatorID, poolAppID, nodeNum)
	frame_dig -3 // nodeNum: uint64
	frame_dig -2 // poolAppID: uint64
	frame_dig -1 // validatorID: ValidatorID
	callsub addPoolToNode

	// contracts/validatorRegistry.algo.ts:752
	// return;
	retsub

*if20_end:

*for_5_continue:
	// contracts/validatorRegistry.algo.ts:739
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_5

*for_5_end:

*for_4_continue:
	// contracts/validatorRegistry.algo.ts:738
	// srcNodeIdx += 1
	frame_dig 1 // srcNodeIdx: uint64
	int 1
	+
	frame_bury 1 // srcNodeIdx: uint64
	b *for_4

*for_4_end:
	err // "couldn't find pool app id in nodes to move"

// reverifyNFDOwnership(validatorID: ValidatorID): void
//
// This method verifies the ownership of NFD (Named Function Data) by a validator.
// If the ownership is no longer valid, it removes the NFD from the validator's configuration.
//
// @param {ValidatorID} validatorID - The ID of the validator whose data should be re-evaluated.
reverifyNFDOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/validatorRegistry.algo.ts:766
	// validatorConfig = this.ValidatorList(validatorID).value.Config
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	frame_bury 0 // storage key//validatorConfig

	// *if21_condition
	// contracts/validatorRegistry.algo.ts:767
	// validatorConfig.NFDForInfo !== 0
	int 72
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	int 0
	!=
	bz *if21_end

	// *if21_consequent
	// contracts/validatorRegistry.algo.ts:770
	// nfdOwner = AppID.fromUint64(validatorConfig.NFDForInfo).globalState('i.owner.a') as Address
	int 72
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex
	assert
	frame_bury 1 // nfdOwner: address

	// *if22_condition
	// contracts/validatorRegistry.algo.ts:772
	// validatorConfig.Owner !== nfdOwner && validatorConfig.Manager !== nfdOwner
	int 8
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_dig 1 // nfdOwner: address
	!=
	dup
	bz *skip_and3
	int 40
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_dig 1 // nfdOwner: address
	!=
	&&

*skip_and3:
	bz *if22_end

	// *if22_consequent
	// contracts/validatorRegistry.algo.ts:774
	// this.ValidatorList(validatorID).value.Config.NFDForInfo = 0
	int 72
	byte 0x0000000000000000
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

*if22_end:

*if21_end:
	retsub

// validateConfig(config: ValidatorConfig): void
validateConfig:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:781
	// assert(config.PayoutEveryXMins >= MIN_PAYOUT_MINS && config.PayoutEveryXMins <= MAX_PAYOUT_MINS)
	frame_dig -1 // config: ValidatorConfig
	extract 136 2
	btoi
	int 1
	>=
	dup
	bz *skip_and4
	frame_dig -1 // config: ValidatorConfig
	extract 136 2
	btoi
	int 10080
	<=
	&&

*skip_and4:
	assert

	// contracts/validatorRegistry.algo.ts:782
	// assert(config.PercentToValidator >= MIN_PCT_TO_VALIDATOR && config.PercentToValidator <= MAX_PCT_TO_VALIDATOR)
	frame_dig -1 // config: ValidatorConfig
	extract 138 4
	btoi
	int 0
	>=
	dup
	bz *skip_and5
	frame_dig -1 // config: ValidatorConfig
	extract 138 4
	btoi
	int 1000000
	<=
	&&

*skip_and5:
	assert

	// *if23_condition
	// contracts/validatorRegistry.algo.ts:783
	// config.PercentToValidator !== 0
	frame_dig -1 // config: ValidatorConfig
	extract 138 4
	btoi
	int 0
	!=
	bz *if23_end

	// *if23_consequent
	// contracts/validatorRegistry.algo.ts:784
	// assert(
	//                 config.ValidatorCommissionAddress !== Address.zeroAddress,
	//                 'ValidatorCommissionAddress must be set if percent to validator is not 0'
	//             )
	frame_dig -1 // config: ValidatorConfig
	extract 142 32
	global ZeroAddress
	!=

	// ValidatorCommissionAddress must be set if percent to validator is not 0
	assert

*if23_end:
	// contracts/validatorRegistry.algo.ts:789
	// assert(config.MinEntryStake >= MIN_ALGO_STAKE_PER_POOL)
	frame_dig -1 // config: ValidatorConfig
	extract 174 8
	btoi
	int 1000000
	>=
	assert

	// contracts/validatorRegistry.algo.ts:790
	// assert(config.MaxAlgoPerPool <= MAX_ALGO_PER_POOL, 'enforce hard constraint to be safe to the network')
	frame_dig -1 // config: ValidatorConfig
	extract 182 8
	btoi
	int 50000000000000
	<=

	// enforce hard constraint to be safe to the network
	assert

	// contracts/validatorRegistry.algo.ts:791
	// assert(config.PoolsPerNode > 0 && config.PoolsPerNode <= MAX_POOLS_PER_NODE)
	frame_dig -1 // config: ValidatorConfig
	extract 190 1
	btoi
	int 0
	>
	dup
	bz *skip_and6
	frame_dig -1 // config: ValidatorConfig
	extract 190 1
	btoi
	int 3
	<=
	&&

*skip_and6:
	assert
	retsub

// callPoolAddStake(stakedAmountPayment: PayTxn, poolKey: ValidatorPoolKey, mbrAmtPaid: uint64, isNewStakerToValidator: boolean, isNewStakerToProtocol: boolean): void
//
// Adds a stakers amount of algo to a validator pool, transferring the algo we received from them (already verified
// by our caller) to the staking pool account, and then telling it about the amount being added for the specified
// staker.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorPoolKey} poolKey - The key of the validator pool.
// @param {uint64} mbrAmtPaid - Amount the user is leaving behind in the validator to pay for their Staker MBR cost
// @param {boolean} isNewStakerToValidator - if this is a new, first-time staker to the validator
// @param {boolean} isNewStakerToProtocol - if this is a new, first-time staker to the protocol
callPoolAddStake:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// *if24_condition
	// contracts/validatorRegistry.algo.ts:812
	// globals.opcodeBudget < 500
	global OpcodeBudget
	int 500
	<
	bz *if24_end

	// *if24_consequent
	// contracts/validatorRegistry.algo.ts:813
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if24_end:
	// contracts/validatorRegistry.algo.ts:815
	// poolAppID = this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].PoolAppID
	int 209 // headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 0
	+
	int 8
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // poolAppID: uint64

	// contracts/validatorRegistry.algo.ts:819
	// sendMethodCall<typeof StakingPool.prototype.addStake>({
	//             applicationID: AppID.fromUint64(poolAppID),
	//             methodArgs: [
	//                 // =======
	//                 // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//                 { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: AppID.fromUint64(poolAppID).address },
	//                 // =======
	//                 stakedAmountPayment.sender,
	//             ],
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:824
	// amount: stakedAmountPayment.amount - mbrAmtPaid
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	itxn_field Amount

	// contracts/validatorRegistry.algo.ts:824
	// receiver: AppID.fromUint64(poolAppID).address
	frame_dig 0 // poolAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee
	itxn_next
	int appl
	itxn_field TypeEnum
	method "addStake(pay,address)uint64"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:820
	// applicationID: AppID.fromUint64(poolAppID)
	frame_dig 0 // poolAppID: uint64
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:821
	// methodArgs: [
	//                 // =======
	//                 // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//                 { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: AppID.fromUint64(poolAppID).address },
	//                 // =======
	//                 stakedAmountPayment.sender,
	//             ]
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	btoi

	// contracts/validatorRegistry.algo.ts:831
	// poolNumStakers = AppID.fromUint64(poolAppID).globalState('numStakers') as uint64
	frame_dig 0 // poolAppID: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get_ex
	assert
	frame_bury 1 // poolNumStakers: uint64

	// contracts/validatorRegistry.algo.ts:832
	// poolAlgoStaked = AppID.fromUint64(poolAppID).globalState('staked') as uint64
	frame_dig 0 // poolAppID: uint64
	byte 0x7374616b6564 // "staked"
	app_global_get_ex
	assert
	frame_bury 2 // poolAlgoStaked: uint64

	// contracts/validatorRegistry.algo.ts:833
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalStakers = poolNumStakers as uint16
	int 209 // headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 8 // headOffset
	+
	frame_dig 1 // poolNumStakers: uint64
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:834
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalAlgoStaked = poolAlgoStaked
	int 209 // headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 18
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	frame_dig 2 // poolAlgoStaked: uint64
	itob
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// *if25_condition
	// contracts/validatorRegistry.algo.ts:837
	// isNewStakerToValidator
	frame_dig -4 // isNewStakerToValidator: boolean
	bz *if25_end

	// *if25_consequent
	// contracts/validatorRegistry.algo.ts:838
	// this.ValidatorList(poolKey.ID).value.State.TotalStakers += 1
	int 193
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	int 1
	+
	itob
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

*if25_end:
	// *if26_condition
	// contracts/validatorRegistry.algo.ts:840
	// isNewStakerToProtocol
	frame_dig -5 // isNewStakerToProtocol: boolean
	bz *if26_end

	// *if26_consequent
	// contracts/validatorRegistry.algo.ts:841
	// this.NumStakers.value += 1
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get
	int 1
	+
	byte 0x6e756d5374616b657273 // "numStakers"
	swap
	app_global_put

*if26_end:
	// contracts/validatorRegistry.algo.ts:843
	// this.ValidatorList(poolKey.ID).value.State.TotalAlgoStaked += stakedAmountPayment.amount - mbrAmtPaid
	int 201
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	itob
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:844
	// this.TotalAlgoStaked.value += stakedAmountPayment.amount - mbrAmtPaid
	byte 0x7374616b6564 // "staked"
	app_global_get
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	byte 0x7374616b6564 // "staked"
	swap
	app_global_put
	retsub

// updateStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): void
updateStakerPoolSet:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/validatorRegistry.algo.ts:848
	// assert(this.StakerPoolSet(staker).exists)
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:850
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_get
	assert
	frame_bury 0 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:851
	// for (let i = 0; i < this.StakerPoolSet(staker).value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

*for_6:
	// contracts/validatorRegistry.algo.ts:851
	// i < this.StakerPoolSet(staker).value.length
	frame_dig 1 // i: uint64
	int 6
	<
	bz *for_6_end

	// *if27_condition
	// contracts/validatorRegistry.algo.ts:852
	// poolSet[i] === poolKey
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz *if27_end

	// *if27_consequent
	// contracts/validatorRegistry.algo.ts:854
	// return;
	retsub

*if27_end:
	// *if28_condition
	// contracts/validatorRegistry.algo.ts:856
	// poolSet[i].ID === 0
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	int 0
	==
	bz *if28_end

	// *if28_consequent
	// contracts/validatorRegistry.algo.ts:857
	// this.StakerPoolSet(staker).value[i] = poolKey
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	frame_dig -2 // poolKey: ValidatorPoolKey
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:858
	// return;
	retsub

*if28_end:

*for_6_continue:
	// contracts/validatorRegistry.algo.ts:851
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_6

*for_6_end:
	err // 'No empty slot available in the staker pool set'

// removeFromStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): [boolean, boolean]
//
// Removes a pool key from the staker's active pool set - fails if not found (!)
//
// @param {Address} staker - The address of the staker.
// @param {ValidatorPoolKey} poolKey - The pool key they should be stored in
//
// @return [boolean, boolean] [is the staker gone from ALL pools of the given VALIDATOR, and is staker gone from ALL pools]
removeFromStakerPoolSet:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/validatorRegistry.algo.ts:874
	// inSameValidatorPoolCount = 0
	int 0
	frame_bury 0 // inSameValidatorPoolCount: uint64

	// contracts/validatorRegistry.algo.ts:875
	// inAnyPoolCount = 0
	int 0
	frame_bury 1 // inAnyPoolCount: uint64

	// contracts/validatorRegistry.algo.ts:876
	// found = false
	int 0
	frame_bury 2 // found: bool

	// contracts/validatorRegistry.algo.ts:878
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_get
	assert
	frame_bury 3 // poolSet: (uint64,uint64,uint64)[6]

	// contracts/validatorRegistry.algo.ts:879
	// for (let i = 0; i < this.StakerPoolSet(staker).value.length; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_7:
	// contracts/validatorRegistry.algo.ts:879
	// i < this.StakerPoolSet(staker).value.length
	frame_dig 4 // i: uint64
	int 6
	<
	bz *for_7_end

	// *if29_condition
	// contracts/validatorRegistry.algo.ts:880
	// poolSet[i].ID === 0
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	int 0
	==
	bz *if29_end

	// *if29_consequent
	b *for_7_continue

*if29_end:
	// contracts/validatorRegistry.algo.ts:883
	// inAnyPoolCount += 1
	frame_dig 1 // inAnyPoolCount: uint64
	int 1
	+
	frame_bury 1 // inAnyPoolCount: uint64

	// *if30_condition
	// contracts/validatorRegistry.algo.ts:884
	// poolSet[i].ID === poolKey.ID
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	==
	bz *if30_end

	// *if30_consequent
	// *if31_condition
	// contracts/validatorRegistry.algo.ts:885
	// poolSet[i] === poolKey
	frame_dig 3 // poolSet: (uint64,uint64,uint64)[6]
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz *if31_else

	// *if31_consequent
	// contracts/validatorRegistry.algo.ts:886
	// found = true
	int 1
	frame_bury 2 // found: bool

	// contracts/validatorRegistry.algo.ts:888
	// this.StakerPoolSet(staker).value[i] = { ID: 0, PoolID: 0, PoolAppID: 0 }
	frame_dig 4 // i: uint64
	int 24
	* // acc * typeLength
	byte 0x000000000000000000000000000000000000000000000000
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace
	b *if31_end

*if31_else:
	// contracts/validatorRegistry.algo.ts:890
	// inSameValidatorPoolCount += 1
	frame_dig 0 // inSameValidatorPoolCount: uint64
	int 1
	+
	frame_bury 0 // inSameValidatorPoolCount: uint64

*if31_end:

*if30_end:

*for_7_continue:
	// contracts/validatorRegistry.algo.ts:879
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_7

*for_7_end:
	// *if32_condition
	// contracts/validatorRegistry.algo.ts:894
	// !found
	frame_dig 2 // found: bool
	!
	bz *if32_end

	// *if32_consequent
	err // 'No matching slot found when told to remove a pool from the stakers set'

*if32_end:
	// contracts/validatorRegistry.algo.ts:898
	// return [inSameValidatorPoolCount === 0, inAnyPoolCount === 0];
	byte 0x00
	int 0
	frame_dig 0 // inSameValidatorPoolCount: uint64
	int 0
	==
	setbit
	int 1
	frame_dig 1 // inAnyPoolCount: uint64
	int 0
	==
	setbit

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// addPoolToNode(validatorID: ValidatorID, poolAppID: uint64, nodeNum: uint64): void
addPoolToNode:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:902
	// nodePoolAssignments = clone(this.ValidatorList(validatorID).value.NodePoolAssignments)
	int 425 // headOffset
	int 96
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // nodePoolAssignments: ((uint64[3])[4])

	// contracts/validatorRegistry.algo.ts:903
	// maxPoolsPerNodeForThisValidator = this.ValidatorList(validatorID).value.Config.PoolsPerNode as uint64
	int 190
	int 1
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // maxPoolsPerNodeForThisValidator: uint64

	// contracts/validatorRegistry.algo.ts:905
	// assert(nodeNum >= 1 && nodeNum <= MAX_NODES)
	frame_dig -3 // nodeNum: uint64
	int 1
	>=
	dup
	bz *skip_and7
	frame_dig -3 // nodeNum: uint64
	int 4
	<=
	&&

*skip_and7:
	assert

	// contracts/validatorRegistry.algo.ts:907
	// for (let i = 0; i < maxPoolsPerNodeForThisValidator; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_8:
	// contracts/validatorRegistry.algo.ts:907
	// i < maxPoolsPerNodeForThisValidator
	frame_dig 2 // i: uint64
	frame_dig 1 // maxPoolsPerNodeForThisValidator: uint64
	<
	bz *for_8_end

	// *if33_condition
	// contracts/validatorRegistry.algo.ts:908
	// nodePoolAssignments.Nodes[nodeNum - 1].PoolAppIDs[i] === 0
	frame_dig 0 // nodePoolAssignments: ((uint64[3])[4])
	int 0
	frame_dig -3 // nodeNum: uint64
	int 1
	-
	int 24
	* // acc * typeLength
	+
	int 0
	+
	frame_dig 2 // i: uint64
	int 8
	* // acc * typeLength
	+
	int 8
	extract3
	btoi
	int 0
	==
	bz *if33_end

	// *if33_consequent
	// contracts/validatorRegistry.algo.ts:910
	// this.ValidatorList(validatorID).value.NodePoolAssignments.Nodes[nodeNum - 1].PoolAppIDs[i] = poolAppID
	int 425
	frame_dig -3 // nodeNum: uint64
	int 1
	-
	int 24
	* // acc * typeLength
	+
	int 0
	+
	frame_dig 2 // i: uint64
	int 8
	* // acc * typeLength
	+
	frame_dig -2 // poolAppID: uint64
	itob
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:911
	// return;
	retsub

*if33_end:

*for_8_continue:
	// contracts/validatorRegistry.algo.ts:907
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_8

*for_8_end:
	err // 'no available space in specified node for this pool'

*create_NoOp:
	method "createApplication(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication
	err

*call_NoOp:
	method "gas()void"
	method "getMbrAmounts()(uint64,uint64,uint64,uint64)"
	method "getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
	method "getNumValidators()uint64"
	method "getValidatorConfig(uint64)(uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8)"
	method "getValidatorState(uint64)(uint16,uint64,uint64)"
	method "getValidatorOwnerAndManager(uint64)(address,address)"
	method "getPools(uint64)(uint64,uint16,uint64)[]"
	method "getPoolAppID(uint64,uint64)uint64"
	method "getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)"
	method "doesStakerNeedToPayMBR(address)bool"
	method "getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]"
	method "getNodePoolAssignments(uint64)((uint64[3])[4])"
	method "getNFDRegistryID()uint64"
	method "addValidator(pay,string,(uint64,address,address,uint64,address,uint64,uint64,uint64,uint16,uint32,address,uint64,uint64,uint8))uint64"
	method "changeValidatorManager(uint64,address)void"
	method "changeValidatorNFD(uint64,uint64,string)void"
	method "changeValidatorCommissionAddress(uint64,address)void"
	method "changeValidatorRewardInfo(uint64,address,uint64,uint64,uint64)void"
	method "addPool(pay,uint64,uint64)(uint64,uint64,uint64)"
	method "addStake(pay,uint64,uint64)(uint64,uint64,uint64)"
	method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64)void"
	method "stakeRemoved((uint64,uint64,uint64),address,uint64,bool)void"
	method "findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)"
	method "movePoolToNode(uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_gas *abi_route_getMbrAmounts *abi_route_getProtocolConstraints *abi_route_getNumValidators *abi_route_getValidatorConfig *abi_route_getValidatorState *abi_route_getValidatorOwnerAndManager *abi_route_getPools *abi_route_getPoolAppID *abi_route_getPoolInfo *abi_route_doesStakerNeedToPayMBR *abi_route_getStakedPoolsForAccount *abi_route_getNodePoolAssignments *abi_route_getNFDRegistryID *abi_route_addValidator *abi_route_changeValidatorManager *abi_route_changeValidatorNFD *abi_route_changeValidatorCommissionAddress *abi_route_changeValidatorRewardInfo *abi_route_addPool *abi_route_addStake *abi_route_stakeUpdatedViaRewards *abi_route_stakeRemoved *abi_route_findPoolForStaker *abi_route_movePoolToNode
	err