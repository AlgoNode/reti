#pragma version 9

// This TEAL was generated by TEALScript v0.82.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// createApplication(uint64)void
abi_route_createApplication:
	// poolTemplateAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64)void
	callsub createApplication
	int 1
	return

// createApplication(poolTemplateAppID: uint64): void
createApplication:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:93
	// this.numValidators.value = 0
	byte 0x6e756d56 // "numV"
	int 0
	app_global_put

	// contracts/validatorRegistry.algo.ts:94
	// this.StakingPoolTemplateAppID.value = poolTemplateAppID
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	frame_dig -1 // poolTemplateAppID: uint64
	app_global_put
	retsub

// gas()void
abi_route_gas:
	// execute gas()void
	callsub gas
	int 1
	return

// gas(): void
//
// gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
gas:
	proto 0 0
	retsub

// minBalanceForAccount(contracts: number, extraPages: number, assets: number, localInts: number, localBytes: number, globalInts: number, globalBytes: number): uint64
minBalanceForAccount:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:111
	// minBal = ALGORAND_ACCOUNT_MIN_BALANCE
	int 100000
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:112
	// minBal += contracts * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -1 // contracts: number
	int 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:113
	// minBal += extraPages * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -2 // extraPages: number
	int 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:114
	// minBal += assets * ASSET_HOLDING_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -3 // assets: number
	int 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:115
	// minBal += localInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -4 // localInts: number
	int 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:116
	// minBal += globalInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -6 // globalInts: number
	int 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:117
	// minBal += localBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -5 // localBytes: number
	int 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:118
	// minBal += globalBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -7 // globalBytes: number
	int 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts/validatorRegistry.algo.ts:119
	// return minBal;
	frame_dig 0 // minBal: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// costForBoxStorage(totalNumBytes: number): uint64
costForBoxStorage:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:123
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE;
	int 2500
	frame_dig -1 // totalNumBytes: number
	int 400
	*
	+
	retsub

// getMbrAmounts()(uint64,uint64,uint64)
abi_route_getMbrAmounts:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getMbrAmounts()(uint64,uint64,uint64)
	callsub getMbrAmounts
	concat
	log
	int 1
	return

// getMbrAmounts(): MbrAmounts
getMbrAmounts:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:130
	// return {
	//             AddValidatorMbr:
	//                 this.costForBoxStorage(1 /* v prefix */ + 8 /* key id size */ + 1523 /* ValidatorInfo struct size */),
	//             AddPoolMbr: this.minBalanceForAccount(1, 0, 0, 0, 0, 7, 2),
	//             AddStakerMbr:
	//                 // how much to charge for first time a staker adds stake - since we add a tracking box per staker
	//                 this.costForBoxStorage(3 /* 'sps' prefix */ + 32 /* account */ + 24 /* ValidatorPoolKey size */ * 4), // size of key + all values
	//         };
	int 1532
	callsub costForBoxStorage
	itob
	int 2
	int 7
	int 0
	dupn 3
	int 1
	callsub minBalanceForAccount
	itob
	concat
	int 131
	callsub costForBoxStorage
	itob
	concat
	retsub

// getNumValidators()uint64
abi_route_getNumValidators:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNumValidators()uint64
	callsub getNumValidators
	itob
	concat
	log
	int 1
	return

// getNumValidators(): uint64
//
// Returns the current number of validators
getNumValidators:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:145
	// return this.numValidators.value;
	byte 0x6e756d56 // "numV"
	app_global_get
	retsub

// getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint64,uint64,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])
abi_route_getValidatorInfo:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint64,uint64,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])
	callsub getValidatorInfo
	concat
	log
	int 1
	return

// getValidatorInfo(validatorID: ValidatorID): ValidatorInfo
getValidatorInfo:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:150
	// return this.ValidatorList(validatorID).value;
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	box_get
	assert
	retsub

// getValidatorConfig(uint64)(uint16,uint32,address,uint64,uint64,uint8,uint16)
abi_route_getValidatorConfig:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorConfig(uint64)(uint16,uint32,address,uint64,uint64,uint8,uint16)
	callsub getValidatorConfig
	concat
	log
	int 1
	return

// getValidatorConfig(validatorID: ValidatorID): ValidatorConfig
getValidatorConfig:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:155
	// return this.ValidatorList(validatorID).value.Config;
	int 80 // headOffset
	int 57
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	retsub

// getValidatorState(uint64)(uint16,uint64,uint64)
abi_route_getValidatorState:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorState(uint64)(uint16,uint64,uint64)
	callsub getValidatorState
	concat
	log
	int 1
	return

// getValidatorState(validatorID: ValidatorID): ValidatorCurState
getValidatorState:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:160
	// return this.ValidatorList(validatorID).value.State;
	int 137 // headOffset
	int 18
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	retsub

// getPoolInfo((uint64,uint64,uint64))(uint16,uint64,uint16,uint64)
abi_route_getPoolInfo:
	// The ABI return prefix
	byte 0x151f7c75

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute getPoolInfo((uint64,uint64,uint64))(uint16,uint64,uint16,uint64)
	callsub getPoolInfo
	concat
	log
	int 1
	return

// getPoolInfo(poolKey: ValidatorPoolKey): PoolInfo
getPoolInfo:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:165
	// return this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1];
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 20
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	retsub

// addValidator(address,address,uint64,(uint16,uint32,address,uint64,uint64,uint8,uint16))uint64
abi_route_addValidator:
	// The ABI return prefix
	byte 0x151f7c75

	// config: (uint16,uint32,address,uint64,uint64,uint8,uint16)
	txna ApplicationArgs 4
	dup
	len
	int 57
	==
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 3
	btoi

	// manager: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute addValidator(address,address,uint64,(uint16,uint32,address,uint64,uint64,uint8,uint16))uint64
	callsub addValidator
	itob
	concat
	log
	int 1
	return

// addValidator(owner: Address, manager: Address, nfdAppID: uint64, config: ValidatorConfig): uint64
//
// Adds a new validator
// @param owner The account (presumably cold-wallet) that owns the validator set
// @param manager The account that manages the pool part. keys and triggers payouts.  Normally a hot-wallet as node sidecar needs the keys
// @param nfdAppID Optional NFD App ID linking to information about the validator being added - where information about the validator and their pools can be found.
// @param config ValidatorConfig struct
addValidator:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:175
	// assert(owner !== Address.zeroAddress)
	frame_dig -1 // owner: Address
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:176
	// assert(manager !== Address.zeroAddress)
	frame_dig -2 // manager: Address
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:178
	// this.validateConfig(config)
	frame_dig -4 // config: ValidatorConfig
	callsub validateConfig

	// contracts/validatorRegistry.algo.ts:181
	// validatorID = this.numValidators.value + 1
	byte 0x6e756d56 // "numV"
	app_global_get
	int 1
	+
	frame_bury 0 // validatorID: uint64

	// contracts/validatorRegistry.algo.ts:182
	// this.numValidators.value = validatorID
	byte 0x6e756d56 // "numV"
	frame_dig 0 // validatorID: uint64
	app_global_put

	// contracts/validatorRegistry.algo.ts:184
	// this.ValidatorList(validatorID).create()
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	int 1523
	box_create
	pop

	// contracts/validatorRegistry.algo.ts:185
	// this.ValidatorList(validatorID).value.ID = validatorID
	int 0
	frame_dig 0 // validatorID: uint64
	itob
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:186
	// this.ValidatorList(validatorID).value.Owner = owner
	int 8 // headOffset
	frame_dig -1 // owner: Address
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:187
	// this.ValidatorList(validatorID).value.Manager = manager
	int 40 // headOffset
	frame_dig -2 // manager: Address
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:188
	// this.ValidatorList(validatorID).value.NFDForInfo = nfdAppID
	int 72 // headOffset
	frame_dig -3 // nfdAppID: uint64
	itob
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:189
	// this.ValidatorList(validatorID).value.Config = config
	int 80 // headOffset
	frame_dig -4 // config: ValidatorConfig
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:191
	// this.ValidatorList(validatorID).value.Nodes[0].Name = 'foo'
	int 157
	byte 0x666f6f // "foo"
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:192
	// return validatorID;
	frame_dig 0 // validatorID: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// addPool(pay,uint64)(uint64,uint64,uint64)
abi_route_addPool:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// mbrPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute addPool(pay,uint64)(uint64,uint64,uint64)
	callsub addPool
	concat
	log
	int 1
	return

// addPool(mbrPayment: PayTxn, validatorID: ValidatorID): ValidatorPoolKey
//
// Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
// The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
// @param {PayTxn} mbrPayment payment from caller which covers mbr increase of valiator pool + staking pool
// @param {uint64} validatorID is ID of validator to pool to (must be owner or manager)
// @returns {ValidatorPoolKey} pool key to created pool
addPool:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:203
	// verifyPayTxn(mbrPayment, { amount: this.getMbrAmounts().AddPoolMbr })
	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	callsub getMbrAmounts
	extract 8 8
	btoi
	==
	assert

	// contracts/validatorRegistry.algo.ts:205
	// assert(this.ValidatorList(validatorID).exists)
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:208
	// assert(
	//             this.txn.sender === this.ValidatorList(validatorID).value.Owner ||
	//                 this.txn.sender === this.ValidatorList(validatorID).value.Manager
	//         )
	txn Sender
	int 8 // headOffset
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	dup
	bnz skip_or0
	txn Sender
	int 40 // headOffset
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	==
	||

skip_or0:
	assert

	// contracts/validatorRegistry.algo.ts:213
	// numPools = this.ValidatorList(validatorID).value.State.NumPools
	int 137
	int 2
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // numPools: uint16

	// if0_condition
	// contracts/validatorRegistry.algo.ts:214
	// (numPools as uint64) >= MAX_POOLS
	frame_dig 0 // numPools: uint16
	int 48
	>=
	bz if0_end

	// if0_consequent
	err // 'already at max pool size'

if0_end:
	// contracts/validatorRegistry.algo.ts:217
	// numPools += 1
	frame_dig 0 // numPools: uint16
	int 1
	+
	frame_bury 0 // numPools: uint16

	// contracts/validatorRegistry.algo.ts:220
	// sendAppCall({
	//             onCompletion: OnCompletion.NoOp,
	//             approvalProgram: Application.fromID(this.StakingPoolTemplateAppID.value).approvalProgram,
	//             clearStateProgram: Application.fromID(this.StakingPoolTemplateAppID.value).clearStateProgram,
	//             globalNumUint: Application.fromID(this.StakingPoolTemplateAppID.value).globalNumUint,
	//             globalNumByteSlice: Application.fromID(this.StakingPoolTemplateAppID.value).globalNumByteSlice,
	//             extraProgramPages: Application.fromID(this.StakingPoolTemplateAppID.value).extraProgramPages,
	//             applicationArgs: [
	//                 // creatingContractID, validatorID, poolID, owner, manager, minAllowedStake, maxStakeAllowed
	//                 method('createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void'),
	//                 itob(this.app.id),
	//                 itob(validatorID),
	//                 itob(numPools as uint64),
	//                 rawBytes(this.ValidatorList(validatorID).value.Owner),
	//                 rawBytes(this.ValidatorList(validatorID).value.Manager),
	//                 itob(this.ValidatorList(validatorID).value.Config.MinAllowedStake),
	//                 itob(this.ValidatorList(validatorID).value.Config.MaxAlgoPerPool),
	//             ],
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:221
	// onCompletion: OnCompletion.NoOp
	int 0 // NoOp
	itxn_field OnCompletion

	// contracts/validatorRegistry.algo.ts:222
	// approvalProgram: Application.fromID(this.StakingPoolTemplateAppID.value).approvalProgram
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppApprovalProgram
	pop
	itxn_field ApprovalProgram

	// contracts/validatorRegistry.algo.ts:223
	// clearStateProgram: Application.fromID(this.StakingPoolTemplateAppID.value).clearStateProgram
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppClearStateProgram
	pop
	itxn_field ClearStateProgram

	// contracts/validatorRegistry.algo.ts:224
	// globalNumUint: Application.fromID(this.StakingPoolTemplateAppID.value).globalNumUint
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppGlobalNumUint
	pop
	itxn_field GlobalNumUint

	// contracts/validatorRegistry.algo.ts:225
	// globalNumByteSlice: Application.fromID(this.StakingPoolTemplateAppID.value).globalNumByteSlice
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppGlobalNumByteSlice
	pop
	itxn_field GlobalNumByteSlice

	// contracts/validatorRegistry.algo.ts:226
	// extraProgramPages: Application.fromID(this.StakingPoolTemplateAppID.value).extraProgramPages
	byte 0x706f6f6c54656d706c6174654170704944 // "poolTemplateAppID"
	app_global_get
	app_params_get AppExtraProgramPages
	pop
	itxn_field ExtraProgramPages

	// contracts/validatorRegistry.algo.ts:227
	// applicationArgs: [
	//                 // creatingContractID, validatorID, poolID, owner, manager, minAllowedStake, maxStakeAllowed
	//                 method('createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void'),
	//                 itob(this.app.id),
	//                 itob(validatorID),
	//                 itob(numPools as uint64),
	//                 rawBytes(this.ValidatorList(validatorID).value.Owner),
	//                 rawBytes(this.ValidatorList(validatorID).value.Manager),
	//                 itob(this.ValidatorList(validatorID).value.Config.MinAllowedStake),
	//                 itob(this.ValidatorList(validatorID).value.Config.MaxAlgoPerPool),
	//             ]
	method "createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void"
	itxn_field ApplicationArgs
	txna Applications 0
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // validatorID: ValidatorID
	itob
	itxn_field ApplicationArgs
	frame_dig 0 // numPools: uint16
	itob
	itxn_field ApplicationArgs
	int 8 // headOffset
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	itxn_field ApplicationArgs
	int 40 // headOffset
	int 32
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	itxn_field ApplicationArgs
	int 118
	int 8
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs
	int 126
	int 8
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/validatorRegistry.algo.ts:240
	// this.ValidatorList(validatorID).value.State.NumPools = numPools
	int 137
	frame_dig 0 // numPools: uint16
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:243
	// this.ValidatorList(validatorID).value.Pools[numPools - 1].PoolAppID = this.itxn.createdApplicationID.id
	int 563 // headOffset
	frame_dig 0 // numPools: uint16
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 2 // headOffset
	+
	itxn CreatedApplicationID
	itob
	byte 0x76 // "v"
	frame_dig -2 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:246
	// return { ID: validatorID, PoolID: numPools as uint64, PoolAppID: this.itxn!.createdApplicationID.id };
	frame_dig -2 // validatorID: ValidatorID
	itob
	frame_dig 0 // numPools: uint16
	itob
	concat
	itxn CreatedApplicationID
	itob
	concat

	// set the subroutine return value
	frame_bury 0
	retsub

// getPoolAppID((uint64,uint64,uint64))uint64
abi_route_getPoolAppID:
	// The ABI return prefix
	byte 0x151f7c75

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute getPoolAppID((uint64,uint64,uint64))uint64
	callsub getPoolAppID
	itob
	concat
	log
	int 1
	return

// getPoolAppID(poolKey: ValidatorPoolKey): uint64
getPoolAppID:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:250
	// return this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].PoolAppID;
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 2 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	retsub

// addStake(pay,uint64)(uint64,uint64,uint64)
abi_route_addStake:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// stakedAmountPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute addStake(pay,uint64)(uint64,uint64,uint64)
	callsub addStake
	concat
	log
	int 1
	return

// addStake(stakedAmountPayment: PayTxn, validatorID: ValidatorID): ValidatorPoolKey
//
// Adds stake to a validator pool.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorID} validatorID - The ID of the validator.
// @returns {ValidatorPoolKey} - The key of the validator pool.
addStake:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/validatorRegistry.algo.ts:261
	// staker = this.txn.sender
	txn Sender
	frame_bury 0 // staker: address

	// contracts/validatorRegistry.algo.ts:264
	// verifyPayTxn(stakedAmountPayment, {
	//             sender: staker,
	//             receiver: this.app.address,
	//         })
	// verify sender
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	frame_dig 0 // staker: address
	==
	assert

	// verify receiver
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/validatorRegistry.algo.ts:271
	// poolKey = this.findPoolForStaker(validatorID, staker, stakedAmountPayment.amount)
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig 0 // staker: address
	frame_dig -2 // validatorID: ValidatorID
	callsub findPoolForStaker
	frame_bury 1 // poolKey: (uint64,uint64,uint64)

	// if1_condition
	// contracts/validatorRegistry.algo.ts:272
	// poolKey.PoolID === 0
	frame_dig 1 // poolKey: (uint64,uint64,uint64)
	extract 8 8
	btoi
	int 0
	==
	bz if1_end

	// if1_consequent
	err // 'No pool available with free stake.  Validator needs to add another pool'

if1_end:
	// contracts/validatorRegistry.algo.ts:275
	// mbrAmtLeftBehind: uint64 = 0
	int 0
	frame_bury 2 // mbrAmtLeftBehind: uint64

	// if2_condition
	// contracts/validatorRegistry.algo.ts:277
	// !this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig 0 // staker: address
	concat
	box_len
	swap
	pop
	!
	bz if2_end

	// if2_consequent
	// contracts/validatorRegistry.algo.ts:280
	// mbrAmtLeftBehind = this.getMbrAmounts().AddStakerMbr
	callsub getMbrAmounts
	extract 16 8
	btoi
	frame_bury 2 // mbrAmtLeftBehind: uint64

	// contracts/validatorRegistry.algo.ts:281
	// this.StakerPoolSet(staker).create()
	byte 0x737073 // "sps"
	frame_dig 0 // staker: address
	concat
	int 96
	box_create
	pop

if2_end:
	// contracts/validatorRegistry.algo.ts:285
	// this.updateStakerPoolSet(staker, poolKey)
	frame_dig 1 // poolKey: (uint64,uint64,uint64)
	frame_dig 0 // staker: address
	callsub updateStakerPoolSet

	// contracts/validatorRegistry.algo.ts:286
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts/validatorRegistry.algo.ts:289
	// this.callPoolAddStake(stakedAmountPayment, poolKey, mbrAmtLeftBehind)
	frame_dig 2 // mbrAmtLeftBehind: uint64
	frame_dig 1 // poolKey: (uint64,uint64,uint64)
	frame_dig -1 // stakedAmountPayment: PayTxn
	callsub callPoolAddStake

	// contracts/validatorRegistry.algo.ts:290
	// return poolKey;
	frame_dig 1 // poolKey: (uint64,uint64,uint64)

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// stakeUpdatedViaRewards((uint64,uint64,uint64),uint64)void
abi_route_stakeUpdatedViaRewards:
	// amountToAdd: uint64
	txna ApplicationArgs 2
	btoi

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute stakeUpdatedViaRewards((uint64,uint64,uint64),uint64)void
	callsub stakeUpdatedViaRewards
	int 1
	return

// stakeUpdatedViaRewards(poolKey: ValidatorPoolKey, amountToAdd: uint64): void
//
// stakeUpdatedViaRewards is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removed
// from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App ID is validated against our pool list as well.
// @param poolKey - ValidatorPoolKey type - [validatorID, PoolID] compound type
// @param amountToAdd
stakeUpdatedViaRewards:
	proto 2 0

	// contracts/validatorRegistry.algo.ts:301
	// assert(this.ValidatorList(poolKey.ID).exists)
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:302
	// assert((poolKey.PoolID as uint64) < 2 ** 16)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 2
	int 16
	exp
	<
	assert

	// contracts/validatorRegistry.algo.ts:303
	// assert(poolKey.PoolID > 0 && (poolKey.PoolID as uint16) <= this.ValidatorList(poolKey.ID).value.State.NumPools)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 0
	>
	dup
	bz skip_and0
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 137
	int 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	<=
	&&

skip_and0:
	assert

	// contracts/validatorRegistry.algo.ts:306
	// assert(
	//             poolKey.PoolAppID === this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].PoolAppID,
	//             "The passed in app id doesn't match the passed in ids"
	//         )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 2 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	==

	// The passed in app id doesn't match the passed in ids
	assert

	// contracts/validatorRegistry.algo.ts:311
	// assert(this.txn.sender === Application.fromID(poolKey.PoolAppID).address)
	txn Sender
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// contracts/validatorRegistry.algo.ts:313
	// assert(poolKey.ID === (Application.fromID(poolKey.PoolAppID).globalState('validatorID') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	byte 0x76616c696461746f724944 // "validatorID"
	app_global_get_ex
	assert
	==
	assert

	// contracts/validatorRegistry.algo.ts:314
	// assert(poolKey.PoolID === (Application.fromID(poolKey.PoolAppID).globalState('poolID') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	byte 0x706f6f6c4944 // "poolID"
	app_global_get_ex
	assert
	==
	assert

	// contracts/validatorRegistry.algo.ts:317
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalAlgoStaked += amountToAdd
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToAdd: uint64
	+
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:318
	// this.ValidatorList(poolKey.ID).value.State.TotalAlgoStaked += amountToAdd
	int 147
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToAdd: uint64
	+
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace
	retsub

// stakeRemoved((uint64,uint64,uint64),address,uint64,bool)void
abi_route_stakeRemoved:
	// stakerRemoved: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// amountRemoved: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// poolKey: (uint64,uint64,uint64)
	txna ApplicationArgs 1
	dup
	len
	int 24
	==
	assert

	// execute stakeRemoved((uint64,uint64,uint64),address,uint64,bool)void
	callsub stakeRemoved
	int 1
	return

// stakeRemoved(poolKey: ValidatorPoolKey, staker: Address, amountRemoved: uint64, stakerRemoved: boolean): void
//
// stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removed
// from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App ID is validated against our pool list as well.
// @param poolKey - ValidatorPoolKey type - [validatorID, PoolID] compound type
// @param staker
// @param amountRemoved
// @param stakerRemoved
stakeRemoved:
	proto 4 0

	// contracts/validatorRegistry.algo.ts:331
	// assert(this.ValidatorList(poolKey.ID).exists)
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:332
	// assert((poolKey.PoolID as uint64) < 2 ** 16)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 2
	int 16
	exp
	<
	assert

	// contracts/validatorRegistry.algo.ts:333
	// assert(poolKey.PoolID > 0 && (poolKey.PoolID as uint16) <= this.ValidatorList(poolKey.ID).value.State.NumPools)
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 0
	>
	dup
	bz skip_and1
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 137
	int 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	<=
	&&

skip_and1:
	assert

	// contracts/validatorRegistry.algo.ts:336
	// assert(
	//             poolKey.PoolAppID === this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].PoolAppID,
	//             "The passed in app id doesn't match the passed in ids"
	//         )
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 2 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	==

	// The passed in app id doesn't match the passed in ids
	assert

	// contracts/validatorRegistry.algo.ts:341
	// assert(this.txn.sender === Application.fromID(poolKey.PoolAppID).address)
	txn Sender
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// contracts/validatorRegistry.algo.ts:343
	// assert(poolKey.ID === (Application.fromID(poolKey.PoolAppID).globalState('validatorID') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	byte 0x76616c696461746f724944 // "validatorID"
	app_global_get_ex
	assert
	==
	assert

	// contracts/validatorRegistry.algo.ts:344
	// assert(poolKey.PoolID === (Application.fromID(poolKey.PoolAppID).globalState('poolID') as uint64))
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	byte 0x706f6f6c4944 // "poolID"
	app_global_get_ex
	assert
	==
	assert

	// contracts/validatorRegistry.algo.ts:347
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalAlgoStaked -= amountRemoved
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:348
	// this.ValidatorList(poolKey.ID).value.State.TotalAlgoStaked -= amountRemoved
	int 147
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountRemoved: uint64
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// if3_condition
	// contracts/validatorRegistry.algo.ts:349
	// stakerRemoved
	frame_dig -4 // stakerRemoved: boolean
	bz if3_end

	// if3_consequent
	// contracts/validatorRegistry.algo.ts:350
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalStakers -= 1
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 563 // headOffset
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	int 1
	-
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:351
	// this.ValidatorList(poolKey.ID).value.State.TotalStakers -= 1
	int 139
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	int 1
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:352
	// this.removeFromStakerPoolSet(staker, <ValidatorPoolKey>{
	//                 ID: poolKey.ID,
	//                 PoolID: poolKey.PoolID,
	//                 PoolAppID: poolKey.PoolAppID,
	//             })
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	itob
	concat
	frame_dig -1 // poolKey: ValidatorPoolKey
	extract 16 8
	btoi
	itob
	concat
	frame_dig -2 // staker: Address
	callsub removeFromStakerPoolSet

if3_end:
	retsub

// findPoolForStaker(uint64,address,uint64)(uint64,uint64,uint64)
abi_route_findPoolForStaker:
	// The ABI return prefix
	byte 0x151f7c75

	// amountToStake: uint64
	txna ApplicationArgs 3
	btoi

	// staker: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute findPoolForStaker(uint64,address,uint64)(uint64,uint64,uint64)
	callsub findPoolForStaker
	concat
	log
	int 1
	return

// findPoolForStaker(validatorID: ValidatorID, staker: Address, amountToStake: uint64): ValidatorPoolKey
findPoolForStaker:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/validatorRegistry.algo.ts:362
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

	// contracts/validatorRegistry.algo.ts:367
	// maxPerPool = this.ValidatorList(validatorID).value.Config.MaxAlgoPerPool
	int 126
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // maxPerPool: uint64

	// if4_condition
	// contracts/validatorRegistry.algo.ts:370
	// this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig -2 // staker: Address
	concat
	box_len
	swap
	pop
	bz if4_end

	// if4_consequent
	// contracts/validatorRegistry.algo.ts:371
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -2 // staker: Address
	concat
	box_get
	assert
	frame_bury 1 // poolSet: (uint64,uint64,uint64)[4]

	// contracts/validatorRegistry.algo.ts:372
	// for (let i = 0; i < poolSet.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

for_0:
	// contracts/validatorRegistry.algo.ts:372
	// i < poolSet.length
	frame_dig 2 // i: uint64
	int 4
	<
	bz for_0_end

	// if5_condition
	// contracts/validatorRegistry.algo.ts:373
	// poolSet[i].ID === validatorID
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[4]
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	frame_dig -1 // validatorID: ValidatorID
	==
	bz if5_end

	// if5_consequent
	// if6_condition
	// contracts/validatorRegistry.algo.ts:376
	// this.ValidatorList(validatorID).value.Pools[poolSet[i].PoolID - 1].TotalAlgoStaked +
	//                             amountToStake <
	//                         maxPerPool
	int 563 // headOffset
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[4]
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	int 8 // headOffset
	+
	int 8
	extract3
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 0 // maxPerPool: uint64
	<
	bz if6_end

	// if6_consequent
	// contracts/validatorRegistry.algo.ts:380
	// return poolSet[i];
	frame_dig 1 // poolSet: (uint64,uint64,uint64)[4]
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

if6_end:

if5_end:
	// contracts/validatorRegistry.algo.ts:372
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b for_0

for_0_end:

if4_end:
	// contracts/validatorRegistry.algo.ts:387
	// assert(
	//             amountToStake >= this.ValidatorList(validatorID).value.Config.MinAllowedStake,
	//             'must stake at least the minimum for this pool'
	//         )
	frame_dig -3 // amountToStake: uint64
	int 118
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	>=

	// must stake at least the minimum for this pool
	assert

	// contracts/validatorRegistry.algo.ts:392
	// pools = clone(this.ValidatorList(validatorID).value.Pools)
	int 563 // headOffset
	int 960
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 3 // pools: (uint16,uint64,uint16,uint64)[48]

	// contracts/validatorRegistry.algo.ts:393
	// for (let i = 0; i < pools.length; i += 1)
	int 0
	frame_bury 4 // i: uint64

for_1:
	// contracts/validatorRegistry.algo.ts:393
	// i < pools.length
	frame_dig 4 // i: uint64
	int 48
	<
	bz for_1_end

	// if7_condition
	// contracts/validatorRegistry.algo.ts:394
	// pools[i].TotalAlgoStaked + amountToStake < maxPerPool
	frame_dig 3 // pools: (uint16,uint64,uint16,uint64)[48]
	frame_dig 4 // i: uint64
	int 20
	* // acc * typeLength
	int 12 // headOffset
	+
	int 8
	extract3
	btoi
	frame_dig -3 // amountToStake: uint64
	+
	frame_dig 0 // maxPerPool: uint64
	<
	bz if7_end

	// if7_consequent
	// contracts/validatorRegistry.algo.ts:395
	// return { ID: validatorID, PoolID: i + 1, PoolAppID: pools[i].PoolAppID };
	frame_dig -1 // validatorID: ValidatorID
	itob
	frame_dig 4 // i: uint64
	int 1
	+
	itob
	concat
	frame_dig 3 // pools: (uint16,uint64,uint16,uint64)[48]
	frame_dig 4 // i: uint64
	int 20
	* // acc * typeLength
	int 2 // headOffset
	+
	int 8
	extract3
	btoi
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

if7_end:
	// contracts/validatorRegistry.algo.ts:393
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b for_1

for_1_end:
	// contracts/validatorRegistry.algo.ts:399
	// return { ID: validatorID, PoolID: 0, PoolAppID: 0 };
	frame_dig -1 // validatorID: ValidatorID
	itob
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// validateConfig(config: ValidatorConfig): void
validateConfig:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:404
	// assert(config.PayoutEveryXDays >= MIN_PAYOUT_DAYS && config.PayoutEveryXDays <= MAX_PAYOUT_DAYS)
	frame_dig -1 // config: ValidatorConfig
	extract 0 2
	btoi
	int 1
	>=
	dup
	bz skip_and2
	frame_dig -1 // config: ValidatorConfig
	extract 0 2
	btoi
	int 30
	<=
	&&

skip_and2:
	assert

	// contracts/validatorRegistry.algo.ts:405
	// assert(config.PercentToValidator >= MIN_PCT_TO_VALIDATOR && config.PercentToValidator <= MAX_PCT_TO_VALIDATOR)
	frame_dig -1 // config: ValidatorConfig
	extract 2 4
	btoi
	int 10000
	>=
	dup
	bz skip_and3
	frame_dig -1 // config: ValidatorConfig
	extract 2 4
	btoi
	int 100000
	<=
	&&

skip_and3:
	assert

	// contracts/validatorRegistry.algo.ts:406
	// assert(config.ValidatorCommissionAddress !== Address.zeroAddress)
	frame_dig -1 // config: ValidatorConfig
	extract 6 32
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:407
	// assert(config.MinAllowedStake >= MIN_ALGO_STAKE_PER_POOL)
	frame_dig -1 // config: ValidatorConfig
	extract 38 8
	btoi
	int 1000000
	>=
	assert

	// contracts/validatorRegistry.algo.ts:408
	// assert(config.MaxAlgoPerPool <= MAX_ALGO_PER_POOL, 'enforce hard constraint to be safe to the network')
	frame_dig -1 // config: ValidatorConfig
	extract 46 8
	btoi
	int 20000000000000
	<=

	// enforce hard constraint to be safe to the network
	assert

	// contracts/validatorRegistry.algo.ts:409
	// assert(config.PoolsPerNode > 0 && config.PoolsPerNode <= MAX_POOLS_PER_NODE)
	frame_dig -1 // config: ValidatorConfig
	extract 54 1
	btoi
	int 0
	>
	dup
	bz skip_and4
	frame_dig -1 // config: ValidatorConfig
	extract 54 1
	btoi
	int 4
	<=
	&&

skip_and4:
	assert

	// contracts/validatorRegistry.algo.ts:410
	// assert(config.MaxNodes > 0 && config.MaxNodes <= MAX_NODES)
	frame_dig -1 // config: ValidatorConfig
	extract 55 2
	btoi
	int 0
	>
	dup
	bz skip_and5
	frame_dig -1 // config: ValidatorConfig
	extract 55 2
	btoi
	int 12
	<=
	&&

skip_and5:
	assert
	retsub

// callPoolAddStake(stakedAmountPayment: PayTxn, poolKey: ValidatorPoolKey, mbrAmtPaid: uint64): void
//
// Adds a stakers amount of algo to a validator pool, transferring the algo we received from them (already verified
// by our caller) to the staking pool account, and then telling it about the amount being added for the specified
// staker.
//
// @param {PayTxn} stakedAmountPayment - payment coming from staker to place into a pool
// @param {ValidatorPoolKey} poolKey - The key of the validator pool.
// @param {uint64} mbrAmtPaid - Amount the user is leaving behind in the validator to pay for their Staker MBR cost
// @returns {void}
callPoolAddStake:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/validatorRegistry.algo.ts:424
	// poolAppID = this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].PoolAppID
	int 563 // headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 2 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // poolAppID: uint64

	// contracts/validatorRegistry.algo.ts:425
	// priorStakers = Application.fromID(poolAppID).globalState('numStakers') as uint64
	frame_dig 0 // poolAppID: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get_ex
	assert
	frame_bury 1 // priorStakers: uint64

	// contracts/validatorRegistry.algo.ts:429
	// sendMethodCall<[InnerPayment, Address], uint64>({
	//             name: 'addStake',
	//             applicationID: Application.fromID(poolAppID),
	//             methodArgs: [
	//                 // =======
	//                 // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//                 { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: Application.fromID(poolAppID).address },
	//                 // =======
	//                 stakedAmountPayment.sender,
	//             ],
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/validatorRegistry.algo.ts:435
	// amount: stakedAmountPayment.amount - mbrAmtPaid
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	itxn_field Amount

	// contracts/validatorRegistry.algo.ts:435
	// receiver: Application.fromID(poolAppID).address
	frame_dig 0 // poolAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee
	itxn_next
	int appl
	itxn_field TypeEnum
	method "addStake(pay,address)uint64"
	itxn_field ApplicationArgs

	// contracts/validatorRegistry.algo.ts:431
	// applicationID: Application.fromID(poolAppID)
	frame_dig 0 // poolAppID: uint64
	itxn_field ApplicationID

	// contracts/validatorRegistry.algo.ts:432
	// methodArgs: [
	//                 // =======
	//                 // THIS IS A SEND of the amount received right back out and into the staking pool contract account.
	//                 { amount: stakedAmountPayment.amount - mbrAmtPaid, receiver: Application.fromID(poolAppID).address },
	//                 // =======
	//                 stakedAmountPayment.sender,
	//             ]
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Sender
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	btoi

	// contracts/validatorRegistry.algo.ts:441
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalStakers = Application.fromID(
	//             poolAppID
	//         ).globalState('numStakers') as uint64 as uint16
	int 563 // headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	frame_dig 0 // poolAppID: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get_ex
	assert
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:445
	// this.ValidatorList(poolKey.ID).value.Pools[poolKey.PoolID - 1].TotalAlgoStaked = Application.fromID(
	//             poolAppID
	//         ).globalState('staked') as uint64
	int 563 // headOffset
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 8 8
	btoi
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	frame_dig 0 // poolAppID: uint64
	byte 0x7374616b6564 // "staked"
	app_global_get_ex
	assert
	itob
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:450
	// this.ValidatorList(poolKey.ID).value.State.TotalStakers +=
	//             (Application.fromID(poolAppID).globalState('numStakers') as uint64) - priorStakers
	int 139
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig 0 // poolAppID: uint64
	byte 0x6e756d5374616b657273 // "numStakers"
	app_global_get_ex
	assert
	frame_dig 1 // priorStakers: uint64
	-
	+
	itob
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:453
	// this.ValidatorList(poolKey.ID).value.State.TotalAlgoStaked += stakedAmountPayment.amount - mbrAmtPaid
	int 147
	dup
	int 8
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -1 // stakedAmountPayment: PayTxn
	gtxns Amount
	frame_dig -3 // mbrAmtPaid: uint64
	-
	+
	itob
	byte 0x76 // "v"
	frame_dig -2 // poolKey: ValidatorPoolKey
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace
	retsub

// updateStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): void
updateStakerPoolSet:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// if8_condition
	// contracts/validatorRegistry.algo.ts:457
	// !this.StakerPoolSet(staker).exists
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_len
	swap
	pop
	!
	bz if8_end

	// if8_consequent
	// contracts/validatorRegistry.algo.ts:458
	// this.StakerPoolSet(staker).create()
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	int 96
	box_create
	pop

if8_end:
	// contracts/validatorRegistry.algo.ts:460
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_get
	assert
	frame_bury 0 // poolSet: (uint64,uint64,uint64)[4]

	// contracts/validatorRegistry.algo.ts:461
	// for (let i = 0; i < this.StakerPoolSet(staker).value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

for_2:
	// contracts/validatorRegistry.algo.ts:461
	// i < this.StakerPoolSet(staker).value.length
	frame_dig 1 // i: uint64
	int 4
	<
	bz for_2_end

	// if9_condition
	// contracts/validatorRegistry.algo.ts:462
	// poolSet[i] === poolKey
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[4]
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz if9_end

	// if9_consequent
	// contracts/validatorRegistry.algo.ts:464
	// return;
	retsub

if9_end:
	// if10_condition
	// contracts/validatorRegistry.algo.ts:466
	// poolSet[i].ID === 0
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[4]
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	int 0
	+
	int 8
	extract3
	btoi
	int 0
	==
	bz if10_end

	// if10_consequent
	// contracts/validatorRegistry.algo.ts:467
	// this.StakerPoolSet(staker).value[i] = poolKey
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	frame_dig -2 // poolKey: ValidatorPoolKey
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:468
	// return;
	retsub

if10_end:
	// contracts/validatorRegistry.algo.ts:461
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b for_2

for_2_end:
	err // 'No empty slot available in the staker pool set'

// removeFromStakerPoolSet(staker: Address, poolKey: ValidatorPoolKey): void
removeFromStakerPoolSet:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/validatorRegistry.algo.ts:475
	// poolSet = clone(this.StakerPoolSet(staker).value)
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	box_get
	assert
	frame_bury 0 // poolSet: (uint64,uint64,uint64)[4]

	// contracts/validatorRegistry.algo.ts:476
	// for (let i = 0; i < this.StakerPoolSet(staker).value.length; i += 1)
	int 0
	frame_bury 1 // i: uint64

for_3:
	// contracts/validatorRegistry.algo.ts:476
	// i < this.StakerPoolSet(staker).value.length
	frame_dig 1 // i: uint64
	int 4
	<
	bz for_3_end

	// if11_condition
	// contracts/validatorRegistry.algo.ts:477
	// poolSet[i] === poolKey
	frame_dig 0 // poolSet: (uint64,uint64,uint64)[4]
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	int 24
	extract3
	frame_dig -2 // poolKey: ValidatorPoolKey
	==
	bz if11_end

	// if11_consequent
	// contracts/validatorRegistry.algo.ts:478
	// this.StakerPoolSet(staker).value[i] = { ID: 0, PoolID: 0, PoolAppID: 0 }
	frame_dig 1 // i: uint64
	int 24
	* // acc * typeLength
	byte 0x000000000000000000000000000000000000000000000000
	byte 0x737073 // "sps"
	frame_dig -1 // staker: Address
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:479
	// return;
	retsub

if11_end:
	// contracts/validatorRegistry.algo.ts:476
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b for_3

for_3_end:
	retsub

create_NoOp:
	method "createApplication(uint64)void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "gas()void"
	method "getMbrAmounts()(uint64,uint64,uint64)"
	method "getNumValidators()uint64"
	method "getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint64,uint64,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])"
	method "getValidatorConfig(uint64)(uint16,uint32,address,uint64,uint64,uint8,uint16)"
	method "getValidatorState(uint64)(uint16,uint64,uint64)"
	method "getPoolInfo((uint64,uint64,uint64))(uint16,uint64,uint16,uint64)"
	method "addValidator(address,address,uint64,(uint16,uint32,address,uint64,uint64,uint8,uint16))uint64"
	method "addPool(pay,uint64)(uint64,uint64,uint64)"
	method "getPoolAppID((uint64,uint64,uint64))uint64"
	method "addStake(pay,uint64)(uint64,uint64,uint64)"
	method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64)void"
	method "stakeRemoved((uint64,uint64,uint64),address,uint64,bool)void"
	method "findPoolForStaker(uint64,address,uint64)(uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match abi_route_gas abi_route_getMbrAmounts abi_route_getNumValidators abi_route_getValidatorInfo abi_route_getValidatorConfig abi_route_getValidatorState abi_route_getPoolInfo abi_route_addValidator abi_route_addPool abi_route_getPoolAppID abi_route_addStake abi_route_stakeUpdatedViaRewards abi_route_stakeRemoved abi_route_findPoolForStaker
	err