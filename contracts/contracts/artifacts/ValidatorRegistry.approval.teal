#pragma version 9

// This TEAL was generated by TEALScript v0.77.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// createApplication()void
abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts/validatorRegistry.algo.ts:78
	// this.numValidators.value = 0
	byte 0x6e756d56 // "numV"
	int 0
	app_global_put
	retsub

// getNumValidators()uint64
abi_route_getNumValidators:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNumValidators()uint64
	callsub getNumValidators
	itob
	concat
	log
	int 1
	return

// getNumValidators(): uint64
//
// Returns the current number of validators
getNumValidators:
	proto 0 1

	// contracts/validatorRegistry.algo.ts:86
	// return this.numValidators.value;
	byte 0x6e756d56 // "numV"
	app_global_get
	retsub

// getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[3],(uint16,uint64,uint16,uint64)[12])
abi_route_getValidatorInfo:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[3],(uint16,uint64,uint16,uint64)[12])
	callsub getValidatorInfo
	concat
	log
	int 1
	return

// getValidatorInfo(validatorID: ValidatorID): ValidatorInfo
getValidatorInfo:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:91
	// return this.ValidatorList(validatorID).value;
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	box_get
	assert
	retsub

// getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)
abi_route_getValidatorConfig:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)
	callsub getValidatorConfig
	concat
	log
	int 1
	return

// getValidatorConfig(validatorID: ValidatorID): ValidatorConfig
getValidatorConfig:
	proto 1 1

	// contracts/validatorRegistry.algo.ts:96
	// return this.ValidatorList(validatorID).value.Config;
	int 80 // headOffset
	int 41
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	retsub

// addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64
abi_route_addValidator:
	// The ABI return prefix
	byte 0x151f7c75

	// config: (uint16,uint32,address,uint8,uint16)
	txna ApplicationArgs 4
	dup
	len
	int 41
	==
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 3
	btoi

	// manager: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64
	callsub addValidator
	itob
	concat
	log
	int 1
	return

// addValidator(owner: Address, manager: Address, nfdAppID: uint64, config: ValidatorConfig): uint64
//
// Adds a new validator
// @param owner The account (presumably cold-wallet) that owns the validator set
// @param manager The account that manages the pool part. keys and triggers payouts.  Normally a hot-wallet as node sidecar needs the keys
// @param nfdAppID Optional NFD App ID linking to information about the validator being added - where information about the validator and their pools can be found.
// @param config ValidatorConfig struct
addValidator:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/validatorRegistry.algo.ts:106
	// assert(owner !== Address.zeroAddress)
	frame_dig -1 // owner: Address
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:107
	// assert(manager !== Address.zeroAddress)
	frame_dig -2 // manager: Address
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:109
	// this.validateConfig(config)
	frame_dig -4 // config: ValidatorConfig
	callsub validateConfig

	// contracts/validatorRegistry.algo.ts:112
	// validatorID = this.numValidators.value + 1
	byte 0x6e756d56 // "numV"
	app_global_get
	int 1
	+
	frame_bury 0 // validatorID: uint64

	// contracts/validatorRegistry.algo.ts:113
	// this.numValidators.value = validatorID
	byte 0x6e756d56 // "numV"
	frame_dig 0 // validatorID: uint64
	app_global_put

	// contracts/validatorRegistry.algo.ts:115
	// this.ValidatorList(validatorID).create()
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	int 481
	box_create
	pop

	// contracts/validatorRegistry.algo.ts:116
	// this.ValidatorList(validatorID).value.ID = validatorID
	int 0
	frame_dig 0 // validatorID: uint64
	itob
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:117
	// this.ValidatorList(validatorID).value.Owner = owner
	int 8 // headOffset
	frame_dig -1 // owner: Address
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:118
	// this.ValidatorList(validatorID).value.Manager = manager
	int 40 // headOffset
	frame_dig -2 // manager: Address
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:119
	// this.ValidatorList(validatorID).value.NFDForInfo = nfdAppID
	int 72 // headOffset
	frame_dig -3 // nfdAppID: uint64
	itob
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:120
	// this.ValidatorList(validatorID).value.Config = config
	int 80 // headOffset
	frame_dig -4 // config: ValidatorConfig
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:122
	// this.ValidatorList(validatorID).value.Nodes[0].Name = 'foo'
	int 141
	byte 0x666f6f // "foo"
	byte 0x76 // "v"
	frame_dig 0 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:123
	// return validatorID;
	frame_dig 0 // validatorID: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// addPool(uint64)(uint64,uint16)
abi_route_addPool:
	// The ABI return prefix
	byte 0x151f7c75

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute addPool(uint64)(uint64,uint16)
	callsub addPool
	concat
	log
	int 1
	return

// addPool(validatorID: ValidatorID): ValidatorPoolKey
//
// Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
addPool:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/validatorRegistry.algo.ts:129
	// assert(this.ValidatorList(validatorID).exists)
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:131
	// owner = this.ValidatorList(validatorID).value.Owner
	int 8 // headOffset
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // owner: address

	// contracts/validatorRegistry.algo.ts:132
	// manager = this.ValidatorList(validatorID).value.Manager
	int 40 // headOffset
	int 32
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 1 // manager: address

	// contracts/validatorRegistry.algo.ts:135
	// assert(this.txn.sender === owner || this.txn.sender === manager)
	txn Sender
	frame_dig 0 // owner: address
	==
	dup
	bnz skip_or0
	txn Sender
	frame_dig 1 // manager: address
	==
	||

skip_or0:
	assert

	// contracts/validatorRegistry.algo.ts:137
	// numPools = this.ValidatorList(validatorID).value.State.NumPools
	int 121
	int 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 2 // numPools: uint16

	// if0_condition
	// contracts/validatorRegistry.algo.ts:138
	// (numPools as uint64) >= MAX_POOLS
	frame_dig 2 // numPools: uint16
	int 12
	>=
	bz if0_end

	// if0_consequent
	err // 'already at max pool size'

if0_end:
	// contracts/validatorRegistry.algo.ts:141
	// numPools += 1
	frame_dig 2 // numPools: uint16
	int 1
	+
	frame_bury 2 // numPools: uint16

	// contracts/validatorRegistry.algo.ts:143
	// this.ValidatorList(validatorID).value.State.NumPools = numPools
	int 121
	frame_dig 2 // numPools: uint16
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:148
	// return { ID: validatorID, PoolID: numPools };
	frame_dig -1 // validatorID: ValidatorID
	itob
	frame_dig 2 // numPools: uint16
	itob
	extract 6 2
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// addStake(uint64,uint64)((uint64,uint16),uint8)
abi_route_addStake:
	// The ABI return prefix
	byte 0x151f7c75

	// amountToStake: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute addStake(uint64,uint64)((uint64,uint16),uint8)
	callsub addStake
	concat
	log
	int 1
	return

// addStake(validatorID: ValidatorID, amountToStake: uint64): ValidatorPoolSlotKey
addStake:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/validatorRegistry.algo.ts:154
	// verifyPayTxn(this.txnGroup[this.txn.groupIndex - 1], {
	//             sender: this.txn.sender,
	//             receiver: this.app.address,
	//             amount: amountToStake,
	//         })
	txn GroupIndex
	int 1
	-
	store 248 // verifyTxn index

	// verify pay
	load 248 // verifyTxn index
	gtxns TypeEnum
	int pay
	==
	assert

	// verify sender
	load 248 // verifyTxn index
	gtxns Sender
	txn Sender
	==
	assert

	// verify receiver
	load 248 // verifyTxn index
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	load 248 // verifyTxn index
	gtxns Amount
	frame_dig -2 // amountToStake: uint64
	==
	assert

	// contracts/validatorRegistry.algo.ts:162
	// neverStaked = this.StakerPoolList(this.txn.sender).exists
	byte 0x73706c // "spl"
	txn Sender
	concat
	box_len
	swap
	pop
	frame_bury 1 // neverStaked: uint64

	// contracts/validatorRegistry.algo.ts:163
	// slot: uint8 = 0
	int 0
	frame_bury 2 // slot: uint8

	// if1_condition
	// contracts/validatorRegistry.algo.ts:164
	// neverStaked
	frame_dig 1 // neverStaked: uint64
	bz if1_else

	// if1_consequent
	// contracts/validatorRegistry.algo.ts:166
	// poolKey = this.findPoolForStake(validatorID, amountToStake)
	frame_dig -2 // amountToStake: uint64
	frame_dig -1 // validatorID: ValidatorID
	callsub findPoolForStake
	frame_bury 0 // poolKey: ValidatorPoolKey

	// if2_condition
	// contracts/validatorRegistry.algo.ts:167
	// poolKey.PoolID == 0
	frame_dig 0 // poolKey: ValidatorPoolKey
	extract 8 2
	btoi
	int 0
	==
	bz if2_end

// if2_consequent
if2_end:
	// contracts/validatorRegistry.algo.ts:173
	// poolKey = { ID: validatorID, PoolID: 0 }
	frame_dig -1 // validatorID: ValidatorID
	itob
	byte 0x0000
	concat
	frame_bury 0 // poolKey: ValidatorPoolKey
	b if1_end

if1_else:

if1_end:
	// contracts/validatorRegistry.algo.ts:177
	// return { PoolKey: { ID: 0, PoolID: 0 }, Slot: slot };
	byte 0x0000000000000000000000

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// stakeRemoved(uint64,uint64,address,uint64,bool)void
abi_route_stakeRemoved:
	// stakerRemoved: bool
	txna ApplicationArgs 5
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// amountRemoved: uint64
	txna ApplicationArgs 4
	btoi

	// staker: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// poolID: uint64
	txna ApplicationArgs 2
	btoi

	// validatorID: uint64
	txna ApplicationArgs 1
	btoi

	// execute stakeRemoved(uint64,uint64,address,uint64,bool)void
	callsub stakeRemoved
	int 1
	return

// stakeRemoved(validatorID: uint64, poolID: uint64, staker: Address, amountRemoved: uint64, stakerRemoved: boolean): void
//
// stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removed
// from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
// The calling App ID is validated against our pool list as well.
// @param validatorID
// @param poolID - 1-index based index into list of pools for this validator
// @param staker
// @param amountRemoved
// @param stakerRemoved
stakeRemoved:
	proto 5 0

	// contracts/validatorRegistry.algo.ts:198
	// assert(this.ValidatorList(validatorID).exists)
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/validatorRegistry.algo.ts:199
	// assert(poolID < 2 ** 16)
	frame_dig -2 // poolID: uint64
	int 2
	int 16
	exp
	<
	assert

	// contracts/validatorRegistry.algo.ts:200
	// assert(poolID > 0 && (poolID as uint16) <= this.ValidatorList(validatorID).value.State.NumPools)
	frame_dig -2 // poolID: uint64
	int 0
	>
	dup
	bz skip_and0
	frame_dig -2 // poolID: uint64
	int 121
	int 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	<=
	&&

skip_and0:
	assert

	// contracts/validatorRegistry.algo.ts:203
	// assert(
	//             this.txn.sender ==
	//                 Application.fromID(this.ValidatorList(validatorID).value.Pools[poolID - 1].PoolAppID).address
	//         )
	txn Sender
	int 241 // headOffset
	frame_dig -2 // poolID: uint64
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 2 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	app_params_get AppAddress
	pop
	==
	assert

	// contracts/validatorRegistry.algo.ts:208
	// this.ValidatorList(validatorID).value.Pools[poolID - 1].TotalAlgoStaked -= amountRemoved
	int 241 // headOffset
	frame_dig -2 // poolID: uint64
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 241 // headOffset
	frame_dig -2 // poolID: uint64
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 12 // headOffset
	+
	int 8
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -4 // amountRemoved: uint64
	-
	itob
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

	// if3_condition
	// contracts/validatorRegistry.algo.ts:209
	// stakerRemoved
	frame_dig -5 // stakerRemoved: boolean
	bz if3_end

	// if3_consequent
	// contracts/validatorRegistry.algo.ts:210
	// this.ValidatorList(validatorID).value.Pools[poolID - 1].TotalStakers -= 1
	int 241 // headOffset
	frame_dig -2 // poolID: uint64
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 241 // headOffset
	frame_dig -2 // poolID: uint64
	int 1
	-
	int 20
	* // acc * typeLength
	+
	int 10 // headOffset
	+
	int 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_extract
	btoi
	int 1
	-
	itob
	extract 6 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: uint64
	itob
	concat
	cover 2
	box_replace

if3_end:
	retsub

// findPoolForStake(validatorID: ValidatorID, amountToStake: uint64): ValidatorPoolKey
findPoolForStake:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/validatorRegistry.algo.ts:215
	// pools = clone(this.ValidatorList(validatorID).value.Pools)
	int 241 // headOffset
	int 240
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	frame_bury 0 // pools: (uint16,uint64,uint16,uint64)[12]

	// contracts/validatorRegistry.algo.ts:216
	// numPools = this.ValidatorList(validatorID).value.State.NumPools
	int 121
	int 2
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // numPools: uint16

	// contracts/validatorRegistry.algo.ts:217
	// i: uint16 = 0
	int 0
	frame_bury 2 // i: uint16

for_0:
	// contracts/validatorRegistry.algo.ts:217
	// i < numPools
	frame_dig 2 // i: uint16
	frame_dig 1 // numPools: uint16
	<
	bz for_0_end

	// if4_condition
	// contracts/validatorRegistry.algo.ts:218
	// pools[i].TotalAlgoStaked + amountToStake < MAX_ALGO_PER_POOL
	frame_dig 0 // pools: (uint16,uint64,uint16,uint64)[12]
	frame_dig 2 // i: uint16
	int 20
	* // acc * typeLength
	int 12 // headOffset
	+
	int 8
	extract3
	btoi
	frame_dig -2 // amountToStake: uint64
	+
	int 20000000000000
	<
	bz if4_end

	// if4_consequent
	// contracts/validatorRegistry.algo.ts:219
	// return { ID: validatorID, PoolID: i + 1 };
	frame_dig -1 // validatorID: ValidatorID
	itob
	frame_dig 2 // i: uint16
	int 1
	+
	itob
	dup
	bitlen
	int 16
	<=
	assert
	extract 6 2
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

if4_end:
	// contracts/validatorRegistry.algo.ts:217
	// i += 1
	frame_dig 2 // i: uint16
	int 1
	+
	frame_bury 2 // i: uint16
	b for_0

for_0_end:
	// contracts/validatorRegistry.algo.ts:222
	// this.ValidatorList(validatorID).value.Pools = pools
	int 241 // headOffset
	frame_dig 0 // pools: (uint16,uint64,uint16,uint64)[12]
	byte 0x76 // "v"
	frame_dig -1 // validatorID: ValidatorID
	itob
	concat
	cover 2
	box_replace

	// contracts/validatorRegistry.algo.ts:224
	// return { ID: validatorID, PoolID: 0 };
	frame_dig -1 // validatorID: ValidatorID
	itob
	byte 0x0000
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// validateConfig(config: ValidatorConfig): void
validateConfig:
	proto 1 0

	// contracts/validatorRegistry.algo.ts:239
	// assert(config.PayoutEveryXDays >= MIN_PAYOUT_DAYS && config.PayoutEveryXDays <= MAX_PAYOUT_DAYS)
	frame_dig -1 // config: ValidatorConfig
	extract 0 2
	btoi
	int 1
	>=
	dup
	bz skip_and1
	frame_dig -1 // config: ValidatorConfig
	extract 0 2
	btoi
	int 30
	<=
	&&

skip_and1:
	assert

	// contracts/validatorRegistry.algo.ts:240
	// assert(config.PercentToValidator >= MIN_PCT_TO_VALIDATOR && config.PercentToValidator <= MAX_PCT_TO_VALIDATOR)
	frame_dig -1 // config: ValidatorConfig
	extract 2 4
	btoi
	int 10000
	>=
	dup
	bz skip_and2
	frame_dig -1 // config: ValidatorConfig
	extract 2 4
	btoi
	int 100000
	<=
	&&

skip_and2:
	assert

	// contracts/validatorRegistry.algo.ts:241
	// assert(config.ValidatorCommissionAddress !== Address.zeroAddress)
	frame_dig -1 // config: ValidatorConfig
	extract 6 32
	global ZeroAddress
	!=
	assert

	// contracts/validatorRegistry.algo.ts:242
	// assert(config.PoolsPerNode > 0 && config.PoolsPerNode <= MAX_POOLS_PER_NODE)
	frame_dig -1 // config: ValidatorConfig
	extract 38 1
	btoi
	int 0
	>
	dup
	bz skip_and3
	frame_dig -1 // config: ValidatorConfig
	extract 38 1
	btoi
	int 4
	<=
	&&

skip_and3:
	assert

	// contracts/validatorRegistry.algo.ts:243
	// assert(config.MaxNodes > 0 && config.MaxNodes <= MAX_NODES)
	frame_dig -1 // config: ValidatorConfig
	extract 39 2
	btoi
	int 0
	>
	dup
	bz skip_and4
	frame_dig -1 // config: ValidatorConfig
	extract 39 2
	btoi
	int 3
	<=
	&&

skip_and4:
	assert
	retsub

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "getNumValidators()uint64"
	method "getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[3],(uint16,uint64,uint16,uint64)[12])"
	method "getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)"
	method "addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64"
	method "addPool(uint64)(uint64,uint16)"
	method "addStake(uint64,uint64)((uint64,uint16),uint8)"
	method "stakeRemoved(uint64,uint64,address,uint64,bool)void"
	txna ApplicationArgs 0
	match abi_route_getNumValidators abi_route_getValidatorInfo abi_route_getValidatorConfig abi_route_addValidator abi_route_addPool abi_route_addStake abi_route_stakeRemoved
	err