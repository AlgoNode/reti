#pragma version 9

// This TEAL was generated by TEALScript v0.76.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// addStake(address,uint64)void
abi_route_addStake:
	// amountToStake: uint64
	txna ApplicationArgs 2
	btoi

	// account: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute addStake(address,uint64)void
	callsub addStake
	int 1
	return

// addStake(account: Address, amountToStake: uint64): void
addStake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/stakingPool.algo.ts:19
	// assert(account !== Account.zeroAddress)
	frame_dig -1 // account: Address
	global ZeroAddress
	!=
	assert

	// contracts/stakingPool.algo.ts:20
	// assert(this.txn.sender === account)
	txn Sender
	frame_dig -1 // account: Address
	==
	assert

	// contracts/stakingPool.algo.ts:24
	// assert(this.txnGroup[this.txn.groupIndex - 1].sender === Application.fromID(this.VALIDATOR_APP_ID).address)
	txn GroupIndex
	int 1
	-
	gtxns Sender
	pushint TMPL_VALIDATOR_APP_ID
	app_params_get AppAddress
	pop
	==
	assert

	// contracts/stakingPool.algo.ts:25
	// verifyPayTxn(this.txnGroup[this.txn.groupIndex - 1], {
	//             receiver: this.app.address,
	//             amount: amountToStake,
	//         })
	txn GroupIndex
	int 1
	-
	store 248 // verifyTxn index

	// verify pay
	load 248 // verifyTxn index
	gtxns TypeEnum
	int pay
	==
	assert

	// verify receiver
	load 248 // verifyTxn index
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	load 248 // verifyTxn index
	gtxns Amount
	frame_dig -2 // amountToStake: uint64
	==
	assert

	// contracts/stakingPool.algo.ts:30
	// firstEmpty = 0
	int 0
	frame_bury 0 // firstEmpty: uint64

	// contracts/stakingPool.algo.ts:33
	// i = 0
	int 0
	frame_bury 1 // i: uint64

for_0:
	// contracts/stakingPool.algo.ts:33
	// i < 100
	frame_dig 1 // i: uint64
	int 100
	<
	bz for_0_end

	// if0_condition
	// contracts/stakingPool.algo.ts:34
	// this.Stakers.value[i].Account === account
	frame_dig 1 // i: uint64
	int 40
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // account: Address
	==
	bz if0_else

	// if0_consequent
	// contracts/stakingPool.algo.ts:35
	// this.Stakers.value[i].Balance += amountToStake
	frame_dig 1 // i: uint64
	int 40
	* // acc * typeLength
	int 32 // headOffset
	+
	frame_dig 1 // i: uint64
	int 40
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToStake: uint64
	+
	itob
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace
	b if0_end

if0_else:
	// if1_condition
	// contracts/stakingPool.algo.ts:37
	// firstEmpty != 0 && this.Stakers.value[i].Account === Address.zeroAddress
	frame_dig 0 // firstEmpty: uint64
	int 0
	!=
	dup
	bz skip_and0
	frame_dig 1 // i: uint64
	int 40
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	global ZeroAddress
	==
	&&

skip_and0:
	bz if1_end

	// if1_consequent
	// contracts/stakingPool.algo.ts:38
	// firstEmpty = i + 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 0 // firstEmpty: uint64

if1_end:

if0_end:
	// contracts/stakingPool.algo.ts:33
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b for_0

for_0_end:
	// if2_condition
	// contracts/stakingPool.algo.ts:42
	// firstEmpty == 0
	frame_dig 0 // firstEmpty: uint64
	int 0
	==
	bz if2_end

	// if2_consequent
	err // 'Staking pool full'

if2_end:
	// contracts/stakingPool.algo.ts:46
	// this.Stakers.value[firstEmpty - 1] = {Account: account, Balance: amountToStake}
	frame_dig 0 // firstEmpty: uint64
	int 1
	-
	int 40
	* // acc * typeLength
	frame_dig -1 // account: Address
	frame_dig -2 // amountToStake: uint64
	itob
	concat
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace
	retsub

// removeStake(address,uint64)void
abi_route_removeStake:
	// amountToUnstake: uint64
	txna ApplicationArgs 2
	btoi

	// account: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute removeStake(address,uint64)void
	callsub removeStake
	int 1
	return

// removeStake(account: Address, amountToUnstake: uint64): void
removeStake:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/stakingPool.algo.ts:57
	// assert(account !== Account.zeroAddress)
	frame_dig -1 // account: Address
	global ZeroAddress
	!=
	assert

	// contracts/stakingPool.algo.ts:58
	// assert(this.txn.sender === account)
	txn Sender
	frame_dig -1 // account: Address
	==
	assert

	// contracts/stakingPool.algo.ts:60
	// i = 0
	int 0
	frame_bury 0 // i: uint64

for_1:
	// contracts/stakingPool.algo.ts:60
	// i < 100
	frame_dig 0 // i: uint64
	int 100
	<
	bz for_1_end

	// if3_condition
	// contracts/stakingPool.algo.ts:61
	// this.Stakers.value[i].Account === account
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 0
	+
	int 32
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	frame_dig -1 // account: Address
	==
	bz if3_end

	// if3_consequent
	// if4_condition
	// contracts/stakingPool.algo.ts:62
	// this.Stakers.value[i].Balance < amountToUnstake
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToUnstake: uint64
	<
	bz if4_end

	// if4_consequent
	err // 'Insufficient balance'

if4_end:
	// contracts/stakingPool.algo.ts:65
	// this.Stakers.value[i].Balance -= amountToUnstake
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 32 // headOffset
	+
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	frame_dig -2 // amountToUnstake: uint64
	-
	itob
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

	// contracts/stakingPool.algo.ts:67
	// sendPayment({
	//                     amount: amountToUnstake,
	//                     receiver: account,
	//                     note: 'unstaked',
	//                 })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/stakingPool.algo.ts:68
	// amount: amountToUnstake
	frame_dig -2 // amountToUnstake: uint64
	itxn_field Amount

	// contracts/stakingPool.algo.ts:69
	// receiver: account
	frame_dig -1 // account: Address
	itxn_field Receiver

	// contracts/stakingPool.algo.ts:70
	// note: 'unstaked'
	byte 0x756e7374616b6564 // "unstaked"
	itxn_field Note

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/stakingPool.algo.ts:73
	// sendAppCall({
	//                     onCompletion: OnCompletion.NoOp,
	//                     applicationID: Application.fromID(this.VALIDATOR_APP_ID),
	//                     // approvalProgram: ValidatorRegistry.approvalProgram(),
	//                 })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/stakingPool.algo.ts:74
	// onCompletion: OnCompletion.NoOp
	int 0 // NoOp
	itxn_field OnCompletion

	// contracts/stakingPool.algo.ts:75
	// applicationID: Application.fromID(this.VALIDATOR_APP_ID)
	pushint TMPL_VALIDATOR_APP_ID
	itxn_field ApplicationID

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// if5_condition
	// contracts/stakingPool.algo.ts:78
	// this.Stakers.value[i].Balance === 0
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 32 // headOffset
	+
	int 8
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_extract
	btoi
	int 0
	==
	bz if5_end

	// if5_consequent
	// contracts/stakingPool.algo.ts:80
	// this.Stakers.value[i].Account = Address.zeroAddress
	frame_dig 0 // i: uint64
	int 40
	* // acc * typeLength
	int 0
	+
	global ZeroAddress
	byte 0x7374616b657273 // "stakers"
	cover 2
	box_replace

if5_end:
	// contracts/stakingPool.algo.ts:83
	// return;
	retsub

if3_end:
	// contracts/stakingPool.algo.ts:60
	// i += 1
	frame_dig 0 // i: uint64
	int 1
	+
	frame_bury 0 // i: uint64
	b for_1

for_1_end:
	err // 'Account not found'

abi_route_createApplication:
	int 1
	return

create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "addStake(address,uint64)void"
	method "removeStake(address,uint64)void"
	txna ApplicationArgs 0
	match abi_route_addStake abi_route_removeStake
	err