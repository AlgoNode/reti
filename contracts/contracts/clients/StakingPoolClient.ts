/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication(uint64,uint64,uint64,address,address)void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addStake(pay,address)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "removeStake(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "payStakers()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "goOffline()void": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "CreatingValidatorContractAppID": {
          "type": "uint64",
          "key": "creatorApp"
        },
        "ValidatorID": {
          "type": "uint64",
          "key": "validatorID"
        },
        "PoolID": {
          "type": "uint64",
          "key": "poolID"
        },
        "Owner": {
          "type": "bytes",
          "key": "owner"
        },
        "Manager": {
          "type": "bytes",
          "key": "manager"
        },
        "NumStakers": {
          "type": "uint64",
          "key": "numStakers"
        },
        "TotalAlgoStaked": {
          "type": "uint64",
          "key": "staked"
        },
        "MaxAlgo": {
          "type": "uint64",
          "key": "maxStake"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 2,
      "num_uints": 6
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDkKCi8vIFRoaXMgVEVBTCB3YXMgZ2VuZXJhdGVkIGJ5IFRFQUxTY3JpcHQgdjAuODEuMAovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCBjYWxsX05vT3AgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBjcmVhdGVfTm9PcCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVECgpOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkCmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIG1hbmFnZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBvd25lcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHBvb2xJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGNyZWF0aW5nQ29udHJhY3RJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBjcmVhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlQXBwbGljYXRpb24oY3JlYXRpbmdDb250cmFjdElEOiB1aW50NjQsIHZhbGlkYXRvcklEOiB1aW50NjQsIHBvb2xJRDogdWludDY0LCBvd25lcjogQWRkcmVzcywgbWFuYWdlcjogQWRkcmVzcyk6IHZvaWQKLy8KLy8gSW5pdGlhbGl6ZSB0aGUgc3Rha2luZyBwb29sIHcvIG93bmVyIGFuZCBtYW5hZ2VyLCBidXQgY2FuIG9ubHkgYmUgY3JlYXRlZCBieSB0aGUgdmFsaWRhdG9yIGNvbnRyYWN0LgovLyBAcGFyYW0gY3JlYXRpbmdDb250cmFjdElEIC0gaWQgb2YgY29udHJhY3QgdGhhdCBjb25zdHJ1Y3RlZCB1cyAtIHRoZSB2YWxpZGF0b3IgYXBwbGljYXRpb24gKHNpbmdsZSBnbG9iYWwgaW5zdGFuY2UpCi8vIEBwYXJhbSB2YWxpZGF0b3JJRCAtIGlkIG9mIHZhbGlkYXRvciB3ZSdyZSBhIHN0YWtpbmcgcG9vbCBvZgovLyBAcGFyYW0gcG9vbElEIC0gd2hpY2ggcG9vbCBpZCBhcmUgd2UKLy8gQHBhcmFtIG93bmVyCi8vIEBwYXJhbSBtYW5hZ2VyCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gNSAwCgoJLy8gaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NTMKCS8vIG93bmVyID09PSBnbG9iYWxzLnplcm9BZGRyZXNzIHx8IG1hbmFnZXIgPT09IGdsb2JhbHMuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAtNCAvLyBvd25lcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgk9PQoJZHVwCglibnogc2tpcF9vcjAKCWZyYW1lX2RpZyAtNSAvLyBtYW5hZ2VyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cgl8fAoKc2tpcF9vcjA6CglieiBpZjBfZWxzZQoKCS8vIGlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo1NQoJLy8gYXNzZXJ0KG93bmVyID09PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC00IC8vIG93bmVyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo1NgoJLy8gYXNzZXJ0KG1hbmFnZXIgPT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTUgLy8gbWFuYWdlcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NTcKCS8vIGFzc2VydChjcmVhdGluZ0NvbnRyYWN0SUQgPT09IDApCglmcmFtZV9kaWcgLTEgLy8gY3JlYXRpbmdDb250cmFjdElEOiB1aW50NjQKCWludCAwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NTgKCS8vIGFzc2VydCh2YWxpZGF0b3JJRCA9PT0gMCkKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJRDogdWludDY0CglpbnQgMAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjU5CgkvLyBhc3NlcnQocG9vbElEID09PSAwKQoJZnJhbWVfZGlnIC0zIC8vIHBvb2xJRDogdWludDY0CglpbnQgMAoJPT0KCWFzc2VydAoJYiBpZjBfZW5kCgppZjBfZWxzZToKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjYxCgkvLyBhc3NlcnQoY3JlYXRpbmdDb250cmFjdElEICE9PSAwKQoJZnJhbWVfZGlnIC0xIC8vIGNyZWF0aW5nQ29udHJhY3RJRDogdWludDY0CglpbnQgMAoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjYyCgkvLyBhc3NlcnQodmFsaWRhdG9ySUQgIT09IDApCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2MwoJLy8gYXNzZXJ0KHBvb2xJRCAhPT0gMCkKCWZyYW1lX2RpZyAtMyAvLyBwb29sSUQ6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCmlmMF9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2NQoJLy8gdGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUgPSBjcmVhdGluZ0NvbnRyYWN0SUQKCWJ5dGUgMHg2MzcyNjU2MTc0NmY3MjQxNzA3MCAvLyAiY3JlYXRvckFwcCIKCWZyYW1lX2RpZyAtMSAvLyBjcmVhdGluZ0NvbnRyYWN0SUQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2NgoJLy8gdGhpcy5WYWxpZGF0b3JJRC52YWx1ZSA9IHZhbGlkYXRvcklECglieXRlIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyNDk0NCAvLyAidmFsaWRhdG9ySUQiCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2NwoJLy8gdGhpcy5Qb29sSUQudmFsdWUgPSBwb29sSUQKCWJ5dGUgMHg3MDZmNmY2YzQ5NDQgLy8gInBvb2xJRCIKCWZyYW1lX2RpZyAtMyAvLyBwb29sSUQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2OAoJLy8gdGhpcy5Pd25lci52YWx1ZSA9IG93bmVyCglieXRlIDB4NmY3NzZlNjU3MiAvLyAib3duZXIiCglmcmFtZV9kaWcgLTQgLy8gb3duZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NjkKCS8vIHRoaXMuTWFuYWdlci52YWx1ZSA9IG1hbmFnZXIKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWZyYW1lX2RpZyAtNSAvLyBtYW5hZ2VyOiBBZGRyZXNzCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjcwCgkvLyB0aGlzLk51bVN0YWtlcnMudmFsdWUgPSAwCglieXRlIDB4NmU3NTZkNTM3NDYxNmI2NTcyNzMgLy8gIm51bVN0YWtlcnMiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo3MQoJLy8gdGhpcy5Ub3RhbEFsZ29TdGFrZWQudmFsdWUgPSAwCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo3MgoJLy8gdGhpcy5NYXhBbGdvLnZhbHVlID0gTUFYX0FMR09fUEVSX1BPT0wKCWJ5dGUgMHg2ZDYxNzg1Mzc0NjE2YjY1IC8vICJtYXhTdGFrZSIKCWludCAyMDAwMDAwMDAwMDAwMAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gZ2FzKCl2b2lkCmFiaV9yb3V0ZV9nYXM6CgkvLyBleGVjdXRlIGdhcygpdm9pZAoJY2FsbHN1YiBnYXMKCWludCAxCglyZXR1cm4KCi8vIGdhcygpOiB2b2lkCi8vCi8vIGdhcyBpcyBhIGR1bW15IG5vLW9wIGNhbGwgdGhhdCBjYW4gYmUgdXNlZCB0byBwb29sLXVwIHJlc291cmNlIHJlZmVyZW5jZXMgYW5kIG9wY29kZSBjb3N0CmdhczoKCXByb3RvIDAgMAoJcmV0c3ViCgovLyBhZGRTdGFrZShwYXksYWRkcmVzcyl1aW50NjQKYWJpX3JvdXRlX2FkZFN0YWtlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBzdGFrZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBzdGFrZWRBbW91bnRQYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgYWRkU3Rha2UocGF5LGFkZHJlc3MpdWludDY0CgljYWxsc3ViIGFkZFN0YWtlCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYWRkU3Rha2Uoc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuLCBzdGFrZXI6IEFkZHJlc3MpOiB1aW50NjQKLy8KLy8gQWRkcyBzdGFrZSB0byB0aGUgZ2l2ZW4gYWNjb3VudC4KLy8gQ2FuIE9OTFkgYmUgY2FsbGVkIGJ5IHRoZSB2YWxpZGF0b3IgY29udHJhY3QgdGhhdCBjcmVhdGVkIHVzCi8vIE11c3QgcmVjZWl2ZSBwYXltZW50IGZyb20gdGhlIHZhbGlkYXRvciBjb250cmFjdCBmb3IgYW1vdW50IGJlaW5nIHN0YWtlZC4KLy8KLy8gQHBhcmFtIHtQYXlUeG59IHN0YWtlZEFtb3VudFBheW1lbnQgcHJpb3IgcGF5bWVudCBjb21pbmcgZnJvbSB2YWxpZGF0b3IgY29udHJhY3QgdG8gdXMgb24gYmVoYWxmIG9mIHN0YWtlci4KLy8gQHBhcmFtIHtBZGRyZXNzfSBzdGFrZXIgLSBUaGUgYWNjb3VudCBhZGRpbmcgbmV3IHN0YWtlCi8vIEB0aHJvd3Mge0Vycm9yfSAtIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc3Rha2luZyBwb29sIGlzIGZ1bGwuCi8vIEByZXR1cm5zIHt1aW50NjR9IG5ldyAnZW50cnkgdGltZScgaW4gc2Vjb25kcyBvZiBzdGFrZSBhZGQuCmFkZFN0YWtlOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjkxCgkvLyAhdGhpcy5TdGFrZXJzLmV4aXN0cwoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiBpZjFfZW5kCgoJLy8gaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjkyCgkvLyB0aGlzLlN0YWtlcnMuY3JlYXRlKCkKCWJ5dGUgMHg3Mzc0NjE2YjY1NzI3MyAvLyAic3Rha2VycyIKCWludCA0MDg4Cglib3hfY3JlYXRlCglwb3AKCmlmMV9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo5NQoJLy8gYXNzZXJ0KHN0YWtlciAhPT0gQWNjb3VudC56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjk2CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUpLmFkZHJlc3MpCgl0eG4gU2VuZGVyCglieXRlIDB4NjM3MjY1NjE3NDZmNzI0MTcwNzAgLy8gImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTAwCgkvLyB2ZXJpZnlQYXlUeG4oc3Rha2VkQW1vdW50UGF5bWVudCwgewoJLy8gICAgICAgICAgICAgc2VuZGVyOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUpLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgIGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQsCgkvLyAgICAgICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBTZW5kZXIKCWJ5dGUgMHg2MzcyNjU2MTc0NmY3MjQxNzA3MCAvLyAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTA3CgkvLyBlbnRyeVRpbWUgPSB0aGlzLmdldEVudHJ5VGltZSgpCgljYWxsc3ViIGdldEVudHJ5VGltZQoJZnJhbWVfYnVyeSAwIC8vIGVudHJ5VGltZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTA4CgkvLyBmaXJzdEVtcHR5ID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMTEKCS8vIHN0YWtlcnMgPSBjbG9uZSh0aGlzLlN0YWtlcnMudmFsdWUpCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCglib3hfZ2V0Cglhc3NlcnQKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTEyCgkvLyBpID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCmZvcl8wOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTEyCgkvLyBpIDwgTUFYX1NUQUtFUlNfUEVSX1BPT0wKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDczCgk8CglieiBmb3JfMF9lbmQKCgkvLyBpZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMTMKCS8vIHN0YWtlcnNbaV0uQWNjb3VudCA9PT0gc3Rha2VyCglmcmFtZV9kaWcgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMAoJKwoJaW50IDMyCglleHRyYWN0MwoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJPT0KCWJ6IGlmMl9lbmQKCgkvLyBpZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTE0CgkvLyBzdGFrZXJzW2ldLkJhbGFuY2UgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcnM6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KVs3M10KCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludCAzMiAvLyBoZWFkT2Zmc2V0CgkrCglmcmFtZV9kaWcgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMzIgLy8gaGVhZE9mZnNldAoJKwoJaW50IDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCSsKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyczogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpWzczXQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjExNQoJLy8gc3Rha2Vyc1tpXS5FbnRyeVRpbWUgPSBlbnRyeVRpbWUKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcnM6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KVs3M10KCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludCA0OCAvLyBoZWFkT2Zmc2V0CgkrCglmcmFtZV9kaWcgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTE3CgkvLyB0aGlzLlN0YWtlcnMudmFsdWVbaV0gPSBzdGFrZXJzW2ldCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgNTYKCWV4dHJhY3QzCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjExOAoJLy8gdGhpcy5Ub3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCSsKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTE5CgkvLyByZXR1cm4gZW50cnlUaW1lOwoJZnJhbWVfZGlnIDAgLy8gZW50cnlUaW1lOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAzCglyZXRzdWIKCmlmMl9lbmQ6CgkvLyBpZjNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMjEKCS8vIHN0YWtlcnNbaV0uQWNjb3VudCA9PT0gQWRkcmVzcy56ZXJvQWRkcmVzcwoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyczogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpWzczXQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgNTYKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50IDAKCSsKCWludCAzMgoJZXh0cmFjdDMKCWdsb2JhbCBaZXJvQWRkcmVzcwoJPT0KCWJ6IGlmM19lbmQKCgkvLyBpZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTIyCgkvLyBmaXJzdEVtcHR5ID0gaSArIDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCWIgZm9yXzBfZW5kCgppZjNfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTI1CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMTIKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoJYiBmb3JfMAoKZm9yXzBfZW5kOgoJLy8gaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTI4CgkvLyBmaXJzdEVtcHR5ID09PSAwCglmcmFtZV9kaWcgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCWludCAwCgk9PQoJYnogaWY0X2VuZAoKCS8vIGlmNF9jb25zZXF1ZW50CgllcnIgLy8gJ1N0YWtpbmcgcG9vbCBmdWxsJwoKaWY0X2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEzNAoJLy8gYXNzZXJ0KHRoaXMuU3Rha2Vycy52YWx1ZVtmaXJzdEVtcHR5IC0gMV0uQWNjb3VudCA9PT0gQWRkcmVzcy56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50IDEKCS0KCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMAoJKwoJaW50IDMyCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCgljb3ZlciAyCglib3hfZXh0cmFjdAoJZ2xvYmFsIFplcm9BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTM1CgkvLyB0aGlzLlN0YWtlcnMudmFsdWVbZmlyc3RFbXB0eSAtIDFdID0gewoJLy8gICAgICAgICAgICAgQWNjb3VudDogc3Rha2VyLAoJLy8gICAgICAgICAgICAgQmFsYW5jZTogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQsCgkvLyAgICAgICAgICAgICBUb3RhbFJld2FyZGVkOiAwLAoJLy8gICAgICAgICAgICAgRW50cnlUaW1lOiBlbnRyeVRpbWUsCgkvLyAgICAgICAgIH0KCWZyYW1lX2RpZyAxIC8vIGZpcnN0RW1wdHk6IHVpbnQ2NAoJaW50IDEKCS0KCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJZnJhbWVfZGlnIDAgLy8gZW50cnlUaW1lOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNDEKCS8vIHRoaXMuTnVtU3Rha2Vycy52YWx1ZSArPSAxCglieXRlIDB4NmU3NTZkNTM3NDYxNmI2NTcyNzMgLy8gIm51bVN0YWtlcnMiCglhcHBfZ2xvYmFsX2dldAoJaW50IDEKCSsKCWJ5dGUgMHg2ZTc1NmQ1Mzc0NjE2YjY1NzI3MyAvLyAibnVtU3Rha2VycyIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTQyCgkvLyB0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJKwoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNDMKCS8vIHJldHVybiBlbnRyeVRpbWU7CglmcmFtZV9kaWcgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKLy8gcmVtb3ZlU3Rha2UoYWRkcmVzcyx1aW50NjQpdm9pZAphYmlfcm91dGVfcmVtb3ZlU3Rha2U6CgkvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFjY291bnQ6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIHJlbW92ZVN0YWtlKGFkZHJlc3MsdWludDY0KXZvaWQKCWNhbGxzdWIgcmVtb3ZlU3Rha2UKCWludCAxCglyZXR1cm4KCi8vIHJlbW92ZVN0YWtlKGFjY291bnQ6IEFkZHJlc3MsIGFtb3VudFRvVW5zdGFrZTogdWludDY0KTogdm9pZAovLwovLyBSZW1vdmVzIHN0YWtlIG9uIGJlaGFsZiBvZiBhIHBhcnRpY3VsYXIgc3Rha2VyLiAgQWxzbyBub3RpZmllcyB0aGUgdmFsaWRhdG9yIGNvbnRyYWN0IGZvciB0aGlzIHBvb2xzCi8vIHZhbGlkYW90ciBvZiB0aGUgc3Rha2VyIC8gYmFsYW5jZSBjaGFuZ2VzLgovLwovLyBAcGFyYW0ge0FkZHJlc3N9IGFjY291bnQgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCByZW1vdmluZyBzdGFrZS4KLy8gQHBhcmFtIHt1aW50NjR9IGFtb3VudFRvVW5zdGFrZSAtIFRoZSBhbW91bnQgb2Ygc3Rha2UgdG8gYmUgcmVtb3ZlZC4KLy8gQHRocm93cyB7RXJyb3J9IElmIHRoZSBhY2NvdW50IGhhcyBpbnN1ZmZpY2llbnQgYmFsYW5jZSBvciBpZiB0aGUgYWNjb3VudCBpcyBub3QgZm91bmQuCnJlbW92ZVN0YWtlOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE1OAoJLy8gYXNzZXJ0KGFjY291bnQgIT09IEFjY291bnQuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTEgLy8gYWNjb3VudDogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTU5CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBhY2NvdW50KQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGFjY291bnQ6IEFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNjEKCS8vIGkgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE2MgoJLy8gdGhpcy5TdGFrZXJzLnZhbHVlCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCglib3hfZ2V0Cglhc3NlcnQKCWR1cAoJZnJhbWVfYnVyeSAxIC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZXh0cmFjdCAwIDU2CglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWludCAwCglmcmFtZV9idXJ5IDMgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCmZvckVhY2hfMDoKCS8vIGlmNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE2MwoJLy8gc3Rha2VyLkFjY291bnQgPT09IGFjY291bnQKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDAgMzIKCWZyYW1lX2RpZyAtMSAvLyBhY2NvdW50OiBBZGRyZXNzCgk9PQoJYnogaWY1X2VuZAoKCS8vIGlmNV9jb25zZXF1ZW50CgkvLyBpZjZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNjQKCS8vIHN0YWtlci5CYWxhbmNlIDwgYW1vdW50VG9VbnN0YWtlCglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCTwKCWJ6IGlmNl9lbmQKCgkvLyBpZjZfY29uc2VxdWVudAoJZXJyIC8vICdJbnN1ZmZpY2llbnQgYmFsYW5jZScKCmlmNl9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNjcKCS8vIHN0YWtlci5CYWxhbmNlIC09IGFtb3VudFRvVW5zdGFrZQoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWludCAzMiAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCS0KCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNjgKCS8vIHRoaXMuVG90YWxBbGdvU3Rha2VkLnZhbHVlIC09IGFtb3VudFRvVW5zdGFrZQoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJLQoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNzEKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhbW91bnRUb1Vuc3Rha2UsCgkvLyAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBhY2NvdW50LAoJLy8gICAgICAgICAgICAgICAgICAgICBub3RlOiAndW5zdGFrZWQnLAoJLy8gICAgICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTcyCgkvLyBhbW91bnQ6IGFtb3VudFRvVW5zdGFrZQoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudFRvVW5zdGFrZTogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE3MwoJLy8gcmVjZWl2ZXI6IGFjY291bnQKCWZyYW1lX2RpZyAtMSAvLyBhY2NvdW50OiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTc0CgkvLyBub3RlOiAndW5zdGFrZWQnCglieXRlIDB4NzU2ZTczNzQ2MTZiNjU2NCAvLyAidW5zdGFrZWQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTc2CgkvLyBzdGFrZXJSZW1vdmVkID0gZmFsc2UKCWludCAwCglmcmFtZV9idXJ5IDQgLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoKCS8vIGlmN19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE3NwoJLy8gc3Rha2VyLkJhbGFuY2UgPT09IDAKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWludCAwCgk9PQoJYnogaWY3X2VuZAoKCS8vIGlmN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNzkKCS8vIHRoaXMuTnVtU3Rha2Vycy52YWx1ZSAtPSAxCglieXRlIDB4NmU3NTZkNTM3NDYxNmI2NTcyNzMgLy8gIm51bVN0YWtlcnMiCglhcHBfZ2xvYmFsX2dldAoJaW50IDEKCS0KCWJ5dGUgMHg2ZTc1NmQ1Mzc0NjE2YjY1NzI3MyAvLyAibnVtU3Rha2VycyIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTgwCgkvLyBzdGFrZXIuQWNjb3VudCA9IEFkZHJlc3MuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgMAoJZ2xvYmFsIFplcm9BZGRyZXNzCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTgxCgkvLyBzdGFrZXIuVG90YWxSZXdhcmRlZCA9IDAKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAoJcmVwbGFjZTIgNDAKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE4MgoJLy8gc3Rha2VyUmVtb3ZlZCA9IHRydWUKCWludCAxCglmcmFtZV9idXJ5IDQgLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoKaWY3X2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE4NQoJLy8gdGhpcy5TdGFrZXJzLnZhbHVlW2ldID0gc3Rha2VyCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxOTAKCS8vIHNlbmRNZXRob2RDYWxsPFtbdWludDY0LCB1aW50NjRdLCBBZGRyZXNzLCB1aW50NjQsIGJvb2xlYW5dLCB2b2lkPih7CgkvLyAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLkNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJRC52YWx1ZSksCgkvLyAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdGFrZVJlbW92ZWQnLAoJLy8gICAgICAgICAgICAgICAgICAgICBtZXRob2RBcmdzOiBbW3RoaXMuVmFsaWRhdG9ySUQudmFsdWUsIHRoaXMuUG9vbElELnZhbHVlXSwgYWNjb3VudCwgYW1vdW50VG9VbnN0YWtlLCBzdGFrZXJSZW1vdmVkXSwKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCW1ldGhvZCAic3Rha2VSZW1vdmVkKCh1aW50NjQsdWludDY0KSxhZGRyZXNzLHVpbnQ2NCxib29sKXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE5MQoJLy8gYXBwbGljYXRpb25JRDogQXBwbGljYXRpb24uZnJvbUlEKHRoaXMuQ3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElELnZhbHVlKQoJYnl0ZSAweDYzNzI2NTYxNzQ2ZjcyNDE3MDcwIC8vICJjcmVhdG9yQXBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE5MwoJLy8gbWV0aG9kQXJnczogW1t0aGlzLlZhbGlkYXRvcklELnZhbHVlLCB0aGlzLlBvb2xJRC52YWx1ZV0sIGFjY291bnQsIGFtb3VudFRvVW5zdGFrZSwgc3Rha2VyUmVtb3ZlZF0KCWJ5dGUgMHg3NjYxNmM2OTY0NjE3NDZmNzI0OTQ0IC8vICJ2YWxpZGF0b3JJRCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglieXRlIDB4NzA2ZjZmNmM0OTQ0IC8vICJwb29sSUQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0xIC8vIGFjY291bnQ6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTIgLy8gYW1vdW50VG9VbnN0YWtlOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgNCAvLyBzdGFrZXJSZW1vdmVkOiBib29sCglieXRlIDB4MDAKCWludCAwCgl1bmNvdmVyIDIKCXNldGJpdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgppZjVfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTk2CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCgkvLyBpbmNyZW1lbnQgb2Zmc2V0IGFuZCBsb29wIGlmIG5vdCBvdXQgb2YgYm91bmRzCglmcmFtZV9kaWcgMyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJaW50IDU2CgkrCglkdXAKCWludCA0MDg4IC8vIG9mZnNldCBvZiBsYXN0IGVsZW1lbnQKCTwKCWJ6IGZvckVhY2hfMF9lbmQKCWZyYW1lX2J1cnkgMyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJZnJhbWVfZGlnIDEgLy8gY29weSBvZiB0aGUgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyCglmcmFtZV9kaWcgMyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJaW50IDU2CglleHRyYWN0CglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWIgZm9yRWFjaF8wCgpmb3JFYWNoXzBfZW5kOgoJZXJyIC8vICdBY2NvdW50IG5vdCBmb3VuZCcKCi8vIHBheVN0YWtlcnMoKXZvaWQKYWJpX3JvdXRlX3BheVN0YWtlcnM6CgkvLyBleGVjdXRlIHBheVN0YWtlcnMoKXZvaWQKCWNhbGxzdWIgcGF5U3Rha2VycwoJaW50IDEKCXJldHVybgoKLy8gcGF5U3Rha2VycygpOiB2b2lkCnBheVN0YWtlcnM6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyMwoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwMwoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy5Pd25lci52YWx1ZSB8fCB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuTWFuYWdlci52YWx1ZSkKCXR4biBTZW5kZXIKCWJ5dGUgMHg2Zjc3NmU2NTcyIC8vICJvd25lciIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJZHVwCglibnogc2tpcF9vcjEKCXR4biBTZW5kZXIKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJfHwKCnNraXBfb3IxOgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjA2CgkvLyBwYXlvdXRDb25maWcgPSBzZW5kTWV0aG9kQ2FsbDxbdWludDY0XSwgW3VpbnQxNiwgdWludDMyLCBBZGRyZXNzLCB1aW50OCwgdWludDE2XT4oewoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwbGljYXRpb24uZnJvbUlEKHRoaXMuQ3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElELnZhbHVlKSwKCS8vICAgICAgICAgICAgIG5hbWU6ICdnZXRWYWxpZGF0b3JDb25maWcnLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW3RoaXMuVmFsaWRhdG9ySUQudmFsdWVdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCW1ldGhvZCAiZ2V0VmFsaWRhdG9yQ29uZmlnKHVpbnQ2NCkodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwNwoJLy8gYXBwbGljYXRpb25JRDogQXBwbGljYXRpb24uZnJvbUlEKHRoaXMuQ3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElELnZhbHVlKQoJYnl0ZSAweDYzNzI2NTYxNzQ2ZjcyNDE3MDcwIC8vICJjcmVhdG9yQXBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwOQoJLy8gbWV0aG9kQXJnczogW3RoaXMuVmFsaWRhdG9ySUQudmFsdWVdCglieXRlIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyNDk0NCAvLyAidmFsaWRhdG9ySUQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludCAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgMCAvLyBwYXlvdXRDb25maWc6ICh1aW50MTYsdWludDMyLGFkZHJlc3MsdWludDgsdWludDE2KQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIxNAoJLy8gcGF5b3V0RGF5cyA9IHBheW91dENvbmZpZ1swXSBhcyB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHBheW91dENvbmZpZzogKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpCglleHRyYWN0IDAgMgoJYnRvaQoJZnJhbWVfYnVyeSAxIC8vIHBheW91dERheXM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIxNQoJLy8gcGN0VG9WYWxpZGF0b3IgPSBwYXlvdXRDb25maWdbMV0gYXMgdWludDY0CglmcmFtZV9kaWcgMCAvLyBwYXlvdXRDb25maWc6ICh1aW50MTYsdWludDMyLGFkZHJlc3MsdWludDgsdWludDE2KQoJZXh0cmFjdCAyIDQKCWJ0b2kKCWZyYW1lX2J1cnkgMiAvLyBwY3RUb1ZhbGlkYXRvcjogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjE2CgkvLyB2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyA9IHBheW91dENvbmZpZ1syXQoJZnJhbWVfZGlnIDAgLy8gcGF5b3V0Q29uZmlnOiAodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikKCWV4dHJhY3QgNiAzMgoJZnJhbWVfYnVyeSAzIC8vIHZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjIwCgkvLyBvcmlnQmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MuYmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDQgLy8gb3JpZ0JhbGFuY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIyMQoJLy8gcmV3YXJkQXZhaWxhYmxlID0gb3JpZ0JhbGFuY2UgLSB0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSAtIHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZnJhbWVfZGlnIDQgLy8gb3JpZ0JhbGFuY2U6IHVpbnQ2NAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCS0KCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJLQoJZnJhbWVfYnVyeSA1IC8vIHJld2FyZEF2YWlsYWJsZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjI0CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICByZXdhcmRBdmFpbGFibGUgPiBnbG9iYWxzLm1pblR4bkZlZSAqIDIsCgkvLyAgICAgICAgICAgICAnUmV3YXJkIHRvIHBheW91dCBub3QgaGlnaCBlbm91Z2ggdG8gY292ZXIgdHhuIGNvc3RzIG9mIHBheWluZyBpdCBvdXQnCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyA1IC8vIHJld2FyZEF2YWlsYWJsZTogdWludDY0CglnbG9iYWwgTWluVHhuRmVlCglpbnQgMgoJKgoJPgoKCS8vIFJld2FyZCB0byBwYXlvdXQgbm90IGhpZ2ggZW5vdWdoIHRvIGNvdmVyIHR4biBjb3N0cyBvZiBwYXlpbmcgaXQgb3V0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMzAKCS8vIHZhbGlkYXRvclBheSA9IHdpZGVSYXRpbyhbcmV3YXJkQXZhaWxhYmxlLCBwY3RUb1ZhbGlkYXRvcl0sIFsxMDAwMDAwXSkKCWZyYW1lX2RpZyA1IC8vIHJld2FyZEF2YWlsYWJsZTogdWludDY0CglmcmFtZV9kaWcgMiAvLyBwY3RUb1ZhbGlkYXRvcjogdWludDY0CgltdWx3CglpbnQgMAoJaW50IDEwMDAwMDAKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCglhc3NlcnQKCWZyYW1lX2J1cnkgNiAvLyB2YWxpZGF0b3JQYXk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIzMgoJLy8gcmV3YXJkQXZhaWxhYmxlIC09IHZhbGlkYXRvclBheQoJZnJhbWVfZGlnIDUgLy8gcmV3YXJkQXZhaWxhYmxlOiB1aW50NjQKCWZyYW1lX2RpZyA2IC8vIHZhbGlkYXRvclBheTogdWludDY0CgktCglmcmFtZV9idXJ5IDUgLy8gcmV3YXJkQXZhaWxhYmxlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMzYKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICAgIGFtb3VudDogdmFsaWRhdG9yUGF5LAoJLy8gICAgICAgICAgICAgcmVjZWl2ZXI6IHZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzLAoJLy8gICAgICAgICAgICAgbm90ZTogJ3ZhbGlkYXRvciByZXdhcmQnLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIzNwoJLy8gYW1vdW50OiB2YWxpZGF0b3JQYXkKCWZyYW1lX2RpZyA2IC8vIHZhbGlkYXRvclBheTogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIzOAoJLy8gcmVjZWl2ZXI6IHZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzCglmcmFtZV9kaWcgMyAvLyB2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIzOQoJLy8gbm90ZTogJ3ZhbGlkYXRvciByZXdhcmQnCglieXRlIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyMjA3MjY1Nzc2MTcyNjQgLy8gInZhbGlkYXRvciByZXdhcmQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjQ5CgkvLyBjdXJUaW1lID0gZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWZyYW1lX2J1cnkgNyAvLyBjdXJUaW1lOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNTEKCS8vIHBheW91dERheXNJblNlY3MgPSBwYXlvdXREYXlzICogMjQgKiA2MCAqIDYwCglmcmFtZV9kaWcgMSAvLyBwYXlvdXREYXlzOiB1aW50NjQKCWludCAyNAoJKgoJaW50IDYwCgkqCglpbnQgNjAKCSoKCWZyYW1lX2J1cnkgOCAvLyBwYXlvdXREYXlzSW5TZWNzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNzUKCS8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNzYKCS8vIGkgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSAxMCAvLyBpOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNzcKCS8vIHRoaXMuU3Rha2Vycy52YWx1ZQoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJYm94X2dldAoJYXNzZXJ0CglkdXAKCWZyYW1lX2J1cnkgMTEgLy8gY29weSBvZiB0aGUgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyCglleHRyYWN0IDAgNTYKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWludCAwCglmcmFtZV9idXJ5IDEzIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCgpmb3JFYWNoXzE6CgkvLyBpZjhfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNzgKCS8vIHN0YWtlci5BY2NvdW50ICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzCglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCAzMgoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYnogaWY4X2VuZAoKCS8vIGlmOF9jb25zZXF1ZW50CgkvLyBpZjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNzkKCS8vIHN0YWtlci5FbnRyeVRpbWUgPiBjdXJUaW1lCglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJZnJhbWVfZGlnIDcgLy8gY3VyVGltZTogdWludDY0Cgk+CglieiBpZjlfZWxzZQoKCS8vIGlmOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyODIKCS8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZSArPSBzdGFrZXIuQmFsYW5jZQoJZnJhbWVfZGlnIDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCWZyYW1lX2RpZyAxMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCgkrCglmcmFtZV9idXJ5IDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCWIgaWY5X2VuZAoKaWY5X2Vsc2U6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyODYKCS8vIHRpbWVJblBvb2wgPSBjdXJUaW1lIC0gc3Rha2VyLkVudHJ5VGltZQoJZnJhbWVfZGlnIDcgLy8gY3VyVGltZTogdWludDY0CglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJLQoJZnJhbWVfYnVyeSAxNCAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCgkvLyBpZjEwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6Mjg5CgkvLyB0aW1lSW5Qb29sIDwgcGF5b3V0RGF5c0luU2VjcwoJZnJhbWVfZGlnIDE0IC8vIHRpbWVJblBvb2w6IHVpbnQ2NAoJZnJhbWVfZGlnIDggLy8gcGF5b3V0RGF5c0luU2VjczogdWludDY0Cgk8CglieiBpZjEwX2VuZAoKCS8vIGlmMTBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjkwCgkvLyBwYXJ0aWFsU3Rha2Vyc1RvdGFsU3Rha2UgKz0gc3Rha2VyLkJhbGFuY2UKCWZyYW1lX2RpZyA5IC8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZTogdWludDY0CglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJKwoJZnJhbWVfYnVyeSA5IC8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjkxCgkvLyB0aW1lUGVyY2VudGFnZSA9ICh0aW1lSW5Qb29sICogMTAwMCkgLyBwYXlvdXREYXlzSW5TZWNzCglmcmFtZV9kaWcgMTQgLy8gdGltZUluUG9vbDogdWludDY0CglpbnQgMTAwMAoJKgoJZnJhbWVfZGlnIDggLy8gcGF5b3V0RGF5c0luU2VjczogdWludDY0CgkvCglmcmFtZV9idXJ5IDE1IC8vIHRpbWVQZXJjZW50YWdlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyOTMKCS8vIHN0YWtlclJld2FyZCA9IHdpZGVSYXRpbygKCS8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3Rha2VyLkJhbGFuY2UsIHJld2FyZEF2YWlsYWJsZSwgdGltZVBlcmNlbnRhZ2VdLAoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSAvIDEwMDBdCgkvLyAgICAgICAgICAgICAgICAgICAgICAgICApCglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJZnJhbWVfZGlnIDUgLy8gcmV3YXJkQXZhaWxhYmxlOiB1aW50NjQKCW11bHcKCWZyYW1lX2RpZyAxNSAvLyB0aW1lUGVyY2VudGFnZTogdWludDY0Cgl1bmNvdmVyIDIKCWRpZyAxCgkqCgljb3ZlciAyCgltdWx3Cgljb3ZlciAyCgkrCglzd2FwCglpbnQgMAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWludCAxMDAwCgkvCglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoJYXNzZXJ0CglmcmFtZV9idXJ5IDE2IC8vIHN0YWtlclJld2FyZDogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6Mjk5CgkvLyByZXdhcmRBdmFpbGFibGUgLT0gc3Rha2VyUmV3YXJkCglmcmFtZV9kaWcgNSAvLyByZXdhcmRBdmFpbGFibGU6IHVpbnQ2NAoJZnJhbWVfZGlnIDE2IC8vIHN0YWtlclJld2FyZDogdWludDY0CgktCglmcmFtZV9idXJ5IDUgLy8gcmV3YXJkQXZhaWxhYmxlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMDIKCS8vIHN0YWtlci5CYWxhbmNlICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgMzIgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyAxNiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMDMKCS8vIHN0YWtlci5Ub3RhbFJld2FyZGVkICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgNDAgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQwIDgKCWJ0b2kKCWZyYW1lX2RpZyAxNiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMDYKCS8vIHRoaXMuU3Rha2Vycy52YWx1ZVtpXSA9IHN0YWtlcgoJZnJhbWVfZGlnIDEwIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWZyYW1lX2RpZyAxMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCmlmMTBfZW5kOgoKaWY5X2VuZDoKCmlmOF9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMTAKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDEwIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMTAgLy8gaTogdWludDY0CgoJLy8gaW5jcmVtZW50IG9mZnNldCBhbmQgbG9vcCBpZiBub3Qgb3V0IG9mIGJvdW5kcwoJZnJhbWVfZGlnIDEzIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCglpbnQgNTYKCSsKCWR1cAoJaW50IDQwODggLy8gb2Zmc2V0IG9mIGxhc3QgZWxlbWVudAoJPAoJYnogZm9yRWFjaF8xX2VuZAoJZnJhbWVfYnVyeSAxMyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJZnJhbWVfZGlnIDExIC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZnJhbWVfZGlnIDEzIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCglpbnQgNTYKCWV4dHJhY3QKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWIgZm9yRWFjaF8xCgpmb3JFYWNoXzFfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzE1CgkvLyBuZXdQb29sVG90YWxTdGFrZSA9IHRoaXMuVG90YWxBbGdvU3Rha2VkLnZhbHVlIC0gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMTcgLy8gbmV3UG9vbFRvdGFsU3Rha2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjMxNwoJLy8gaSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDEwIC8vIGk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjMxOAoJLy8gdGhpcy5TdGFrZXJzLnZhbHVlCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCglib3hfZ2V0Cglhc3NlcnQKCWR1cAoJZnJhbWVfYnVyeSAxOCAvLyBjb3B5IG9mIHRoZSBhcnJheSB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIKCWV4dHJhY3QgMCA1NgoJZnJhbWVfYnVyeSAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50IDAKCWZyYW1lX2J1cnkgMjAgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCmZvckVhY2hfMjoKCS8vIGlmMTFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMTkKCS8vIHN0YWtlci5BY2NvdW50ICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzICYmIHN0YWtlci5FbnRyeVRpbWUgPCBjdXJUaW1lCglmcmFtZV9kaWcgMTkgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCAzMgoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJZHVwCglieiBza2lwX2FuZDAKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0OCA4CglidG9pCglmcmFtZV9kaWcgNyAvLyBjdXJUaW1lOiB1aW50NjQKCTwKCSYmCgpza2lwX2FuZDA6CglieiBpZjExX2VuZAoKCS8vIGlmMTFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzIwCgkvLyB0aW1lSW5Qb29sID0gY3VyVGltZSAtIHN0YWtlci5FbnRyeVRpbWUKCWZyYW1lX2RpZyA3IC8vIGN1clRpbWU6IHVpbnQ2NAoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQ4IDgKCWJ0b2kKCS0KCWZyYW1lX2J1cnkgMjEgLy8gdGltZUluUG9vbDogdWludDY0CgoJLy8gaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjMyMgoJLy8gdGltZUluUG9vbCA8IHBheW91dERheXNJblNlY3MKCWZyYW1lX2RpZyAyMSAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCWZyYW1lX2RpZyA4IC8vIHBheW91dERheXNJblNlY3M6IHVpbnQ2NAoJPAoJYnogaWYxMl9lbmQKCgkvLyBpZjEyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjMyMwoJLy8gcmV0dXJuOwoJYiBmb3JFYWNoXzJfZW5kCgppZjEyX2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjMyNwoJLy8gc3Rha2VyUmV3YXJkID0gd2lkZVJhdGlvKFtzdGFrZXIuQmFsYW5jZSwgcmV3YXJkQXZhaWxhYmxlXSwgW25ld1Bvb2xUb3RhbFN0YWtlXSkKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgNSAvLyByZXdhcmRBdmFpbGFibGU6IHVpbnQ2NAoJbXVsdwoJaW50IDAKCWZyYW1lX2RpZyAxNyAvLyBuZXdQb29sVG90YWxTdGFrZTogdWludDY0CglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoJYXNzZXJ0CglmcmFtZV9idXJ5IDIyIC8vIHN0YWtlclJld2FyZDogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzMwCgkvLyBzdGFrZXIuQmFsYW5jZSArPSBzdGFrZXJSZXdhcmQKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50IDMyIC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglmcmFtZV9kaWcgMjIgLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCSsKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzMxCgkvLyBzdGFrZXIuVG90YWxSZXdhcmRlZCArPSBzdGFrZXJSZXdhcmQKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50IDQwIC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA0MCA4CglidG9pCglmcmFtZV9kaWcgMjIgLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCSsKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzM0CgkvLyB0aGlzLlN0YWtlcnMudmFsdWVbaV0gPSBzdGFrZXIKCWZyYW1lX2RpZyAxMCAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgMTkgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWJ5dGUgMHg3Mzc0NjE2YjY1NzI3MyAvLyAic3Rha2VycyIKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgppZjExX2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjMzNgoJLy8gaSArPSAxCglmcmFtZV9kaWcgMTAgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAxMCAvLyBpOiB1aW50NjQKCgkvLyBpbmNyZW1lbnQgb2Zmc2V0IGFuZCBsb29wIGlmIG5vdCBvdXQgb2YgYm91bmRzCglmcmFtZV9kaWcgMjAgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludCA1NgoJKwoJZHVwCglpbnQgNDA4OCAvLyBvZmZzZXQgb2YgbGFzdCBlbGVtZW50Cgk8CglieiBmb3JFYWNoXzJfZW5kCglmcmFtZV9idXJ5IDIwIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCglmcmFtZV9kaWcgMTggLy8gY29weSBvZiB0aGUgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyCglmcmFtZV9kaWcgMjAgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludCA1NgoJZXh0cmFjdAoJZnJhbWVfYnVyeSAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYiBmb3JFYWNoXzIKCmZvckVhY2hfMl9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNDEKCS8vIGluY3JlYXNlZFN0YWtlID0gdGhpcy5hcHAuYWRkcmVzcy5iYWxhbmNlIC0gdGhpcy5Ub3RhbEFsZ29TdGFrZWQudmFsdWUgLSB0aGlzLmFwcC5hZGRyZXNzLm1pbkJhbGFuY2UKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKCXBvcAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCS0KCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJLQoJZnJhbWVfYnVyeSAyMyAvLyBpbmNyZWFzZWRTdGFrZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzQyCgkvLyB0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBpbmNyZWFzZWRTdGFrZQoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAyMyAvLyBpbmNyZWFzZWRTdGFrZTogdWludDY0CgkrCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM0NwoJLy8gc2VuZE1ldGhvZENhbGw8W1t1aW50NjQsIHVpbnQ2NCwgdWludDY0XSwgdWludDY0XSwgdm9pZD4oewoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwbGljYXRpb24uZnJvbUlEKHRoaXMuQ3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElELnZhbHVlKSwKCS8vICAgICAgICAgICAgIG5hbWU6ICdzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzJywKCS8vICAgICAgICAgICAgIG1ldGhvZEFyZ3M6IFtbdGhpcy5WYWxpZGF0b3JJRC52YWx1ZSwgdGhpcy5Qb29sSUQudmFsdWUsIHRoaXMuYXBwLmlkXSwgaW5jcmVhc2VkU3Rha2VdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCW1ldGhvZCAic3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCx1aW50NjQpLHVpbnQ2NCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNDgKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLkNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJRC52YWx1ZSkKCWJ5dGUgMHg2MzcyNjU2MTc0NmY3MjQxNzA3MCAvLyAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNTAKCS8vIG1ldGhvZEFyZ3M6IFtbdGhpcy5WYWxpZGF0b3JJRC52YWx1ZSwgdGhpcy5Qb29sSUQudmFsdWUsIHRoaXMuYXBwLmlkXSwgaW5jcmVhc2VkU3Rha2VdCglieXRlIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyNDk0NCAvLyAidmFsaWRhdG9ySUQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJYnl0ZSAweDcwNmY2ZjZjNDk0NCAvLyAicG9vbElEIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWNvbmNhdAoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDIzIC8vIGluY3JlYXNlZFN0YWtlOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBnb09ubGluZShieXRlW10sYnl0ZVtdLGJ5dGVbXSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCmFiaV9yb3V0ZV9nb09ubGluZToKCS8vIHZvdGVLZXlEaWx1dGlvbjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglidG9pCgoJLy8gdm90ZUxhc3Q6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIHZvdGVGaXJzdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gc3RhdGVQcm9vZlBLOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gc2VsZWN0aW9uUEs6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyB2b3RlUEs6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGdvT25saW5lKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgZ29PbmxpbmUKCWludCAxCglyZXR1cm4KCi8vIGdvT25saW5lKHZvdGVQSzogYnl0ZXMsIHNlbGVjdGlvblBLOiBieXRlcywgc3RhdGVQcm9vZlBLOiBieXRlcywgdm90ZUZpcnN0OiB1aW50NjQsIHZvdGVMYXN0OiB1aW50NjQsIHZvdGVLZXlEaWx1dGlvbjogdWludDY0KTogdm9pZApnb09ubGluZToKCXByb3RvIDYgMAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM2MgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy5Pd25lci52YWx1ZSB8fCB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuTWFuYWdlci52YWx1ZSkKCXR4biBTZW5kZXIKCWJ5dGUgMHg2Zjc3NmU2NTcyIC8vICJvd25lciIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJZHVwCglibnogc2tpcF9vcjIKCXR4biBTZW5kZXIKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJfHwKCnNraXBfb3IyOgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzYzCgkvLyBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKHsKCS8vICAgICAgICAgICAgIHZvdGVQSzogdm90ZVBLLAoJLy8gICAgICAgICAgICAgc2VsZWN0aW9uUEs6IHNlbGVjdGlvblBLLAoJLy8gICAgICAgICAgICAgc3RhdGVQcm9vZlBLOiBzdGF0ZVByb29mUEssCgkvLyAgICAgICAgICAgICB2b3RlRmlyc3Q6IHZvdGVGaXJzdCwKCS8vICAgICAgICAgICAgIHZvdGVMYXN0OiB2b3RlTGFzdCwKCS8vICAgICAgICAgICAgIHZvdGVLZXlEaWx1dGlvbjogdm90ZUtleURpbHV0aW9uLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGtleXJlZwoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM2NAoJLy8gdm90ZVBLOiB2b3RlUEsKCWZyYW1lX2RpZyAtMSAvLyB2b3RlUEs6IGJ5dGVzCglpdHhuX2ZpZWxkIFZvdGVQSwoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM2NQoJLy8gc2VsZWN0aW9uUEs6IHNlbGVjdGlvblBLCglmcmFtZV9kaWcgLTIgLy8gc2VsZWN0aW9uUEs6IGJ5dGVzCglpdHhuX2ZpZWxkIFNlbGVjdGlvblBLCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzY2CgkvLyBzdGF0ZVByb29mUEs6IHN0YXRlUHJvb2ZQSwoJZnJhbWVfZGlnIC0zIC8vIHN0YXRlUHJvb2ZQSzogYnl0ZXMKCWl0eG5fZmllbGQgU3RhdGVQcm9vZlBLCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzY3CgkvLyB2b3RlRmlyc3Q6IHZvdGVGaXJzdAoJZnJhbWVfZGlnIC00IC8vIHZvdGVGaXJzdDogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVGaXJzdAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM2OAoJLy8gdm90ZUxhc3Q6IHZvdGVMYXN0CglmcmFtZV9kaWcgLTUgLy8gdm90ZUxhc3Q6IHVpbnQ2NAoJaXR4bl9maWVsZCBWb3RlTGFzdAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM2OQoJLy8gdm90ZUtleURpbHV0aW9uOiB2b3RlS2V5RGlsdXRpb24KCWZyYW1lX2RpZyAtNiAvLyB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NAoJaXR4bl9maWVsZCBWb3RlS2V5RGlsdXRpb24KCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGdvT2ZmbGluZSgpdm9pZAphYmlfcm91dGVfZ29PZmZsaW5lOgoJLy8gZXhlY3V0ZSBnb09mZmxpbmUoKXZvaWQKCWNhbGxzdWIgZ29PZmZsaW5lCglpbnQgMQoJcmV0dXJuCgovLyBnb09mZmxpbmUoKTogdm9pZApnb09mZmxpbmU6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNzQKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuT3duZXIudmFsdWUgfHwgdGhpcy50eG4uc2VuZGVyID09PSB0aGlzLk1hbmFnZXIudmFsdWUpCgl0eG4gU2VuZGVyCglieXRlIDB4NmY3NzZlNjU3MiAvLyAib3duZXIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWR1cAoJYm56IHNraXBfb3IzCgl0eG4gU2VuZGVyCglieXRlIDB4NmQ2MTZlNjE2NzY1NzIgLy8gIm1hbmFnZXIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCXx8Cgpza2lwX29yMzoKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM3NQoJLy8gc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oe30pCglpdHhuX2JlZ2luCglpbnQga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBnZXRFbnRyeVRpbWUoKTogdWludDY0Ci8vCi8vIENhbGN1bGF0ZSB0aGUgZW50cnkgdGltZSBmb3IgY291bnRpbmcgYSBzdGFrZSBhcyBlbnRlcmluZyB0aGUgcG9vbC4KLy8gQWxnb3JhbmQgd29uJ3Qgc2VlIHRoZSBiYWxhbmNlIGluY3JlYXNlIGZvciBBTEdPUkFORF9TVEFLSU5HX0JMT0NLX0RFTEFZIHJvdW5kcywgc28gd2UgYXBwcm94aW1hdGUgaXQuCi8vIFRoZSBlbnRyeSB0aW1lIGlzIGNhbGN1bGF0ZWQgYnkgYWRkaW5nIGFuIGFwcHJveGltYXRlIG51bWJlciBvZiBzZWNvbmRzIGJhc2VkIG9uIGN1cnJlbnQgQVZHIGJsb2NrIHRpbWVzCi8vIHRvIHRoZSBvcmlnaW5hbCBlbnRyeSB0aW1lLiAgVGhpcyBtZWFucyB1c2VycyBkb24ndCBnZXQgcGF5b3V0cyBiYXNlZCBvbiB0aW1lIHRoZWlyIGJhbGFuY2Ugd291bGRuJ3QgaGF2ZQovLyBiZWVuIHNlZW4gYnkgdGhlIG5ldHdvcmsuCi8vCi8vIEByZXR1cm5zIHt1aW50NjR9IC0gVGhlIHVwZGF0ZWQgZW50cnkgdGltZS4KZ2V0RW50cnlUaW1lOgoJcHJvdG8gMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozOTAKCS8vIGVudHJ5VGltZSA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9idXJ5IDAgLy8gZW50cnlUaW1lOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozOTMKCS8vIHJldHVybiBlbnRyeVRpbWUgKyAoQUxHT1JBTkRfU1RBS0lOR19CTE9DS19ERUxBWSAqIEFWR19CTE9DS19USU1FX1NFQ1MpIC8gMTA7CglmcmFtZV9kaWcgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoJaW50IDk2MAoJKwoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgpjcmVhdGVfTm9PcDoKCW1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxhZGRyZXNzKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCBhYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCWVycgoKY2FsbF9Ob09wOgoJbWV0aG9kICJnYXMoKXZvaWQiCgltZXRob2QgImFkZFN0YWtlKHBheSxhZGRyZXNzKXVpbnQ2NCIKCW1ldGhvZCAicmVtb3ZlU3Rha2UoYWRkcmVzcyx1aW50NjQpdm9pZCIKCW1ldGhvZCAicGF5U3Rha2Vycygpdm9pZCIKCW1ldGhvZCAiZ29PbmxpbmUoYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAiZ29PZmZsaW5lKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggYWJpX3JvdXRlX2dhcyBhYmlfcm91dGVfYWRkU3Rha2UgYWJpX3JvdXRlX3JlbW92ZVN0YWtlIGFiaV9yb3V0ZV9wYXlTdGFrZXJzIGFiaV9yb3V0ZV9nb09ubGluZSBhYmlfcm91dGVfZ29PZmZsaW5lCgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDk="
  },
  "contract": {
    "name": "StakingPool",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "desc": "Initialize the staking pool w/ owner and manager, but can only be created by the validator contract.",
        "args": [
          {
            "name": "creatingContractID",
            "type": "uint64",
            "desc": "id of contract that constructed us - the validator application (single global instance)"
          },
          {
            "name": "validatorID",
            "type": "uint64",
            "desc": "id of validator we're a staking pool of"
          },
          {
            "name": "poolID",
            "type": "uint64",
            "desc": "which pool id are we"
          },
          {
            "name": "owner",
            "type": "address"
          },
          {
            "name": "manager",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "gas",
        "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "addStake",
        "desc": "Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.",
        "args": [
          {
            "name": "stakedAmountPayment",
            "type": "pay",
            "desc": "prior payment coming from validator contract to us on behalf of staker."
          },
          {
            "name": "staker",
            "type": "address",
            "desc": "The account adding new stake"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "{uint64}new 'entry time' in seconds of stake add."
        }
      },
      {
        "name": "removeStake",
        "desc": "Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidaotr of the staker / balance changes.",
        "args": [
          {
            "name": "account",
            "type": "address",
            "desc": "The address of the account removing stake."
          },
          {
            "name": "amountToUnstake",
            "type": "uint64",
            "desc": "The amount of stake to be removed."
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "payStakers",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "goOnline",
        "args": [
          {
            "name": "votePK",
            "type": "byte[]"
          },
          {
            "name": "selectionPK",
            "type": "byte[]"
          },
          {
            "name": "stateProofPK",
            "type": "byte[]"
          },
          {
            "name": "voteFirst",
            "type": "uint64"
          },
          {
            "name": "voteLast",
            "type": "uint64"
          },
          {
            "name": "voteKeyDilution",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "goOffline",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the StakingPool smart contract.
 */
export type StakingPool = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(uint64,uint64,uint64,address,address)void' | 'createApplication', {
      argsObj: {
        /**
         * id of contract that constructed us - the validator application (single global instance)
         */
        creatingContractID: bigint | number
        /**
         * id of validator we're a staking pool of
         */
        validatorID: bigint | number
        /**
         * which pool id are we
         */
        poolID: bigint | number
        owner: string
        manager: string
      }
      argsTuple: [creatingContractID: bigint | number, validatorID: bigint | number, poolID: bigint | number, owner: string, manager: string]
      returns: void
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'addStake(pay,address)uint64' | 'addStake', {
      argsObj: {
        /**
         * prior payment coming from validator contract to us on behalf of staker.
         */
        stakedAmountPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * The account adding new stake
         */
        staker: string
      }
      argsTuple: [stakedAmountPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>, staker: string]
      /**
       * {uint64}new 'entry time' in seconds of stake add.
       */
      returns: bigint
    }>
    & Record<'removeStake(address,uint64)void' | 'removeStake', {
      argsObj: {
        /**
         * The address of the account removing stake.
         */
        account: string
        /**
         * The amount of stake to be removed.
         */
        amountToUnstake: bigint | number
      }
      argsTuple: [account: string, amountToUnstake: bigint | number]
      returns: void
    }>
    & Record<'payStakers()void' | 'payStakers', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void' | 'goOnline', {
      argsObj: {
        votePK: Uint8Array
        selectionPK: Uint8Array
        stateProofPK: Uint8Array
        voteFirst: bigint | number
        voteLast: bigint | number
        voteKeyDilution: bigint | number
      }
      argsTuple: [votePK: Uint8Array, selectionPK: Uint8Array, stateProofPK: Uint8Array, voteFirst: bigint | number, voteLast: bigint | number, voteKeyDilution: bigint | number]
      returns: void
    }>
    & Record<'goOffline()void' | 'goOffline', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'creatorApp'?: IntegerState
      'validatorID'?: IntegerState
      'poolID'?: IntegerState
      'owner'?: BinaryState
      'manager'?: BinaryState
      'numStakers'?: IntegerState
      'staked'?: IntegerState
      'maxStake'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type StakingPoolSig = keyof StakingPool['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends StakingPoolSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the StakingPool smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends StakingPoolSig> = StakingPool['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the StakingPool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingPoolSig> = StakingPool['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type StakingPoolCreateCalls = (typeof StakingPoolCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type StakingPoolCreateCallParams =
  | (TypedCallParams<'createApplication(uint64,uint64,uint64,address,address)void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type StakingPoolDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: StakingPoolCreateCalls) => StakingPoolCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class StakingPoolCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the StakingPool smart contract using the createApplication(uint64,uint64,uint64,address,address)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication(uint64,uint64,uint64,address,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication(uint64,uint64,uint64,address,address)void' as const,
          methodArgs: Array.isArray(args) ? args : [args.creatingContractID, args.validatorID, args.poolID, args.owner, args.manager],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'gas()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addStake(pay,address)uint64 ABI method
   *
   * Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addStake(pay,address)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.stakedAmountPayment, args.staker],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the removeStake(address,uint64)void ABI method
   *
   * Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidaotr of the staker / balance changes.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'removeStake(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.account, args.amountToUnstake],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the payStakers()void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static payStakers(args: MethodArgs<'payStakers()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'payStakers()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.votePK, args.selectionPK, args.stateProofPK, args.voteFirst, args.voteLast, args.voteKeyDilution],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the goOffline()void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static goOffline(args: MethodArgs<'goOffline()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'goOffline()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
}

/**
 * A client to make calls to the StakingPool smart contract
 */
export class StakingPoolClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `StakingPoolClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof StakingPool['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the StakingPool smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: StakingPoolDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(StakingPoolCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the StakingPool smart contract using the createApplication(uint64,uint64,uint64,address,address)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication(uint64,uint64,uint64,address,address)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication(uint64,uint64,uint64,address,address)void'>, AppCreateCallTransactionResult>(await $this.appClient.create(StakingPoolCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the StakingPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.gas(args, params))
  }

  /**
   * Calls the addStake(pay,address)uint64 ABI method.
   *
   * Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: {uint64}new 'entry time' in seconds of stake add.
   */
  public addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.addStake(args, params))
  }

  /**
   * Calls the removeStake(address,uint64)void ABI method.
   *
   * Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidaotr of the staker / balance changes.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.removeStake(args, params))
  }

  /**
   * Calls the payStakers()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public payStakers(args: MethodArgs<'payStakers()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.payStakers(args, params))
  }

  /**
   * Calls the goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.goOnline(args, params))
  }

  /**
   * Calls the goOffline()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public goOffline(args: MethodArgs<'goOffline()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.goOffline(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<StakingPool['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get creatorApp() {
        return StakingPoolClient.getIntegerState(state, 'creatorApp')
      },
      get validatorID() {
        return StakingPoolClient.getIntegerState(state, 'validatorID')
      },
      get poolID() {
        return StakingPoolClient.getIntegerState(state, 'poolID')
      },
      get owner() {
        return StakingPoolClient.getBinaryState(state, 'owner')
      },
      get manager() {
        return StakingPoolClient.getBinaryState(state, 'manager')
      },
      get numStakers() {
        return StakingPoolClient.getIntegerState(state, 'numStakers')
      },
      get staked() {
        return StakingPoolClient.getIntegerState(state, 'staked')
      },
      get maxStake() {
        return StakingPoolClient.getIntegerState(state, 'maxStake')
      },
    }
  }

  public compose(): StakingPoolComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      gas(args: MethodArgs<'gas()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.gas(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addStake(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.removeStake(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      payStakers(args: MethodArgs<'payStakers()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.payStakers(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.goOnline(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      goOffline(args: MethodArgs<'goOffline()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.goOffline(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as StakingPoolComposer
  }
}
export type StakingPoolComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(args: MethodArgs<'gas()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'gas()void'>]>

  /**
   * Calls the addStake(pay,address)uint64 ABI method.
   *
   * Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'addStake(pay,address)uint64'>]>

  /**
   * Calls the removeStake(address,uint64)void ABI method.
   *
   * Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidaotr of the staker / balance changes.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'removeStake(address,uint64)void'>]>

  /**
   * Calls the payStakers()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  payStakers(args: MethodArgs<'payStakers()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'payStakers()void'>]>

  /**
   * Calls the goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>]>

  /**
   * Calls the goOffline()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  goOffline(args: MethodArgs<'goOffline()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'goOffline()void'>]>

  /**
   * Makes a clear_state call to an existing instance of the StakingPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): StakingPoolComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<StakingPoolComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<StakingPoolComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type StakingPoolComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type StakingPoolComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
