/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addStake(pay,address)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "removeStake(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "payStakers()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "goOffline()void": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "CreatingValidatorContractAppID": {
          "type": "uint64",
          "key": "creatorApp"
        },
        "ValidatorID": {
          "type": "uint64",
          "key": "validatorID"
        },
        "PoolID": {
          "type": "uint64",
          "key": "poolID"
        },
        "Owner": {
          "type": "bytes",
          "key": "owner"
        },
        "Manager": {
          "type": "bytes",
          "key": "manager"
        },
        "NumStakers": {
          "type": "uint64",
          "key": "numStakers"
        },
        "TotalAlgoStaked": {
          "type": "uint64",
          "key": "staked"
        },
        "MinAllowedStake": {
          "type": "uint64",
          "key": "minAllowedStake"
        },
        "MaxStakeAllowed": {
          "type": "uint64",
          "key": "maxStake"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 2,
      "num_uints": 7
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDkKCi8vIFRoaXMgVEVBTCB3YXMgZ2VuZXJhdGVkIGJ5IFRFQUxTY3JpcHQgdjAuODIuMQovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCBjYWxsX05vT3AgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBjcmVhdGVfTm9PcCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVECgpOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDY0KXZvaWQKYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uOgoJLy8gbWF4U3Rha2VBbGxvd2VkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDcKCWJ0b2kKCgkvLyBtaW5BbGxvd2VkU3Rha2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJYnRvaQoKCS8vIG1hbmFnZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBvd25lcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHBvb2xJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGNyZWF0aW5nQ29udHJhY3RJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbihjcmVhdGluZ0NvbnRyYWN0SUQ6IHVpbnQ2NCwgdmFsaWRhdG9ySUQ6IHVpbnQ2NCwgcG9vbElEOiB1aW50NjQsIG93bmVyOiBBZGRyZXNzLCBtYW5hZ2VyOiBBZGRyZXNzLCBtaW5BbGxvd2VkU3Rha2U6IHVpbnQ2NCwgbWF4U3Rha2VBbGxvd2VkOiB1aW50NjQpOiB2b2lkCi8vCi8vIEluaXRpYWxpemUgdGhlIHN0YWtpbmcgcG9vbCB3LyBvd25lciBhbmQgbWFuYWdlciwgYnV0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgYnkgdGhlIHZhbGlkYXRvciBjb250cmFjdC4KLy8gQHBhcmFtIGNyZWF0aW5nQ29udHJhY3RJRCAtIGlkIG9mIGNvbnRyYWN0IHRoYXQgY29uc3RydWN0ZWQgdXMgLSB0aGUgdmFsaWRhdG9yIGFwcGxpY2F0aW9uIChzaW5nbGUgZ2xvYmFsIGluc3RhbmNlKQovLyBAcGFyYW0gdmFsaWRhdG9ySUQgLSBpZCBvZiB2YWxpZGF0b3Igd2UncmUgYSBzdGFraW5nIHBvb2wgb2YKLy8gQHBhcmFtIHBvb2xJRCAtIHdoaWNoIHBvb2wgaWQgYXJlIHdlCi8vIEBwYXJhbSBvd25lciAtIG93bmVyIG9mIHBvb2wKLy8gQHBhcmFtIG1hbmFnZXIgLSBtYW5hZ2VyIG9mIHBvb2wgKGNhbiBpc3N1ZSBwYXlvdXRzIGFuZCBvbmxpbmUgdHhucykKLy8gQHBhcmFtIG1pbkFsbG93ZWRTdGFrZSAtIG1pbmltdW0gYW1vdW50IHRvIGJlIGluIHBvb2wsIGJ1dCBhbHNvIG1pbmltdW0gYW1vdW50IGJhbGFuY2UgY2FuJ3QgZ28gYmVsb3cgKHdpdGhvdXQgcmVtb3ZpbmcgYWxsISkKLy8gQHBhcmFtIG1heFN0YWtlQWxsb3dlZCAtIG1heGltdW0gYWxnbyBhbGxvd2VkIGluIHRoaXMgc3Rha2luZyBwb29sCmNyZWF0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gNyAwCgoJLy8gaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NTkKCS8vIG93bmVyID09PSBnbG9iYWxzLnplcm9BZGRyZXNzIHx8IG1hbmFnZXIgPT09IGdsb2JhbHMuemVyb0FkZHJlc3MKCWZyYW1lX2RpZyAtNCAvLyBvd25lcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgk9PQoJZHVwCglibnogc2tpcF9vcjAKCWZyYW1lX2RpZyAtNSAvLyBtYW5hZ2VyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cgl8fAoKc2tpcF9vcjA6CglieiBpZjBfZWxzZQoKCS8vIGlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2MQoJLy8gYXNzZXJ0KG93bmVyID09PSBnbG9iYWxzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC00IC8vIG93bmVyOiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2MgoJLy8gYXNzZXJ0KG1hbmFnZXIgPT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTUgLy8gbWFuYWdlcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NjMKCS8vIGFzc2VydChjcmVhdGluZ0NvbnRyYWN0SUQgPT09IDApCglmcmFtZV9kaWcgLTEgLy8gY3JlYXRpbmdDb250cmFjdElEOiB1aW50NjQKCWludCAwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NjQKCS8vIGFzc2VydCh2YWxpZGF0b3JJRCA9PT0gMCkKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJRDogdWludDY0CglpbnQgMAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjY1CgkvLyBhc3NlcnQocG9vbElEID09PSAwKQoJZnJhbWVfZGlnIC0zIC8vIHBvb2xJRDogdWludDY0CglpbnQgMAoJPT0KCWFzc2VydAoJYiBpZjBfZW5kCgppZjBfZWxzZToKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjY3CgkvLyBhc3NlcnQoY3JlYXRpbmdDb250cmFjdElEICE9PSAwKQoJZnJhbWVfZGlnIC0xIC8vIGNyZWF0aW5nQ29udHJhY3RJRDogdWludDY0CglpbnQgMAoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjY4CgkvLyBhc3NlcnQodmFsaWRhdG9ySUQgIT09IDApCglmcmFtZV9kaWcgLTIgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo2OQoJLy8gYXNzZXJ0KHBvb2xJRCAhPT0gMCkKCWZyYW1lX2RpZyAtMyAvLyBwb29sSUQ6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCmlmMF9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo3MQoJLy8gYXNzZXJ0KG1pbkFsbG93ZWRTdGFrZSA+PSBNSU5fQUxHT19TVEFLRV9QRVJfUE9PTCkKCWZyYW1lX2RpZyAtNiAvLyBtaW5BbGxvd2VkU3Rha2U6IHVpbnQ2NAoJaW50IDEwMDAwMDAKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo3MgoJLy8gYXNzZXJ0KG1heFN0YWtlQWxsb3dlZCA8IE1BWF9BTEdPX1BFUl9QT09MKQoJZnJhbWVfZGlnIC03IC8vIG1heFN0YWtlQWxsb3dlZDogdWludDY0CglpbnQgMjAwMDAwMDAwMDAwMDAKCTwKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjczCgkvLyB0aGlzLkNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJRC52YWx1ZSA9IGNyZWF0aW5nQ29udHJhY3RJRAoJYnl0ZSAweDYzNzI2NTYxNzQ2ZjcyNDE3MDcwIC8vICJjcmVhdG9yQXBwIgoJZnJhbWVfZGlnIC0xIC8vIGNyZWF0aW5nQ29udHJhY3RJRDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjc0CgkvLyB0aGlzLlZhbGlkYXRvcklELnZhbHVlID0gdmFsaWRhdG9ySUQKCWJ5dGUgMHg3NjYxNmM2OTY0NjE3NDZmNzI0OTQ0IC8vICJ2YWxpZGF0b3JJRCIKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJRDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjc1CgkvLyB0aGlzLlBvb2xJRC52YWx1ZSA9IHBvb2xJRAoJYnl0ZSAweDcwNmY2ZjZjNDk0NCAvLyAicG9vbElEIgoJZnJhbWVfZGlnIC0zIC8vIHBvb2xJRDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjc2CgkvLyB0aGlzLk93bmVyLnZhbHVlID0gb3duZXIKCWJ5dGUgMHg2Zjc3NmU2NTcyIC8vICJvd25lciIKCWZyYW1lX2RpZyAtNCAvLyBvd25lcjogQWRkcmVzcwoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czo3NwoJLy8gdGhpcy5NYW5hZ2VyLnZhbHVlID0gbWFuYWdlcgoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJZnJhbWVfZGlnIC01IC8vIG1hbmFnZXI6IEFkZHJlc3MKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NzgKCS8vIHRoaXMuTnVtU3Rha2Vycy52YWx1ZSA9IDAKCWJ5dGUgMHg2ZTc1NmQ1Mzc0NjE2YjY1NzI3MyAvLyAibnVtU3Rha2VycyIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjc5CgkvLyB0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSA9IDAKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCWludCAwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjgwCgkvLyB0aGlzLk1pbkFsbG93ZWRTdGFrZS52YWx1ZSA9IG1pbkFsbG93ZWRTdGFrZQoJYnl0ZSAweDZkNjk2ZTQxNmM2YzZmNzc2NTY0NTM3NDYxNmI2NSAvLyAibWluQWxsb3dlZFN0YWtlIgoJZnJhbWVfZGlnIC02IC8vIG1pbkFsbG93ZWRTdGFrZTogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjgxCgkvLyB0aGlzLk1heFN0YWtlQWxsb3dlZC52YWx1ZSA9IG1heFN0YWtlQWxsb3dlZAoJYnl0ZSAweDZkNjE3ODUzNzQ2MTZiNjUgLy8gIm1heFN0YWtlIgoJZnJhbWVfZGlnIC03IC8vIG1heFN0YWtlQWxsb3dlZDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBnYXMoKXZvaWQKYWJpX3JvdXRlX2dhczoKCS8vIGV4ZWN1dGUgZ2FzKCl2b2lkCgljYWxsc3ViIGdhcwoJaW50IDEKCXJldHVybgoKLy8gZ2FzKCk6IHZvaWQKLy8KLy8gZ2FzIGlzIGEgZHVtbXkgbm8tb3AgY2FsbCB0aGF0IGNhbiBiZSB1c2VkIHRvIHBvb2wtdXAgcmVzb3VyY2UgcmVmZXJlbmNlcyBhbmQgb3Bjb2RlIGNvc3QKZ2FzOgoJcHJvdG8gMCAwCglyZXRzdWIKCi8vIGFkZFN0YWtlKHBheSxhZGRyZXNzKXVpbnQ2NAphYmlfcm91dGVfYWRkU3Rha2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhZGRTdGFrZShwYXksYWRkcmVzcyl1aW50NjQKCWNhbGxzdWIgYWRkU3Rha2UKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhZGRTdGFrZShzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4sIHN0YWtlcjogQWRkcmVzcyk6IHVpbnQ2NAovLwovLyBBZGRzIHN0YWtlIHRvIHRoZSBnaXZlbiBhY2NvdW50LgovLyBDYW4gT05MWSBiZSBjYWxsZWQgYnkgdGhlIHZhbGlkYXRvciBjb250cmFjdCB0aGF0IGNyZWF0ZWQgdXMKLy8gTXVzdCByZWNlaXZlIHBheW1lbnQgZnJvbSB0aGUgdmFsaWRhdG9yIGNvbnRyYWN0IGZvciBhbW91bnQgYmVpbmcgc3Rha2VkLgovLwovLyBAcGFyYW0ge1BheVR4bn0gc3Rha2VkQW1vdW50UGF5bWVudCBwcmlvciBwYXltZW50IGNvbWluZyBmcm9tIHZhbGlkYXRvciBjb250cmFjdCB0byB1cyBvbiBiZWhhbGYgb2Ygc3Rha2VyLgovLyBAcGFyYW0ge0FkZHJlc3N9IHN0YWtlciAtIFRoZSBhY2NvdW50IGFkZGluZyBuZXcgc3Rha2UKLy8gQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzdGFraW5nIHBvb2wgaXMgZnVsbC4KLy8gQHJldHVybnMge3VpbnQ2NH0gbmV3ICdlbnRyeSB0aW1lJyBpbiBzZWNvbmRzIG9mIHN0YWtlIGFkZC4KYWRkU3Rha2U6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAzCgoJLy8gaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTAwCgkvLyAhdGhpcy5TdGFrZXJzLmV4aXN0cwoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiBpZjFfZW5kCgoJLy8gaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEwMQoJLy8gdGhpcy5TdGFrZXJzLmNyZWF0ZSgpCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCglpbnQgNDA4OAoJYm94X2NyZWF0ZQoJcG9wCgppZjFfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTA0CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUpLmFkZHJlc3MpCgl0eG4gU2VuZGVyCglieXRlIDB4NjM3MjY1NjE3NDZmNzI0MTcwNzAgLy8gImNyZWF0b3JBcHAiCglhcHBfZ2xvYmFsX2dldAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTA1CgkvLyBhc3NlcnQoc3Rha2VyICE9PSBBY2NvdW50Lnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTA5CgkvLyB2ZXJpZnlQYXlUeG4oc3Rha2VkQW1vdW50UGF5bWVudCwgewoJLy8gICAgICAgICAgICAgc2VuZGVyOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUpLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgIGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQsCgkvLyAgICAgICAgIH0pCgkvLyB2ZXJpZnkgc2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBTZW5kZXIKCWJ5dGUgMHg2MzcyNjU2MTc0NmY3MjQxNzA3MCAvLyAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTE0CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCArIHRoaXMuVG90YWxBbGdvU3Rha2VkLnZhbHVlIDwgdGhpcy5NYXhTdGFrZUFsbG93ZWQudmFsdWUsCgkvLyAgICAgICAgICAgICAnYWRkaW5nIHRoaXMgc3Rha2UgYW1vdW50IHdpbGwgZXhjZWVkIHRoZSBtYXggYWxsb3dlZCBpbiB0aGlzIHBvb2wnCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCSsKCWJ5dGUgMHg2ZDYxNzg1Mzc0NjE2YjY1IC8vICJtYXhTdGFrZSIKCWFwcF9nbG9iYWxfZ2V0Cgk8CgoJLy8gYWRkaW5nIHRoaXMgc3Rha2UgYW1vdW50IHdpbGwgZXhjZWVkIHRoZSBtYXggYWxsb3dlZCBpbiB0aGlzIHBvb2wKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEyMAoJLy8gZW50cnlUaW1lID0gdGhpcy5nZXRFbnRyeVRpbWUoKQoJY2FsbHN1YiBnZXRFbnRyeVRpbWUKCWZyYW1lX2J1cnkgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEyMQoJLy8gZmlyc3RFbXB0eSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDEgLy8gZmlyc3RFbXB0eTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTI0CgkvLyBzdGFrZXJzID0gY2xvbmUodGhpcy5TdGFrZXJzLnZhbHVlKQoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJYm94X2dldAoJYXNzZXJ0CglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyczogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpWzczXQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEyNQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFrZXJzLmxlbmd0aDsgaSArPSAxKQoJaW50IDAKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCmZvcl8wOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTI1CgkvLyBpIDwgc3Rha2Vycy5sZW5ndGgKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDczCgk8CglieiBmb3JfMF9lbmQKCgkvLyBpZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMjYKCS8vIHN0YWtlcnNbaV0uQWNjb3VudCA9PT0gc3Rha2VyCglmcmFtZV9kaWcgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMAoJKwoJaW50IDMyCglleHRyYWN0MwoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJPT0KCWJ6IGlmMl9lbmQKCgkvLyBpZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTI3CgkvLyBzdGFrZXJzW2ldLkJhbGFuY2UgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcnM6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KVs3M10KCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludCAzMiAvLyBoZWFkT2Zmc2V0CgkrCglmcmFtZV9kaWcgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMzIgLy8gaGVhZE9mZnNldAoJKwoJaW50IDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCSsKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyczogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpWzczXQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEyOAoJLy8gc3Rha2Vyc1tpXS5FbnRyeVRpbWUgPSBlbnRyeVRpbWUKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcnM6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KVs3M10KCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludCA0OCAvLyBoZWFkT2Zmc2V0CgkrCglmcmFtZV9kaWcgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTMwCgkvLyB0aGlzLlN0YWtlcnMudmFsdWVbaV0gPSBzdGFrZXJzW2ldCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgMiAvLyBzdGFrZXJzOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NClbNzNdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA1NgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgNTYKCWV4dHJhY3QzCglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjEzMQoJLy8gdGhpcy5Ub3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCSsKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTMyCgkvLyByZXR1cm4gZW50cnlUaW1lOwoJZnJhbWVfZGlnIDAgLy8gZW50cnlUaW1lOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAzCglyZXRzdWIKCmlmMl9lbmQ6CgkvLyBpZjNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMzQKCS8vIHN0YWtlcnNbaV0uQWNjb3VudCA9PT0gQWRkcmVzcy56ZXJvQWRkcmVzcwoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyczogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpWzczXQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgNTYKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50IDAKCSsKCWludCAzMgoJZXh0cmFjdDMKCWdsb2JhbCBaZXJvQWRkcmVzcwoJPT0KCWJ6IGlmM19lbmQKCgkvLyBpZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTM1CgkvLyBmaXJzdEVtcHR5ID0gaSArIDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCWIgZm9yXzBfZW5kCgppZjNfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTM4CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxMjUKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoJYiBmb3JfMAoKZm9yXzBfZW5kOgoJLy8gaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTQxCgkvLyBmaXJzdEVtcHR5ID09PSAwCglmcmFtZV9kaWcgMSAvLyBmaXJzdEVtcHR5OiB1aW50NjQKCWludCAwCgk9PQoJYnogaWY0X2VuZAoKCS8vIGlmNF9jb25zZXF1ZW50CgllcnIgLy8gJ1N0YWtpbmcgcG9vbCBmdWxsJwoKaWY0X2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE0OAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgPj0gdGhpcy5NaW5BbGxvd2VkU3Rha2UudmFsdWUsCgkvLyAgICAgICAgICAgICAnbXVzdCBzdGFrZSBhdCBsZWFzdCB0aGUgbWluaW11bSBmb3IgdGhpcyBwb29sJwoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBBbW91bnQKCWJ5dGUgMHg2ZDY5NmU0MTZjNmM2Zjc3NjU2NDUzNzQ2MTZiNjUgLy8gIm1pbkFsbG93ZWRTdGFrZSIKCWFwcF9nbG9iYWxfZ2V0Cgk+PQoKCS8vIG11c3Qgc3Rha2UgYXQgbGVhc3QgdGhlIG1pbmltdW0gZm9yIHRoaXMgcG9vbAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTUzCgkvLyBhc3NlcnQodGhpcy5TdGFrZXJzLnZhbHVlW2ZpcnN0RW1wdHkgLSAxXS5BY2NvdW50ID09PSBBZGRyZXNzLnplcm9BZGRyZXNzKQoJZnJhbWVfZGlnIDEgLy8gZmlyc3RFbXB0eTogdWludDY0CglpbnQgMQoJLQoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludCAwCgkrCglpbnQgMzIKCWJ5dGUgMHg3Mzc0NjE2YjY1NzI3MyAvLyAic3Rha2VycyIKCWNvdmVyIDIKCWJveF9leHRyYWN0CglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNTQKCS8vIHRoaXMuU3Rha2Vycy52YWx1ZVtmaXJzdEVtcHR5IC0gMV0gPSB7CgkvLyAgICAgICAgICAgICBBY2NvdW50OiBzdGFrZXIsCgkvLyAgICAgICAgICAgICBCYWxhbmNlOiBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCwKCS8vICAgICAgICAgICAgIFRvdGFsUmV3YXJkZWQ6IDAsCgkvLyAgICAgICAgICAgICBFbnRyeVRpbWU6IGVudHJ5VGltZSwKCS8vICAgICAgICAgfQoJZnJhbWVfZGlnIDEgLy8gZmlyc3RFbXB0eTogdWludDY0CglpbnQgMQoJLQoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWZyYW1lX2RpZyAtMiAvLyBzdGFrZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaXRvYgoJY29uY2F0CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAoJY29uY2F0CglmcmFtZV9kaWcgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglieXRlIDB4NzM3NDYxNmI2NTcyNzMgLy8gInN0YWtlcnMiCgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE2MAoJLy8gdGhpcy5OdW1TdGFrZXJzLnZhbHVlICs9IDEKCWJ5dGUgMHg2ZTc1NmQ1Mzc0NjE2YjY1NzI3MyAvLyAibnVtU3Rha2VycyIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMQoJKwoJYnl0ZSAweDZlNzU2ZDUzNzQ2MTZiNjU3MjczIC8vICJudW1TdGFrZXJzIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNjEKCS8vIHRoaXMuVG90YWxBbGdvU3Rha2VkLnZhbHVlICs9IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50CglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CgkrCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE2MgoJLy8gcmV0dXJuIGVudHJ5VGltZTsKCWZyYW1lX2RpZyAwIC8vIGVudHJ5VGltZTogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyByZW1vdmVTdGFrZShhZGRyZXNzLHVpbnQ2NCl2b2lkCmFiaV9yb3V0ZV9yZW1vdmVTdGFrZToKCS8vIGFtb3VudFRvVW5zdGFrZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gYWNjb3VudDogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVtb3ZlU3Rha2UoYWRkcmVzcyx1aW50NjQpdm9pZAoJY2FsbHN1YiByZW1vdmVTdGFrZQoJaW50IDEKCXJldHVybgoKLy8gcmVtb3ZlU3Rha2UoYWNjb3VudDogQWRkcmVzcywgYW1vdW50VG9VbnN0YWtlOiB1aW50NjQpOiB2b2lkCi8vCi8vIFJlbW92ZXMgc3Rha2Ugb24gYmVoYWxmIG9mIGEgcGFydGljdWxhciBzdGFrZXIuICBBbHNvIG5vdGlmaWVzIHRoZSB2YWxpZGF0b3IgY29udHJhY3QgZm9yIHRoaXMgcG9vbHMKLy8gdmFsaWRhdG9yIG9mIHRoZSBzdGFrZXIgLyBiYWxhbmNlIGNoYW5nZXMuCi8vCi8vIEBwYXJhbSB7QWRkcmVzc30gYWNjb3VudCAtIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHJlbW92aW5nIHN0YWtlLgovLyBAcGFyYW0ge3VpbnQ2NH0gYW1vdW50VG9VbnN0YWtlIC0gVGhlIGFtb3VudCBvZiBzdGFrZSB0byBiZSByZW1vdmVkLgovLyBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGFjY291bnQgaGFzIGluc3VmZmljaWVudCBiYWxhbmNlIG9yIGlmIHRoZSBhY2NvdW50IGlzIG5vdCBmb3VuZC4KcmVtb3ZlU3Rha2U6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiA0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTc3CgkvLyBhc3NlcnQoYWNjb3VudCAhPT0gQWNjb3VudC56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBhY2NvdW50OiBBZGRyZXNzCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxNzgKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGFjY291bnQpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTEgLy8gYWNjb3VudDogQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE3OQoJLy8gYXNzZXJ0KGFtb3VudFRvVW5zdGFrZSAhPT0gMCkKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxODEKCS8vIGkgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE4MgoJLy8gdGhpcy5TdGFrZXJzLnZhbHVlLmZvckVhY2gKCWJ5dGUgMHg3Mzc0NjE2YjY1NzI3MyAvLyAic3Rha2VycyIKCWJveF9nZXQKCWFzc2VydAoJZHVwCglmcmFtZV9idXJ5IDEgLy8gY29weSBvZiB0aGUgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyCglleHRyYWN0IDAgNTYKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50IDAKCWZyYW1lX2J1cnkgMyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoKZm9yRWFjaF8wOgoJLy8gaWY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTgzCgkvLyBzdGFrZXIuQWNjb3VudCA9PT0gYWNjb3VudAoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCAzMgoJZnJhbWVfZGlnIC0xIC8vIGFjY291bnQ6IEFkZHJlc3MKCT09CglieiBpZjVfZW5kCgoJLy8gaWY1X2NvbnNlcXVlbnQKCS8vIGlmNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE4NAoJLy8gc3Rha2VyLkJhbGFuY2UgPCBhbW91bnRUb1Vuc3Rha2UKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJPAoJYnogaWY2X2VuZAoKCS8vIGlmNl9jb25zZXF1ZW50CgllcnIgLy8gJ0luc3VmZmljaWVudCBiYWxhbmNlJwoKaWY2X2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE4NwoJLy8gc3Rha2VyLkJhbGFuY2UgLT0gYW1vdW50VG9VbnN0YWtlCglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50IDMyIC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJLQoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE4OAoJLy8gdGhpcy5Ub3RhbEFsZ29TdGFrZWQudmFsdWUgLT0gYW1vdW50VG9VbnN0YWtlCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudFRvVW5zdGFrZTogdWludDY0CgktCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE5MQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgICAgICBzdGFrZXIuQmFsYW5jZSA9PSAwIHx8IHN0YWtlci5CYWxhbmNlID49IE1JTl9BTEdPX1NUQUtFX1BFUl9QT09MLAoJLy8gICAgICAgICAgICAgICAgICAgICAnY2Fubm90IHJlZHVjZSBiYWxhbmNlIGJlbG93IG1pbmltdW0gYWxsb3dlZCBzdGFrZSB1bmxlc3MgYWxsIGlzIHJlbW92ZWQnCgkvLyAgICAgICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJaW50IDAKCT09CglkdXAKCWJueiBza2lwX29yMQoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJaW50IDEwMDAwMDAKCT49Cgl8fAoKc2tpcF9vcjE6CgkvLyBjYW5ub3QgcmVkdWNlIGJhbGFuY2UgYmVsb3cgbWluaW11bSBhbGxvd2VkIHN0YWtlIHVubGVzcyBhbGwgaXMgcmVtb3ZlZAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MTk3CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50VG9VbnN0YWtlLAoJLy8gICAgICAgICAgICAgICAgICAgICByZWNlaXZlcjogYWNjb3VudCwKCS8vICAgICAgICAgICAgICAgICAgICAgbm90ZTogJ3Vuc3Rha2VkJywKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjE5OAoJLy8gYW1vdW50OiBhbW91bnRUb1Vuc3Rha2UKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb1Vuc3Rha2U6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoxOTkKCS8vIHJlY2VpdmVyOiBhY2NvdW50CglmcmFtZV9kaWcgLTEgLy8gYWNjb3VudDogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwMAoJLy8gbm90ZTogJ3Vuc3Rha2VkJwoJYnl0ZSAweDc1NmU3Mzc0NjE2YjY1NjQgLy8gInVuc3Rha2VkIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwMgoJLy8gc3Rha2VyUmVtb3ZlZCA9IGZhbHNlCglpbnQgMAoJZnJhbWVfYnVyeSA0IC8vIHN0YWtlclJlbW92ZWQ6IGJvb2wKCgkvLyBpZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMDMKCS8vIHN0YWtlci5CYWxhbmNlID09PSAwCglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCglpbnQgMAoJPT0KCWJ6IGlmN19lbmQKCgkvLyBpZjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjA1CgkvLyB0aGlzLk51bVN0YWtlcnMudmFsdWUgLT0gMQoJYnl0ZSAweDZlNzU2ZDUzNzQ2MTZiNjU3MjczIC8vICJudW1TdGFrZXJzIgoJYXBwX2dsb2JhbF9nZXQKCWludCAxCgktCglieXRlIDB4NmU3NTZkNTM3NDYxNmI2NTcyNzMgLy8gIm51bVN0YWtlcnMiCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwNgoJLy8gc3Rha2VyLkFjY291bnQgPSBBZGRyZXNzLnplcm9BZGRyZXNzCglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJaW50IDAKCWdsb2JhbCBaZXJvQWRkcmVzcwoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIwNwoJLy8gc3Rha2VyLlRvdGFsUmV3YXJkZWQgPSAwCglmcmFtZV9kaWcgMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCXJlcGxhY2UyIDQwCglmcmFtZV9idXJ5IDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMDgKCS8vIHN0YWtlclJlbW92ZWQgPSB0cnVlCglpbnQgMQoJZnJhbWVfYnVyeSA0IC8vIHN0YWtlclJlbW92ZWQ6IGJvb2wKCmlmN19lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMTEKCS8vIHRoaXMuU3Rha2Vycy52YWx1ZVtpXSA9IHN0YWtlcgoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglpbnQgNTYKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJZnJhbWVfZGlnIDIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWJ5dGUgMHg3Mzc0NjE2YjY1NzI3MyAvLyAic3Rha2VycyIKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjE2CgkvLyBzZW5kTWV0aG9kQ2FsbDxbW3VpbnQ2NCwgdWludDY0XSwgQWRkcmVzcywgdWludDY0LCBib29sZWFuXSwgdm9pZD4oewoJLy8gICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUpLAoJLy8gICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc3Rha2VSZW1vdmVkJywKCS8vICAgICAgICAgICAgICAgICAgICAgbWV0aG9kQXJnczogW1t0aGlzLlZhbGlkYXRvcklELnZhbHVlLCB0aGlzLlBvb2xJRC52YWx1ZV0sIGFjY291bnQsIGFtb3VudFRvVW5zdGFrZSwgc3Rha2VyUmVtb3ZlZF0sCgkvLyAgICAgICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgInN0YWtlUmVtb3ZlZCgodWludDY0LHVpbnQ2NCksYWRkcmVzcyx1aW50NjQsYm9vbCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMTcKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLkNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJRC52YWx1ZSkKCWJ5dGUgMHg2MzcyNjU2MTc0NmY3MjQxNzA3MCAvLyAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMTkKCS8vIG1ldGhvZEFyZ3M6IFtbdGhpcy5WYWxpZGF0b3JJRC52YWx1ZSwgdGhpcy5Qb29sSUQudmFsdWVdLCBhY2NvdW50LCBhbW91bnRUb1Vuc3Rha2UsIHN0YWtlclJlbW92ZWRdCglieXRlIDB4NzY2MTZjNjk2NDYxNzQ2ZjcyNDk0NCAvLyAidmFsaWRhdG9ySUQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJYnl0ZSAweDcwNmY2ZjZjNDk0NCAvLyAicG9vbElEIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMSAvLyBhY2NvdW50OiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudFRvVW5zdGFrZTogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDQgLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoJYnl0ZSAweDAwCglpbnQgMAoJdW5jb3ZlciAyCglzZXRiaXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKaWY1X2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIyMgoJLy8gaSArPSAxCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgoJLy8gaW5jcmVtZW50IG9mZnNldCBhbmQgbG9vcCBpZiBub3Qgb3V0IG9mIGJvdW5kcwoJZnJhbWVfZGlnIDMgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludCA1NgoJKwoJZHVwCglpbnQgNDA4OCAvLyBvZmZzZXQgb2YgbGFzdCBlbGVtZW50Cgk8CglieiBmb3JFYWNoXzBfZW5kCglmcmFtZV9idXJ5IDMgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWZyYW1lX2RpZyAxIC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZnJhbWVfZGlnIDMgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWludCA1NgoJZXh0cmFjdAoJZnJhbWVfYnVyeSAyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgliIGZvckVhY2hfMAoKZm9yRWFjaF8wX2VuZDoKCWVyciAvLyAnQWNjb3VudCBub3QgZm91bmQnCgovLyBwYXlTdGFrZXJzKCl2b2lkCmFiaV9yb3V0ZV9wYXlTdGFrZXJzOgoJLy8gZXhlY3V0ZSBwYXlTdGFrZXJzKCl2b2lkCgljYWxsc3ViIHBheVN0YWtlcnMKCWludCAxCglyZXR1cm4KCi8vIHBheVN0YWtlcnMoKTogdm9pZApwYXlTdGFrZXJzOgoJcHJvdG8gMCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMjMKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMjkKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuT3duZXIudmFsdWUgfHwgdGhpcy50eG4uc2VuZGVyID09PSB0aGlzLk1hbmFnZXIudmFsdWUpCgl0eG4gU2VuZGVyCglieXRlIDB4NmY3NzZlNjU3MiAvLyAib3duZXIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWR1cAoJYm56IHNraXBfb3IyCgl0eG4gU2VuZGVyCglieXRlIDB4NmQ2MTZlNjE2NzY1NzIgLy8gIm1hbmFnZXIiCglhcHBfZ2xvYmFsX2dldAoJPT0KCXx8Cgpza2lwX29yMjoKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjIzMgoJLy8gcGF5b3V0Q29uZmlnID0gc2VuZE1ldGhvZENhbGw8W3VpbnQ2NF0sIFt1aW50MTYsIHVpbnQzMiwgQWRkcmVzcywgdWludDgsIHVpbnQxNl0+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLkNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJRC52YWx1ZSksCgkvLyAgICAgICAgICAgICBuYW1lOiAnZ2V0VmFsaWRhdG9yQ29uZmlnJywKCS8vICAgICAgICAgICAgIG1ldGhvZEFyZ3M6IFt0aGlzLlZhbGlkYXRvcklELnZhbHVlXSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgImdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMzMKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLkNyZWF0aW5nVmFsaWRhdG9yQ29udHJhY3RBcHBJRC52YWx1ZSkKCWJ5dGUgMHg2MzcyNjU2MTc0NmY3MjQxNzA3MCAvLyAiY3JlYXRvckFwcCIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyMzUKCS8vIG1ldGhvZEFyZ3M6IFt0aGlzLlZhbGlkYXRvcklELnZhbHVlXQoJYnl0ZSAweDc2NjE2YzY5NjQ2MTc0NmY3MjQ5NDQgLy8gInZhbGlkYXRvcklEIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnQgMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglmcmFtZV9idXJ5IDAgLy8gcGF5b3V0Q29uZmlnOiAodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNDAKCS8vIHBheW91dERheXMgPSBwYXlvdXRDb25maWdbMF0gYXMgdWludDY0CglmcmFtZV9kaWcgMCAvLyBwYXlvdXRDb25maWc6ICh1aW50MTYsdWludDMyLGFkZHJlc3MsdWludDgsdWludDE2KQoJZXh0cmFjdCAwIDIKCWJ0b2kKCWZyYW1lX2J1cnkgMSAvLyBwYXlvdXREYXlzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNDEKCS8vIHBjdFRvVmFsaWRhdG9yID0gcGF5b3V0Q29uZmlnWzFdIGFzIHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gcGF5b3V0Q29uZmlnOiAodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikKCWV4dHJhY3QgMiA0CglidG9pCglmcmFtZV9idXJ5IDIgLy8gcGN0VG9WYWxpZGF0b3I6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjI0MgoJLy8gdmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgPSBwYXlvdXRDb25maWdbMl0KCWZyYW1lX2RpZyAwIC8vIHBheW91dENvbmZpZzogKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpCglleHRyYWN0IDYgMzIKCWZyYW1lX2J1cnkgMyAvLyB2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzczogYWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjI0NgoJLy8gb3JpZ0JhbGFuY2UgPSB0aGlzLmFwcC5hZGRyZXNzLmJhbGFuY2UKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKCXBvcAoJZnJhbWVfYnVyeSA0IC8vIG9yaWdCYWxhbmNlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNDcKCS8vIHJld2FyZEF2YWlsYWJsZSA9IG9yaWdCYWxhbmNlIC0gdGhpcy5Ub3RhbEFsZ29TdGFrZWQudmFsdWUgLSB0aGlzLmFwcC5hZGRyZXNzLm1pbkJhbGFuY2UKCWZyYW1lX2RpZyA0IC8vIG9yaWdCYWxhbmNlOiB1aW50NjQKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCWFwcF9nbG9iYWxfZ2V0CgktCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RNaW5CYWxhbmNlCglwb3AKCS0KCWZyYW1lX2J1cnkgNSAvLyByZXdhcmRBdmFpbGFibGU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjI1MAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgcmV3YXJkQXZhaWxhYmxlID4gZ2xvYmFscy5taW5UeG5GZWUgKiAyLAoJLy8gICAgICAgICAgICAgJ1Jld2FyZCB0byBwYXlvdXQgbm90IGhpZ2ggZW5vdWdoIHRvIGNvdmVyIHR4biBjb3N0cyBvZiBwYXlpbmcgaXQgb3V0JwoJLy8gICAgICAgICApCglmcmFtZV9kaWcgNSAvLyByZXdhcmRBdmFpbGFibGU6IHVpbnQ2NAoJZ2xvYmFsIE1pblR4bkZlZQoJaW50IDIKCSoKCT4KCgkvLyBSZXdhcmQgdG8gcGF5b3V0IG5vdCBoaWdoIGVub3VnaCB0byBjb3ZlciB0eG4gY29zdHMgb2YgcGF5aW5nIGl0IG91dAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjU2CgkvLyB2YWxpZGF0b3JQYXkgPSB3aWRlUmF0aW8oW3Jld2FyZEF2YWlsYWJsZSwgcGN0VG9WYWxpZGF0b3JdLCBbMTAwMDAwMF0pCglmcmFtZV9kaWcgNSAvLyByZXdhcmRBdmFpbGFibGU6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gcGN0VG9WYWxpZGF0b3I6IHVpbnQ2NAoJbXVsdwoJaW50IDAKCWludCAxMDAwMDAwCglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoJYXNzZXJ0CglmcmFtZV9idXJ5IDYgLy8gdmFsaWRhdG9yUGF5OiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNTgKCS8vIHJld2FyZEF2YWlsYWJsZSAtPSB2YWxpZGF0b3JQYXkKCWZyYW1lX2RpZyA1IC8vIHJld2FyZEF2YWlsYWJsZTogdWludDY0CglmcmFtZV9kaWcgNiAvLyB2YWxpZGF0b3JQYXk6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSA1IC8vIHJld2FyZEF2YWlsYWJsZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MjYyCgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICBhbW91bnQ6IHZhbGlkYXRvclBheSwKCS8vICAgICAgICAgICAgIHJlY2VpdmVyOiB2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcywKCS8vICAgICAgICAgICAgIG5vdGU6ICd2YWxpZGF0b3IgcmV3YXJkJywKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNjMKCS8vIGFtb3VudDogdmFsaWRhdG9yUGF5CglmcmFtZV9kaWcgNiAvLyB2YWxpZGF0b3JQYXk6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNjQKCS8vIHJlY2VpdmVyOiB2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcwoJZnJhbWVfZGlnIDMgLy8gdmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3M6IGFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czoyNjUKCS8vIG5vdGU6ICd2YWxpZGF0b3IgcmV3YXJkJwoJYnl0ZSAweDc2NjE2YzY5NjQ2MTc0NmY3MjIwNzI2NTc3NjE3MjY0IC8vICJ2YWxpZGF0b3IgcmV3YXJkIgoJaXR4bl9maWVsZCBOb3RlCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjI3NQoJLy8gY3VyVGltZSA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9idXJ5IDcgLy8gY3VyVGltZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6Mjc3CgkvLyBwYXlvdXREYXlzSW5TZWNzID0gcGF5b3V0RGF5cyAqIDI0ICogNjAgKiA2MAoJZnJhbWVfZGlnIDEgLy8gcGF5b3V0RGF5czogdWludDY0CglpbnQgMjQKCSoKCWludCA2MAoJKgoJaW50IDYwCgkqCglmcmFtZV9idXJ5IDggLy8gcGF5b3V0RGF5c0luU2VjczogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzAxCgkvLyBwYXJ0aWFsU3Rha2Vyc1RvdGFsU3Rha2UgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSA5IC8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzAyCgkvLyBpID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMTAgLy8gaTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzAzCgkvLyB0aGlzLlN0YWtlcnMudmFsdWUuZm9yRWFjaAoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJYm94X2dldAoJYXNzZXJ0CglkdXAKCWZyYW1lX2J1cnkgMTEgLy8gY29weSBvZiB0aGUgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyCglleHRyYWN0IDAgNTYKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWludCAwCglmcmFtZV9idXJ5IDEzIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCgpmb3JFYWNoXzE6CgkvLyBpZjhfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMDQKCS8vIHN0YWtlci5BY2NvdW50ICE9PSBBZGRyZXNzLnplcm9BZGRyZXNzCglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCAzMgoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYnogaWY4X2VuZAoKCS8vIGlmOF9jb25zZXF1ZW50CgkvLyBpZjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMDUKCS8vIHN0YWtlci5FbnRyeVRpbWUgPiBjdXJUaW1lCglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJZnJhbWVfZGlnIDcgLy8gY3VyVGltZTogdWludDY0Cgk+CglieiBpZjlfZWxzZQoKCS8vIGlmOV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMDgKCS8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZSArPSBzdGFrZXIuQmFsYW5jZQoJZnJhbWVfZGlnIDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCWZyYW1lX2RpZyAxMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAzMiA4CglidG9pCgkrCglmcmFtZV9idXJ5IDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCWIgaWY5X2VuZAoKaWY5X2Vsc2U6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMTIKCS8vIHRpbWVJblBvb2wgPSBjdXJUaW1lIC0gc3Rha2VyLkVudHJ5VGltZQoJZnJhbWVfZGlnIDcgLy8gY3VyVGltZTogdWludDY0CglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJLQoJZnJhbWVfYnVyeSAxNCAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCgkvLyBpZjEwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzE1CgkvLyB0aW1lSW5Qb29sIDwgcGF5b3V0RGF5c0luU2VjcwoJZnJhbWVfZGlnIDE0IC8vIHRpbWVJblBvb2w6IHVpbnQ2NAoJZnJhbWVfZGlnIDggLy8gcGF5b3V0RGF5c0luU2VjczogdWludDY0Cgk8CglieiBpZjEwX2VuZAoKCS8vIGlmMTBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzE2CgkvLyBwYXJ0aWFsU3Rha2Vyc1RvdGFsU3Rha2UgKz0gc3Rha2VyLkJhbGFuY2UKCWZyYW1lX2RpZyA5IC8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZTogdWludDY0CglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJKwoJZnJhbWVfYnVyeSA5IC8vIHBhcnRpYWxTdGFrZXJzVG90YWxTdGFrZTogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzE3CgkvLyB0aW1lUGVyY2VudGFnZSA9ICh0aW1lSW5Qb29sICogMTAwMCkgLyBwYXlvdXREYXlzSW5TZWNzCglmcmFtZV9kaWcgMTQgLy8gdGltZUluUG9vbDogdWludDY0CglpbnQgMTAwMAoJKgoJZnJhbWVfZGlnIDggLy8gcGF5b3V0RGF5c0luU2VjczogdWludDY0CgkvCglmcmFtZV9idXJ5IDE1IC8vIHRpbWVQZXJjZW50YWdlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMTkKCS8vIHN0YWtlclJld2FyZCA9IHdpZGVSYXRpbygKCS8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3Rha2VyLkJhbGFuY2UsIHJld2FyZEF2YWlsYWJsZSwgdGltZVBlcmNlbnRhZ2VdLAoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSAvIDEwMDBdCgkvLyAgICAgICAgICAgICAgICAgICAgICAgICApCglmcmFtZV9kaWcgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMzIgOAoJYnRvaQoJZnJhbWVfZGlnIDUgLy8gcmV3YXJkQXZhaWxhYmxlOiB1aW50NjQKCW11bHcKCWZyYW1lX2RpZyAxNSAvLyB0aW1lUGVyY2VudGFnZTogdWludDY0Cgl1bmNvdmVyIDIKCWRpZyAxCgkqCgljb3ZlciAyCgltdWx3Cgljb3ZlciAyCgkrCglzd2FwCglpbnQgMAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXQKCWludCAxMDAwCgkvCglkaXZtb2R3Cglwb3AKCXBvcAoJc3dhcAoJIQoJYXNzZXJ0CglmcmFtZV9idXJ5IDE2IC8vIHN0YWtlclJld2FyZDogdWludDY0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzI1CgkvLyByZXdhcmRBdmFpbGFibGUgLT0gc3Rha2VyUmV3YXJkCglmcmFtZV9kaWcgNSAvLyByZXdhcmRBdmFpbGFibGU6IHVpbnQ2NAoJZnJhbWVfZGlnIDE2IC8vIHN0YWtlclJld2FyZDogdWludDY0CgktCglmcmFtZV9idXJ5IDUgLy8gcmV3YXJkQXZhaWxhYmxlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMjgKCS8vIHN0YWtlci5CYWxhbmNlICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgMzIgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyAxNiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMjkKCS8vIHN0YWtlci5Ub3RhbFJld2FyZGVkICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgNDAgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDEyIC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQwIDgKCWJ0b2kKCWZyYW1lX2RpZyAxNiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMzIKCS8vIHRoaXMuU3Rha2Vycy52YWx1ZVtpXSA9IHN0YWtlcgoJZnJhbWVfZGlnIDEwIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWZyYW1lX2RpZyAxMiAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCmlmMTBfZW5kOgoKaWY5X2VuZDoKCmlmOF9lbmQ6CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozMzYKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDEwIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMTAgLy8gaTogdWludDY0CgoJLy8gaW5jcmVtZW50IG9mZnNldCBhbmQgbG9vcCBpZiBub3Qgb3V0IG9mIGJvdW5kcwoJZnJhbWVfZGlnIDEzIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCglpbnQgNTYKCSsKCWR1cAoJaW50IDQwODggLy8gb2Zmc2V0IG9mIGxhc3QgZWxlbWVudAoJPAoJYnogZm9yRWFjaF8xX2VuZAoJZnJhbWVfYnVyeSAxMyAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJZnJhbWVfZGlnIDExIC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZnJhbWVfZGlnIDEzIC8vIHRoZSBvZmZzZXQgd2UgYXJlIGV4dHJhY3RpbmcgdGhlIG5leHQgZWxlbWVudCBmcm9tCglpbnQgNTYKCWV4dHJhY3QKCWZyYW1lX2J1cnkgMTIgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWIgZm9yRWFjaF8xCgpmb3JFYWNoXzFfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzQxCgkvLyBuZXdQb29sVG90YWxTdGFrZSA9IHRoaXMuVG90YWxBbGdvU3Rha2VkLnZhbHVlIC0gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDkgLy8gcGFydGlhbFN0YWtlcnNUb3RhbFN0YWtlOiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMTcgLy8gbmV3UG9vbFRvdGFsU3Rha2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM0MwoJLy8gaSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDEwIC8vIGk6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM0NAoJLy8gdGhpcy5TdGFrZXJzLnZhbHVlLmZvckVhY2gKCWJ5dGUgMHg3Mzc0NjE2YjY1NzI3MyAvLyAic3Rha2VycyIKCWJveF9nZXQKCWFzc2VydAoJZHVwCglmcmFtZV9idXJ5IDE4IC8vIGNvcHkgb2YgdGhlIGFycmF5IHdlIGFyZSBpdGVyYXRpbmcgb3ZlcgoJZXh0cmFjdCAwIDU2CglmcmFtZV9idXJ5IDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgMAoJZnJhbWVfYnVyeSAyMCAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoKZm9yRWFjaF8yOgoJLy8gaWYxMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM0NQoJLy8gc3Rha2VyLkFjY291bnQgIT09IEFkZHJlc3MuemVyb0FkZHJlc3MgJiYgc3Rha2VyLkVudHJ5VGltZSA8IGN1clRpbWUKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9CglkdXAKCWJ6IHNraXBfYW5kMAoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQ4IDgKCWJ0b2kKCWZyYW1lX2RpZyA3IC8vIGN1clRpbWU6IHVpbnQ2NAoJPAoJJiYKCnNraXBfYW5kMDoKCWJ6IGlmMTFfZW5kCgoJLy8gaWYxMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNDYKCS8vIHRpbWVJblBvb2wgPSBjdXJUaW1lIC0gc3Rha2VyLkVudHJ5VGltZQoJZnJhbWVfZGlnIDcgLy8gY3VyVGltZTogdWludDY0CglmcmFtZV9kaWcgMTkgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNDggOAoJYnRvaQoJLQoJZnJhbWVfYnVyeSAyMSAvLyB0aW1lSW5Qb29sOiB1aW50NjQKCgkvLyBpZjEyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzQ4CgkvLyB0aW1lSW5Qb29sIDwgcGF5b3V0RGF5c0luU2VjcwoJZnJhbWVfZGlnIDIxIC8vIHRpbWVJblBvb2w6IHVpbnQ2NAoJZnJhbWVfZGlnIDggLy8gcGF5b3V0RGF5c0luU2VjczogdWludDY0Cgk8CglieiBpZjEyX2VuZAoKCS8vIGlmMTJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzQ5CgkvLyByZXR1cm47CgliIGZvckVhY2hfMl9lbmQKCmlmMTJfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzUzCgkvLyBzdGFrZXJSZXdhcmQgPSB3aWRlUmF0aW8oW3N0YWtlci5CYWxhbmNlLCByZXdhcmRBdmFpbGFibGVdLCBbbmV3UG9vbFRvdGFsU3Rha2VdKQoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyA1IC8vIHJld2FyZEF2YWlsYWJsZTogdWludDY0CgltdWx3CglpbnQgMAoJZnJhbWVfZGlnIDE3IC8vIG5ld1Bvb2xUb3RhbFN0YWtlOiB1aW50NjQKCWRpdm1vZHcKCXBvcAoJcG9wCglzd2FwCgkhCglhc3NlcnQKCWZyYW1lX2J1cnkgMjIgLy8gc3Rha2VyUmV3YXJkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNTYKCS8vIHN0YWtlci5CYWxhbmNlICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgMzIgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDMyIDgKCWJ0b2kKCWZyYW1lX2RpZyAyMiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMTkgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNTcKCS8vIHN0YWtlci5Ub3RhbFJld2FyZGVkICs9IHN0YWtlclJld2FyZAoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglpbnQgNDAgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDQwIDgKCWJ0b2kKCWZyYW1lX2RpZyAyMiAvLyBzdGFrZXJSZXdhcmQ6IHVpbnQ2NAoJKwoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMTkgLy8gc3Rha2VyOiAoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNjAKCS8vIHRoaXMuU3Rha2Vycy52YWx1ZVtpXSA9IHN0YWtlcgoJZnJhbWVfZGlnIDEwIC8vIGk6IHVpbnQ2NAoJaW50IDU2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWZyYW1lX2RpZyAxOSAvLyBzdGFrZXI6IChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJYnl0ZSAweDczNzQ2MTZiNjU3MjczIC8vICJzdGFrZXJzIgoJY292ZXIgMgoJYm94X3JlcGxhY2UKCmlmMTFfZW5kOgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzYyCgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxMCAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDEwIC8vIGk6IHVpbnQ2NAoKCS8vIGluY3JlbWVudCBvZmZzZXQgYW5kIGxvb3AgaWYgbm90IG91dCBvZiBib3VuZHMKCWZyYW1lX2RpZyAyMCAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJaW50IDU2CgkrCglkdXAKCWludCA0MDg4IC8vIG9mZnNldCBvZiBsYXN0IGVsZW1lbnQKCTwKCWJ6IGZvckVhY2hfMl9lbmQKCWZyYW1lX2J1cnkgMjAgLy8gdGhlIG9mZnNldCB3ZSBhcmUgZXh0cmFjdGluZyB0aGUgbmV4dCBlbGVtZW50IGZyb20KCWZyYW1lX2RpZyAxOCAvLyBjb3B5IG9mIHRoZSBhcnJheSB3ZSBhcmUgaXRlcmF0aW5nIG92ZXIKCWZyYW1lX2RpZyAyMCAvLyB0aGUgb2Zmc2V0IHdlIGFyZSBleHRyYWN0aW5nIHRoZSBuZXh0IGVsZW1lbnQgZnJvbQoJaW50IDU2CglleHRyYWN0CglmcmFtZV9idXJ5IDE5IC8vIHN0YWtlcjogKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgliIGZvckVhY2hfMgoKZm9yRWFjaF8yX2VuZDoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM2NwoJLy8gaW5jcmVhc2VkU3Rha2UgPSB0aGlzLmFwcC5hZGRyZXNzLmJhbGFuY2UgLSB0aGlzLlRvdGFsQWxnb1N0YWtlZC52YWx1ZSAtIHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQoJcG9wCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJLQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCgktCglmcmFtZV9idXJ5IDIzIC8vIGluY3JlYXNlZFN0YWtlOiB1aW50NjQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozNjgKCS8vIHRoaXMuVG90YWxBbGdvU3Rha2VkLnZhbHVlICs9IGluY3JlYXNlZFN0YWtlCglieXRlIDB4NzM3NDYxNmI2NTY0IC8vICJzdGFrZWQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIDIzIC8vIGluY3JlYXNlZFN0YWtlOiB1aW50NjQKCSsKCWJ5dGUgMHg3Mzc0NjE2YjY1NjQgLy8gInN0YWtlZCIKCXN3YXAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzczCgkvLyBzZW5kTWV0aG9kQ2FsbDxbW3VpbnQ2NCwgdWludDY0LCB1aW50NjRdLCB1aW50NjRdLCB2b2lkPih7CgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5DcmVhdGluZ1ZhbGlkYXRvckNvbnRyYWN0QXBwSUQudmFsdWUpLAoJLy8gICAgICAgICAgICAgbmFtZTogJ3N0YWtlVXBkYXRlZFZpYVJld2FyZHMnLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW1t0aGlzLlZhbGlkYXRvcklELnZhbHVlLCB0aGlzLlBvb2xJRC52YWx1ZSwgdGhpcy5hcHAuaWRdLCBpbmNyZWFzZWRTdGFrZV0sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKCh1aW50NjQsdWludDY0LHVpbnQ2NCksdWludDY0KXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM3NAoJLy8gYXBwbGljYXRpb25JRDogQXBwbGljYXRpb24uZnJvbUlEKHRoaXMuQ3JlYXRpbmdWYWxpZGF0b3JDb250cmFjdEFwcElELnZhbHVlKQoJYnl0ZSAweDYzNzI2NTYxNzQ2ZjcyNDE3MDcwIC8vICJjcmVhdG9yQXBwIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjM3NgoJLy8gbWV0aG9kQXJnczogW1t0aGlzLlZhbGlkYXRvcklELnZhbHVlLCB0aGlzLlBvb2xJRC52YWx1ZSwgdGhpcy5hcHAuaWRdLCBpbmNyZWFzZWRTdGFrZV0KCWJ5dGUgMHg3NjYxNmM2OTY0NjE3NDZmNzI0OTQ0IC8vICJ2YWxpZGF0b3JJRCIKCWFwcF9nbG9iYWxfZ2V0CglpdG9iCglieXRlIDB4NzA2ZjZmNmM0OTQ0IC8vICJwb29sSUQiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJY29uY2F0Cgl0eG5hIEFwcGxpY2F0aW9ucyAwCglpdG9iCgljb25jYXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgMjMgLy8gaW5jcmVhc2VkU3Rha2U6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGdvT25saW5lKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKYWJpX3JvdXRlX2dvT25saW5lOgoJLy8gdm90ZUtleURpbHV0aW9uOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyB2b3RlTGFzdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gdm90ZUZpcnN0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBzdGF0ZVByb29mUEs6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBzZWxlY3Rpb25QSzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIHZvdGVQSzogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgZ29PbmxpbmUoYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBnb09ubGluZQoJaW50IDEKCXJldHVybgoKLy8gZ29PbmxpbmUodm90ZVBLOiBieXRlcywgc2VsZWN0aW9uUEs6IGJ5dGVzLCBzdGF0ZVByb29mUEs6IGJ5dGVzLCB2b3RlRmlyc3Q6IHVpbnQ2NCwgdm90ZUxhc3Q6IHVpbnQ2NCwgdm90ZUtleURpbHV0aW9uOiB1aW50NjQpOiB2b2lkCmdvT25saW5lOgoJcHJvdG8gNiAwCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6Mzg4CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSB0aGlzLk93bmVyLnZhbHVlIHx8IHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy5NYW5hZ2VyLnZhbHVlKQoJdHhuIFNlbmRlcgoJYnl0ZSAweDZmNzc2ZTY1NzIgLy8gIm93bmVyIgoJYXBwX2dsb2JhbF9nZXQKCT09CglkdXAKCWJueiBza2lwX29yMwoJdHhuIFNlbmRlcgoJYnl0ZSAweDZkNjE2ZTYxNjc2NTcyIC8vICJtYW5hZ2VyIgoJYXBwX2dsb2JhbF9nZXQKCT09Cgl8fAoKc2tpcF9vcjM6Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozODkKCS8vIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24oewoJLy8gICAgICAgICAgICAgdm90ZVBLOiB2b3RlUEssCgkvLyAgICAgICAgICAgICBzZWxlY3Rpb25QSzogc2VsZWN0aW9uUEssCgkvLyAgICAgICAgICAgICBzdGF0ZVByb29mUEs6IHN0YXRlUHJvb2ZQSywKCS8vICAgICAgICAgICAgIHZvdGVGaXJzdDogdm90ZUZpcnN0LAoJLy8gICAgICAgICAgICAgdm90ZUxhc3Q6IHZvdGVMYXN0LAoJLy8gICAgICAgICAgICAgdm90ZUtleURpbHV0aW9uOiB2b3RlS2V5RGlsdXRpb24sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzkwCgkvLyB2b3RlUEs6IHZvdGVQSwoJZnJhbWVfZGlnIC0xIC8vIHZvdGVQSzogYnl0ZXMKCWl0eG5fZmllbGQgVm90ZVBLCgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6MzkxCgkvLyBzZWxlY3Rpb25QSzogc2VsZWN0aW9uUEsKCWZyYW1lX2RpZyAtMiAvLyBzZWxlY3Rpb25QSzogYnl0ZXMKCWl0eG5fZmllbGQgU2VsZWN0aW9uUEsKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozOTIKCS8vIHN0YXRlUHJvb2ZQSzogc3RhdGVQcm9vZlBLCglmcmFtZV9kaWcgLTMgLy8gc3RhdGVQcm9vZlBLOiBieXRlcwoJaXR4bl9maWVsZCBTdGF0ZVByb29mUEsKCgkvLyBjb250cmFjdHMvc3Rha2luZ1Bvb2wuYWxnby50czozOTMKCS8vIHZvdGVGaXJzdDogdm90ZUZpcnN0CglmcmFtZV9kaWcgLTQgLy8gdm90ZUZpcnN0OiB1aW50NjQKCWl0eG5fZmllbGQgVm90ZUZpcnN0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6Mzk0CgkvLyB2b3RlTGFzdDogdm90ZUxhc3QKCWZyYW1lX2RpZyAtNSAvLyB2b3RlTGFzdDogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVMYXN0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6Mzk1CgkvLyB2b3RlS2V5RGlsdXRpb246IHZvdGVLZXlEaWx1dGlvbgoJZnJhbWVfZGlnIC02IC8vIHZvdGVLZXlEaWx1dGlvbjogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVLZXlEaWx1dGlvbgoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gZ29PZmZsaW5lKCl2b2lkCmFiaV9yb3V0ZV9nb09mZmxpbmU6CgkvLyBleGVjdXRlIGdvT2ZmbGluZSgpdm9pZAoJY2FsbHN1YiBnb09mZmxpbmUKCWludCAxCglyZXR1cm4KCi8vIGdvT2ZmbGluZSgpOiB2b2lkCmdvT2ZmbGluZToKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjQwMAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy5Pd25lci52YWx1ZSB8fCB0aGlzLnR4bi5zZW5kZXIgPT09IHRoaXMuTWFuYWdlci52YWx1ZSkKCXR4biBTZW5kZXIKCWJ5dGUgMHg2Zjc3NmU2NTcyIC8vICJvd25lciIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJZHVwCglibnogc2tpcF9vcjQKCXR4biBTZW5kZXIKCWJ5dGUgMHg2ZDYxNmU2MTY3NjU3MiAvLyAibWFuYWdlciIKCWFwcF9nbG9iYWxfZ2V0Cgk9PQoJfHwKCnNraXBfb3I0OgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3N0YWtpbmdQb29sLmFsZ28udHM6NDAxCgkvLyBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbih7fSkKCWl0eG5fYmVnaW4KCWludCBrZXlyZWcKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGdldEVudHJ5VGltZSgpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlIHRoZSBlbnRyeSB0aW1lIGZvciBjb3VudGluZyBhIHN0YWtlIGFzIGVudGVyaW5nIHRoZSBwb29sLgovLyBBbGdvcmFuZCB3b24ndCBzZWUgdGhlIGJhbGFuY2UgaW5jcmVhc2UgZm9yIEFMR09SQU5EX1NUQUtJTkdfQkxPQ0tfREVMQVkgcm91bmRzLCBzbyB3ZSBhcHByb3hpbWF0ZSBpdC4KLy8gVGhlIGVudHJ5IHRpbWUgaXMgY2FsY3VsYXRlZCBieSBhZGRpbmcgYW4gYXBwcm94aW1hdGUgbnVtYmVyIG9mIHNlY29uZHMgYmFzZWQgb24gY3VycmVudCBBVkcgYmxvY2sgdGltZXMKLy8gdG8gdGhlIG9yaWdpbmFsIGVudHJ5IHRpbWUuICBUaGlzIG1lYW5zIHVzZXJzIGRvbid0IGdldCBwYXlvdXRzIGJhc2VkIG9uIHRpbWUgdGhlaXIgYmFsYW5jZSB3b3VsZG4ndCBoYXZlCi8vIGJlZW4gc2VlbiBieSB0aGUgbmV0d29yay4KLy8KLy8gQHJldHVybnMge3VpbnQ2NH0gLSBUaGUgdXBkYXRlZCBlbnRyeSB0aW1lLgpnZXRFbnRyeVRpbWU6Cglwcm90byAwIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjQxNgoJLy8gZW50cnlUaW1lID0gZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWZyYW1lX2J1cnkgMCAvLyBlbnRyeVRpbWU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9zdGFraW5nUG9vbC5hbGdvLnRzOjQxOQoJLy8gcmV0dXJuIGVudHJ5VGltZSArIChBTEdPUkFORF9TVEFLSU5HX0JMT0NLX0RFTEFZICogQVZHX0JMT0NLX1RJTUVfU0VDUykgLyAxMDsKCWZyYW1lX2RpZyAwIC8vIGVudHJ5VGltZTogdWludDY0CglpbnQgOTYwCgkrCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCmNyZWF0ZV9Ob09wOgoJbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgllcnIKCmNhbGxfTm9PcDoKCW1ldGhvZCAiZ2FzKCl2b2lkIgoJbWV0aG9kICJhZGRTdGFrZShwYXksYWRkcmVzcyl1aW50NjQiCgltZXRob2QgInJlbW92ZVN0YWtlKGFkZHJlc3MsdWludDY0KXZvaWQiCgltZXRob2QgInBheVN0YWtlcnMoKXZvaWQiCgltZXRob2QgImdvT25saW5lKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCgltZXRob2QgImdvT2ZmbGluZSgpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV9nYXMgYWJpX3JvdXRlX2FkZFN0YWtlIGFiaV9yb3V0ZV9yZW1vdmVTdGFrZSBhYmlfcm91dGVfcGF5U3Rha2VycyBhYmlfcm91dGVfZ29PbmxpbmUgYWJpX3JvdXRlX2dvT2ZmbGluZQoJZXJy",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDk="
  },
  "contract": {
    "name": "StakingPool",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "desc": "Initialize the staking pool w/ owner and manager, but can only be created by the validator contract.",
        "args": [
          {
            "name": "creatingContractID",
            "type": "uint64",
            "desc": "id of contract that constructed us - the validator application (single global instance)"
          },
          {
            "name": "validatorID",
            "type": "uint64",
            "desc": "id of validator we're a staking pool of"
          },
          {
            "name": "poolID",
            "type": "uint64",
            "desc": "which pool id are we"
          },
          {
            "name": "owner",
            "type": "address",
            "desc": "owner of pool"
          },
          {
            "name": "manager",
            "type": "address",
            "desc": "manager of pool (can issue payouts and online txns)"
          },
          {
            "name": "minAllowedStake",
            "type": "uint64",
            "desc": "minimum amount to be in pool, but also minimum amount balance can't go below (without removing all!)"
          },
          {
            "name": "maxStakeAllowed",
            "type": "uint64",
            "desc": "maximum algo allowed in this staking pool"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "gas",
        "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "addStake",
        "desc": "Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.",
        "args": [
          {
            "name": "stakedAmountPayment",
            "type": "pay",
            "desc": "prior payment coming from validator contract to us on behalf of staker."
          },
          {
            "name": "staker",
            "type": "address",
            "desc": "The account adding new stake"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "{uint64}new 'entry time' in seconds of stake add."
        }
      },
      {
        "name": "removeStake",
        "desc": "Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidator of the staker / balance changes.",
        "args": [
          {
            "name": "account",
            "type": "address",
            "desc": "The address of the account removing stake."
          },
          {
            "name": "amountToUnstake",
            "type": "uint64",
            "desc": "The amount of stake to be removed."
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "payStakers",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "goOnline",
        "args": [
          {
            "name": "votePK",
            "type": "byte[]"
          },
          {
            "name": "selectionPK",
            "type": "byte[]"
          },
          {
            "name": "stateProofPK",
            "type": "byte[]"
          },
          {
            "name": "voteFirst",
            "type": "uint64"
          },
          {
            "name": "voteLast",
            "type": "uint64"
          },
          {
            "name": "voteKeyDilution",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "goOffline",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

/**
 * Defines the types of available calls and state of the StakingPool smart contract.
 */
export type StakingPool = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void' | 'createApplication', {
      argsObj: {
        /**
         * id of contract that constructed us - the validator application (single global instance)
         */
        creatingContractID: bigint | number
        /**
         * id of validator we're a staking pool of
         */
        validatorID: bigint | number
        /**
         * which pool id are we
         */
        poolID: bigint | number
        /**
         * owner of pool
         */
        owner: string
        /**
         * manager of pool (can issue payouts and online txns)
         */
        manager: string
        /**
         * minimum amount to be in pool, but also minimum amount balance can't go below (without removing all!)
         */
        minAllowedStake: bigint | number
        /**
         * maximum algo allowed in this staking pool
         */
        maxStakeAllowed: bigint | number
      }
      argsTuple: [creatingContractID: bigint | number, validatorID: bigint | number, poolID: bigint | number, owner: string, manager: string, minAllowedStake: bigint | number, maxStakeAllowed: bigint | number]
      returns: void
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'addStake(pay,address)uint64' | 'addStake', {
      argsObj: {
        /**
         * prior payment coming from validator contract to us on behalf of staker.
         */
        stakedAmountPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * The account adding new stake
         */
        staker: string
      }
      argsTuple: [stakedAmountPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>, staker: string]
      /**
       * {uint64}new 'entry time' in seconds of stake add.
       */
      returns: bigint
    }>
    & Record<'removeStake(address,uint64)void' | 'removeStake', {
      argsObj: {
        /**
         * The address of the account removing stake.
         */
        account: string
        /**
         * The amount of stake to be removed.
         */
        amountToUnstake: bigint | number
      }
      argsTuple: [account: string, amountToUnstake: bigint | number]
      returns: void
    }>
    & Record<'payStakers()void' | 'payStakers', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void' | 'goOnline', {
      argsObj: {
        votePK: Uint8Array
        selectionPK: Uint8Array
        stateProofPK: Uint8Array
        voteFirst: bigint | number
        voteLast: bigint | number
        voteKeyDilution: bigint | number
      }
      argsTuple: [votePK: Uint8Array, selectionPK: Uint8Array, stateProofPK: Uint8Array, voteFirst: bigint | number, voteLast: bigint | number, voteKeyDilution: bigint | number]
      returns: void
    }>
    & Record<'goOffline()void' | 'goOffline', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'creatorApp'?: IntegerState
      'validatorID'?: IntegerState
      'poolID'?: IntegerState
      'owner'?: BinaryState
      'manager'?: BinaryState
      'numStakers'?: IntegerState
      'staked'?: IntegerState
      'minAllowedStake'?: IntegerState
      'maxStake'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type StakingPoolSig = keyof StakingPool['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends StakingPoolSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the StakingPool smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends StakingPoolSig> = StakingPool['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the StakingPool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingPoolSig> = StakingPool['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type StakingPoolCreateCalls = (typeof StakingPoolCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type StakingPoolCreateCallParams =
  | (TypedCallParams<'createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type StakingPoolDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: StakingPoolCreateCalls) => StakingPoolCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class StakingPoolCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the StakingPool smart contract using the createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void' as const,
          methodArgs: Array.isArray(args) ? args : [args.creatingContractID, args.validatorID, args.poolID, args.owner, args.manager, args.minAllowedStake, args.maxStakeAllowed],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'gas()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addStake(pay,address)uint64 ABI method
   *
   * Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addStake(pay,address)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.stakedAmountPayment, args.staker],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the removeStake(address,uint64)void ABI method
   *
   * Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidator of the staker / balance changes.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'removeStake(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.account, args.amountToUnstake],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the payStakers()void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static payStakers(args: MethodArgs<'payStakers()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'payStakers()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.votePK, args.selectionPK, args.stateProofPK, args.voteFirst, args.voteLast, args.voteKeyDilution],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the goOffline()void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static goOffline(args: MethodArgs<'goOffline()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'goOffline()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
}

/**
 * A client to make calls to the StakingPool smart contract
 */
export class StakingPoolClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `StakingPoolClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof StakingPool['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the StakingPool smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: StakingPoolDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(StakingPoolCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the StakingPool smart contract using the createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication(uint64,uint64,uint64,address,address,uint64,uint64)void'>, AppCreateCallTransactionResult>(await $this.appClient.create(StakingPoolCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the StakingPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.gas(args, params))
  }

  /**
   * Calls the addStake(pay,address)uint64 ABI method.
   *
   * Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: {uint64}new 'entry time' in seconds of stake add.
   */
  public addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.addStake(args, params))
  }

  /**
   * Calls the removeStake(address,uint64)void ABI method.
   *
   * Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidator of the staker / balance changes.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.removeStake(args, params))
  }

  /**
   * Calls the payStakers()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public payStakers(args: MethodArgs<'payStakers()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.payStakers(args, params))
  }

  /**
   * Calls the goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.goOnline(args, params))
  }

  /**
   * Calls the goOffline()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public goOffline(args: MethodArgs<'goOffline()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(StakingPoolCallFactory.goOffline(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<StakingPool['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get creatorApp() {
        return StakingPoolClient.getIntegerState(state, 'creatorApp')
      },
      get validatorID() {
        return StakingPoolClient.getIntegerState(state, 'validatorID')
      },
      get poolID() {
        return StakingPoolClient.getIntegerState(state, 'poolID')
      },
      get owner() {
        return StakingPoolClient.getBinaryState(state, 'owner')
      },
      get manager() {
        return StakingPoolClient.getBinaryState(state, 'manager')
      },
      get numStakers() {
        return StakingPoolClient.getIntegerState(state, 'numStakers')
      },
      get staked() {
        return StakingPoolClient.getIntegerState(state, 'staked')
      },
      get minAllowedStake() {
        return StakingPoolClient.getIntegerState(state, 'minAllowedStake')
      },
      get maxStake() {
        return StakingPoolClient.getIntegerState(state, 'maxStake')
      },
    }
  }

  public compose(): StakingPoolComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      gas(args: MethodArgs<'gas()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.gas(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addStake(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.removeStake(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      payStakers(args: MethodArgs<'payStakers()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.payStakers(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.goOnline(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      goOffline(args: MethodArgs<'goOffline()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.goOffline(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as StakingPoolComposer
  }
}
export type StakingPoolComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(args: MethodArgs<'gas()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'gas()void'>]>

  /**
   * Calls the addStake(pay,address)uint64 ABI method.
   *
   * Adds stake to the given account.Can ONLY be called by the validator contract that created usMust receive payment from the validator contract for amount being staked.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addStake(args: MethodArgs<'addStake(pay,address)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'addStake(pay,address)uint64'>]>

  /**
   * Calls the removeStake(address,uint64)void ABI method.
   *
   * Removes stake on behalf of a particular staker.  Also notifies the validator contract for this poolsvalidator of the staker / balance changes.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  removeStake(args: MethodArgs<'removeStake(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'removeStake(address,uint64)void'>]>

  /**
   * Calls the payStakers()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  payStakers(args: MethodArgs<'payStakers()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'payStakers()void'>]>

  /**
   * Calls the goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  goOnline(args: MethodArgs<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'goOnline(byte[],byte[],byte[],uint64,uint64,uint64)void'>]>

  /**
   * Calls the goOffline()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  goOffline(args: MethodArgs<'goOffline()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, MethodReturn<'goOffline()void'>]>

  /**
   * Makes a clear_state call to an existing instance of the StakingPool smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): StakingPoolComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): StakingPoolComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<StakingPoolComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<StakingPoolComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type StakingPoolComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type StakingPoolComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
