/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication(uint64)void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getNumValidators()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addPool(uint64)(uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getPoolAppID((uint64,uint64))uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "addStake(pay,uint64)(uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "stakeUpdatedViaRewards((uint64,uint64),uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "stakeRemoved((uint64,uint64),address,uint64,bool)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "findPoolForStaker(uint64,address,uint64)(uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "numValidators": {
          "type": "uint64",
          "key": "numV"
        },
        "StakingPoolTemplateAppID": {
          "type": "uint64",
          "key": "poolTemplateAppID"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 2
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDkKCi8vIFRoaXMgVEVBTCB3YXMgZ2VuZXJhdGVkIGJ5IFRFQUxTY3JpcHQgdjAuODAuMQovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCBjYWxsX05vT3AgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBjcmVhdGVfTm9PcCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVECgpOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCl2b2lkCmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIHBvb2xUZW1wbGF0ZUFwcElEOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbihwb29sVGVtcGxhdGVBcHBJRDogdWludDY0KTogdm9pZApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDEgMAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc5CgkvLyB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgPSAwCglieXRlIDB4NmU3NTZkNTYgLy8gIm51bVYiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MAoJLy8gdGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUgPSBwb29sVGVtcGxhdGVBcHBJRAoJYnl0ZSAweDcwNmY2ZjZjNTQ2NTZkNzA2YzYxNzQ2NTQxNzA3MDQ5NDQgLy8gInBvb2xUZW1wbGF0ZUFwcElEIgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xUZW1wbGF0ZUFwcElEOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIGdhcygpdm9pZAphYmlfcm91dGVfZ2FzOgoJLy8gZXhlY3V0ZSBnYXMoKXZvaWQKCWNhbGxzdWIgZ2FzCglpbnQgMQoJcmV0dXJuCgovLyBnYXMoKTogdm9pZAovLwovLyBnYXMgaXMgYSBkdW1teSBuby1vcCBjYWxsIHRoYXQgY2FuIGJlIHVzZWQgdG8gcG9vbC11cCByZXNvdXJjZSByZWZlcmVuY2VzIGFuZCBvcGNvZGUgY29zdApnYXM6Cglwcm90byAwIDAKCXJldHN1YgoKLy8gZ2V0TnVtVmFsaWRhdG9ycygpdWludDY0CmFiaV9yb3V0ZV9nZXROdW1WYWxpZGF0b3JzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldE51bVZhbGlkYXRvcnMoKXVpbnQ2NAoJY2FsbHN1YiBnZXROdW1WYWxpZGF0b3JzCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0TnVtVmFsaWRhdG9ycygpOiB1aW50NjQKLy8KLy8gUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgdmFsaWRhdG9ycwpnZXROdW1WYWxpZGF0b3JzOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAwCgkvLyByZXR1cm4gdGhpcy5udW1WYWxpZGF0b3JzLnZhbHVlOwoJYnl0ZSAweDZlNzU2ZDU2IC8vICJudW1WIgoJYXBwX2dsb2JhbF9nZXQKCXJldHN1YgoKLy8gZ2V0VmFsaWRhdG9ySW5mbyh1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LCh1aW50MTYsdWludDMyLGFkZHJlc3MsdWludDgsdWludDE2KSwodWludDE2LHVpbnQ2NCx1aW50NjQpLCh1aW50MTYsYnl0ZVszMl0pWzEyXSwodWludDE2LHVpbnQ2NCx1aW50MTYsdWludDY0KVs0OF0pCmFiaV9yb3V0ZV9nZXRWYWxpZGF0b3JJbmZvOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyB2YWxpZGF0b3JJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBnZXRWYWxpZGF0b3JJbmZvKHVpbnQ2NCkodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpLCh1aW50MTYsdWludDY0LHVpbnQ2NCksKHVpbnQxNixieXRlWzMyXSlbMTJdLCh1aW50MTYsdWludDY0LHVpbnQxNix1aW50NjQpWzQ4XSkKCWNhbGxzdWIgZ2V0VmFsaWRhdG9ySW5mbwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldFZhbGlkYXRvckluZm8odmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklEKTogVmFsaWRhdG9ySW5mbwpnZXRWYWxpZGF0b3JJbmZvOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA1CgkvLyByZXR1cm4gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZTsKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWNvbmNhdAoJYm94X2dldAoJYXNzZXJ0CglyZXRzdWIKCi8vIGdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpCmFiaV9yb3V0ZV9nZXRWYWxpZGF0b3JDb25maWc6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIHZhbGlkYXRvcklEOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpCgljYWxsc3ViIGdldFZhbGlkYXRvckNvbmZpZwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldFZhbGlkYXRvckNvbmZpZyh2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQpOiBWYWxpZGF0b3JDb25maWcKZ2V0VmFsaWRhdG9yQ29uZmlnOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEwCgkvLyByZXR1cm4gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5Db25maWc7CglpbnQgODAgLy8gaGVhZE9mZnNldAoJaW50IDQxCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglyZXRzdWIKCi8vIGFkZFZhbGlkYXRvcihhZGRyZXNzLGFkZHJlc3MsdWludDY0LCh1aW50MTYsdWludDMyLGFkZHJlc3MsdWludDgsdWludDE2KSl1aW50NjQKYWJpX3JvdXRlX2FkZFZhbGlkYXRvcjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gY29uZmlnOiAodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWR1cAoJbGVuCglpbnQgNDEKCT09Cglhc3NlcnQKCgkvLyBuZmRBcHBJRDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gbWFuYWdlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIG93bmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhZGRWYWxpZGF0b3IoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCwodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikpdWludDY0CgljYWxsc3ViIGFkZFZhbGlkYXRvcgoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFkZFZhbGlkYXRvcihvd25lcjogQWRkcmVzcywgbWFuYWdlcjogQWRkcmVzcywgbmZkQXBwSUQ6IHVpbnQ2NCwgY29uZmlnOiBWYWxpZGF0b3JDb25maWcpOiB1aW50NjQKLy8KLy8gQWRkcyBhIG5ldyB2YWxpZGF0b3IKLy8gQHBhcmFtIG93bmVyIFRoZSBhY2NvdW50IChwcmVzdW1hYmx5IGNvbGQtd2FsbGV0KSB0aGF0IG93bnMgdGhlIHZhbGlkYXRvciBzZXQKLy8gQHBhcmFtIG1hbmFnZXIgVGhlIGFjY291bnQgdGhhdCBtYW5hZ2VzIHRoZSBwb29sIHBhcnQuIGtleXMgYW5kIHRyaWdnZXJzIHBheW91dHMuICBOb3JtYWxseSBhIGhvdC13YWxsZXQgYXMgbm9kZSBzaWRlY2FyIG5lZWRzIHRoZSBrZXlzCi8vIEBwYXJhbSBuZmRBcHBJRCBPcHRpb25hbCBORkQgQXBwIElEIGxpbmtpbmcgdG8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZCAtIHdoZXJlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2YWxpZGF0b3IgYW5kIHRoZWlyIHBvb2xzIGNhbiBiZSBmb3VuZC4KLy8gQHBhcmFtIGNvbmZpZyBWYWxpZGF0b3JDb25maWcgc3RydWN0CmFkZFZhbGlkYXRvcjoKCXByb3RvIDQgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwCgkvLyBhc3NlcnQob3duZXIgIT09IEFkZHJlc3MuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMQoJLy8gYXNzZXJ0KG1hbmFnZXIgIT09IEFkZHJlc3MuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gbWFuYWdlcjogQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzCgkvLyB0aGlzLnZhbGlkYXRlQ29uZmlnKGNvbmZpZykKCWZyYW1lX2RpZyAtNCAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJY2FsbHN1YiB2YWxpZGF0ZUNvbmZpZwoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNgoJLy8gdmFsaWRhdG9ySUQgPSB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgKyAxCglieXRlIDB4NmU3NTZkNTYgLy8gIm51bVYiCglhcHBfZ2xvYmFsX2dldAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMCAvLyB2YWxpZGF0b3JJRDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI3CgkvLyB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgPSB2YWxpZGF0b3JJRAoJYnl0ZSAweDZlNzU2ZDU2IC8vICJudW1WIgoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjkKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkuY3JlYXRlKCkKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklEOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJaW50IDE1MDcKCWJveF9jcmVhdGUKCXBvcAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMAoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5JRCA9IHZhbGlkYXRvcklECglpbnQgMAoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMQoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5Pd25lciA9IG93bmVyCglpbnQgOCAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gb3duZXI6IEFkZHJlc3MKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklEOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzIKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkudmFsdWUuTWFuYWdlciA9IG1hbmFnZXIKCWludCA0MCAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gbWFuYWdlcjogQWRkcmVzcwoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMwoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5ORkRGb3JJbmZvID0gbmZkQXBwSUQKCWludCA3MiAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gbmZkQXBwSUQ6IHVpbnQ2NAoJaXRvYgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIDAgLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNAoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5Db25maWcgPSBjb25maWcKCWludCA4MCAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTQgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAwIC8vIHZhbGlkYXRvcklEOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzYKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkudmFsdWUuTm9kZXNbMF0uTmFtZSA9ICdmb28nCglpbnQgMTQxCglieXRlIDB4NjY2ZjZmIC8vICJmb28iCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJRDogdWludDY0CglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM3CgkvLyByZXR1cm4gdmFsaWRhdG9ySUQ7CglmcmFtZV9kaWcgMCAvLyB2YWxpZGF0b3JJRDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCi8vIGFkZFBvb2wodWludDY0KSh1aW50NjQsdWludDY0KQphYmlfcm91dGVfYWRkUG9vbDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYWRkUG9vbCh1aW50NjQpKHVpbnQ2NCx1aW50NjQpCgljYWxsc3ViIGFkZFBvb2wKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhZGRQb29sKHZhbGlkYXRvcklEOiBWYWxpZGF0b3JJRCk6IFZhbGlkYXRvclBvb2xLZXkKLy8KLy8gQWRkcyBhIG5ldyBwb29sIHRvIGEgdmFsaWRhdG9yJ3MgcG9vbCBzZXQsIHJldHVybmluZyB0aGUgJ2tleScgdG8gcmVmZXJlbmNlIHRoZSBwb29sIGluIHRoZSBmdXR1cmUgZm9yIHN0YWtpbmcsIGV0Yy4KYWRkUG9vbDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDIKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDMKCS8vIGFzc2VydCh0aGlzLlZhbGlkYXRvckxpc3QodmFsaWRhdG9ySUQpLmV4aXN0cykKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDUKCS8vIG93bmVyID0gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5Pd25lcgoJaW50IDggLy8gaGVhZE9mZnNldAoJaW50IDMyCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9idXJ5IDAgLy8gb3duZXI6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDYKCS8vIG1hbmFnZXIgPSB0aGlzLlZhbGlkYXRvckxpc3QodmFsaWRhdG9ySUQpLnZhbHVlLk1hbmFnZXIKCWludCA0MCAvLyBoZWFkT2Zmc2V0CglpbnQgMzIKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWZyYW1lX2J1cnkgMSAvLyBtYW5hZ2VyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTQ5CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBvd25lciB8fCB0aGlzLnR4bi5zZW5kZXIgPT09IG1hbmFnZXIpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMCAvLyBvd25lcjogYWRkcmVzcwoJPT0KCWR1cAoJYm56IHNraXBfb3IwCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMSAvLyBtYW5hZ2VyOiBhZGRyZXNzCgk9PQoJfHwKCnNraXBfb3IwOgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTUxCgkvLyBudW1Qb29scyA9IHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkudmFsdWUuU3RhdGUuTnVtUG9vbHMKCWludCAxMjEKCWludCAyCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDIgLy8gbnVtUG9vbHM6IHVpbnQxNgoKCS8vIGlmMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE1MgoJLy8gKG51bVBvb2xzIGFzIHVpbnQ2NCkgPj0gTUFYX1BPT0xTCglmcmFtZV9kaWcgMiAvLyBudW1Qb29sczogdWludDE2CglpbnQgNDgKCT49CglieiBpZjBfZW5kCgoJLy8gaWYwX2NvbnNlcXVlbnQKCWVyciAvLyAnYWxyZWFkeSBhdCBtYXggcG9vbCBzaXplJwoKaWYwX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE1NQoJLy8gbnVtUG9vbHMgKz0gMQoJZnJhbWVfZGlnIDIgLy8gbnVtUG9vbHM6IHVpbnQxNgoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBudW1Qb29sczogdWludDE2CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTU4CgkvLyBzZW5kQXBwQ2FsbCh7CgkvLyAgICAgICAgICAgICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5Ob09wLAoJLy8gICAgICAgICAgICAgYXBwcm92YWxQcm9ncmFtOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmFwcHJvdmFsUHJvZ3JhbSwKCS8vICAgICAgICAgICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmNsZWFyU3RhdGVQcm9ncmFtLAoJLy8gICAgICAgICAgICAgZ2xvYmFsTnVtVWludDogQXBwbGljYXRpb24uZnJvbUlEKHRoaXMuU3Rha2luZ1Bvb2xUZW1wbGF0ZUFwcElELnZhbHVlKS5nbG9iYWxOdW1VaW50LAoJLy8gICAgICAgICAgICAgZ2xvYmFsTnVtQnl0ZVNsaWNlOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmdsb2JhbE51bUJ5dGVTbGljZSwKCS8vICAgICAgICAgICAgIGV4dHJhUHJvZ3JhbVBhZ2VzOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmV4dHJhUHJvZ3JhbVBhZ2VzLAoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25BcmdzOiBbCgkvLyAgICAgICAgICAgICAgICAgbWV0aG9kKCdjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3Mpdm9pZCcpLAoJLy8gICAgICAgICAgICAgICAgIGl0b2IodGhpcy5hcHAuaWQpLAoJLy8gICAgICAgICAgICAgICAgIGl0b2IodmFsaWRhdG9ySUQpLAoJLy8gICAgICAgICAgICAgICAgIGl0b2IobnVtUG9vbHMgYXMgdWludDY0KSwKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyh0aGlzLlZhbGlkYXRvckxpc3QodmFsaWRhdG9ySUQpLnZhbHVlLk93bmVyKSwKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyh0aGlzLlZhbGlkYXRvckxpc3QodmFsaWRhdG9ySUQpLnZhbHVlLk1hbmFnZXIpLAoJLy8gICAgICAgICAgICAgXSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTU5CgkvLyBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5Ob09wCglpbnQgMCAvLyBOb09wCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE2MAoJLy8gYXBwcm92YWxQcm9ncmFtOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmFwcHJvdmFsUHJvZ3JhbQoJYnl0ZSAweDcwNmY2ZjZjNTQ2NTZkNzA2YzYxNzQ2NTQxNzA3MDQ5NDQgLy8gInBvb2xUZW1wbGF0ZUFwcElEIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFwcHJvdmFsUHJvZ3JhbQoJcG9wCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE2MQoJLy8gY2xlYXJTdGF0ZVByb2dyYW06IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLlN0YWtpbmdQb29sVGVtcGxhdGVBcHBJRC52YWx1ZSkuY2xlYXJTdGF0ZVByb2dyYW0KCWJ5dGUgMHg3MDZmNmY2YzU0NjU2ZDcwNmM2MTc0NjU0MTcwNzA0OTQ0IC8vICJwb29sVGVtcGxhdGVBcHBJRCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBDbGVhclN0YXRlUHJvZ3JhbQoJcG9wCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTYyCgkvLyBnbG9iYWxOdW1VaW50OiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmdsb2JhbE51bVVpbnQKCWJ5dGUgMHg3MDZmNmY2YzU0NjU2ZDcwNmM2MTc0NjU0MTcwNzA0OTQ0IC8vICJwb29sVGVtcGxhdGVBcHBJRCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBHbG9iYWxOdW1VaW50Cglwb3AKCWl0eG5fZmllbGQgR2xvYmFsTnVtVWludAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE2MwoJLy8gZ2xvYmFsTnVtQnl0ZVNsaWNlOiBBcHBsaWNhdGlvbi5mcm9tSUQodGhpcy5TdGFraW5nUG9vbFRlbXBsYXRlQXBwSUQudmFsdWUpLmdsb2JhbE51bUJ5dGVTbGljZQoJYnl0ZSAweDcwNmY2ZjZjNTQ2NTZkNzA2YzYxNzQ2NTQxNzA3MDQ5NDQgLy8gInBvb2xUZW1wbGF0ZUFwcElEIgoJYXBwX2dsb2JhbF9nZXQKCWFwcF9wYXJhbXNfZ2V0IEFwcEdsb2JhbE51bUJ5dGVTbGljZQoJcG9wCglpdHhuX2ZpZWxkIEdsb2JhbE51bUJ5dGVTbGljZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE2NAoJLy8gZXh0cmFQcm9ncmFtUGFnZXM6IEFwcGxpY2F0aW9uLmZyb21JRCh0aGlzLlN0YWtpbmdQb29sVGVtcGxhdGVBcHBJRC52YWx1ZSkuZXh0cmFQcm9ncmFtUGFnZXMKCWJ5dGUgMHg3MDZmNmY2YzU0NjU2ZDcwNmM2MTc0NjU0MTcwNzA0OTQ0IC8vICJwb29sVGVtcGxhdGVBcHBJRCIKCWFwcF9nbG9iYWxfZ2V0CglhcHBfcGFyYW1zX2dldCBBcHBFeHRyYVByb2dyYW1QYWdlcwoJcG9wCglpdHhuX2ZpZWxkIEV4dHJhUHJvZ3JhbVBhZ2VzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTY1CgkvLyBhcHBsaWNhdGlvbkFyZ3M6IFsKCS8vICAgICAgICAgICAgICAgICBtZXRob2QoJ2NyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkJyksCgkvLyAgICAgICAgICAgICAgICAgaXRvYih0aGlzLmFwcC5pZCksCgkvLyAgICAgICAgICAgICAgICAgaXRvYih2YWxpZGF0b3JJRCksCgkvLyAgICAgICAgICAgICAgICAgaXRvYihudW1Qb29scyBhcyB1aW50NjQpLAoJLy8gICAgICAgICAgICAgICAgIHJhd0J5dGVzKHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkudmFsdWUuT3duZXIpLAoJLy8gICAgICAgICAgICAgICAgIHJhd0J5dGVzKHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkudmFsdWUuTWFuYWdlciksCgkvLyAgICAgICAgICAgICBdCgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCXR4bmEgQXBwbGljYXRpb25zIDAKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDIgLy8gbnVtUG9vbHM6IHVpbnQxNgoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWludCA4IC8vIGhlYWRPZmZzZXQKCWludCAzMgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklEOiBWYWxpZGF0b3JJRAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWludCA0MCAvLyBoZWFkT2Zmc2V0CglpbnQgMzIKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE3NQoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5TdGF0ZS5OdW1Qb29scyA9IG51bVBvb2xzCglpbnQgMTIxCglmcmFtZV9kaWcgMiAvLyBudW1Qb29sczogdWludDE2CglpdG9iCglleHRyYWN0IDYgMgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHZhbGlkYXRvcklEOiBWYWxpZGF0b3JJRAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE3OAoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHZhbGlkYXRvcklEKS52YWx1ZS5Qb29sc1tudW1Qb29scyAtIDFdLlBvb2xBcHBJRCA9IHRoaXMuaXR4bi5jcmVhdGVkQXBwbGljYXRpb25JRC5pZAoJaW50IDU0NyAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgMiAvLyBudW1Qb29sczogdWludDE2CglpbnQgMQoJLQoJaW50IDIwCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludCAyIC8vIGhlYWRPZmZzZXQKCSsKCWl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKCWl0b2IKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxODEKCS8vIHJldHVybiB7IElEOiB2YWxpZGF0b3JJRCwgUG9vbElEOiBudW1Qb29scyBhcyB1aW50NjQgfTsKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWZyYW1lX2RpZyAyIC8vIG51bVBvb2xzOiB1aW50MTYKCWl0b2IKCWNvbmNhdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gZ2V0UG9vbEFwcElEKCh1aW50NjQsdWludDY0KSl1aW50NjQKYWJpX3JvdXRlX2dldFBvb2xBcHBJRDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gcG9vbEtleTogKHVpbnQ2NCx1aW50NjQpCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDE2Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnZXRQb29sQXBwSUQoKHVpbnQ2NCx1aW50NjQpKXVpbnQ2NAoJY2FsbHN1YiBnZXRQb29sQXBwSUQKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBnZXRQb29sQXBwSUQocG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSk6IHVpbnQ2NApnZXRQb29sQXBwSUQ6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxODUKCS8vIHJldHVybiB0aGlzLlZhbGlkYXRvckxpc3QocG9vbEtleS5JRCkudmFsdWUuUG9vbHNbcG9vbEtleS5Qb29sSUQgLSAxXS5Qb29sQXBwSUQ7CglpbnQgNTQ3IC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDEKCS0KCWludCAyMAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnQgMiAvLyBoZWFkT2Zmc2V0CgkrCglpbnQgOAoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglyZXRzdWIKCi8vIGFkZFN0YWtlKHBheSx1aW50NjQpKHVpbnQ2NCx1aW50NjQpCmFiaV9yb3V0ZV9hZGRTdGFrZToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gdmFsaWRhdG9ySUQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhZGRTdGFrZShwYXksdWludDY0KSh1aW50NjQsdWludDY0KQoJY2FsbHN1YiBhZGRTdGFrZQoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFkZFN0YWtlKHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4biwgdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklEKTogVmFsaWRhdG9yUG9vbEtleQovLwovLyBBZGRzIHN0YWtlIHRvIGEgdmFsaWRhdG9yIHBvb2wuCi8vCi8vIEBwYXJhbSB7UGF5VHhufSBzdGFrZWRBbW91bnRQYXltZW50IC0gcGF5bWVudCBjb21pbmcgZnJvbSBzdGFrZXIgdG8gcGxhY2UgaW50byBhIHBvb2wKLy8gQHBhcmFtIHtWYWxpZGF0b3JJRH0gdmFsaWRhdG9ySUQgLSBUaGUgSUQgb2YgdGhlIHZhbGlkYXRvci4KLy8gQHJldHVybnMge1ZhbGlkYXRvclBvb2xLZXl9IC0gVGhlIGtleSBvZiB0aGUgdmFsaWRhdG9yIHBvb2wuCmFkZFN0YWtlOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE5NgoJLy8gc3Rha2VyID0gdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglmcmFtZV9idXJ5IDAgLy8gc3Rha2VyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTk5CgkvLyB2ZXJpZnlQYXlUeG4oc3Rha2VkQW1vdW50UGF5bWVudCwgewoJLy8gICAgICAgICAgICAgc2VuZGVyOiBzdGFrZXIsCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgfSkKCS8vIHZlcmlmeSBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJZnJhbWVfZGlnIDAgLy8gc3Rha2VyOiBhZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VkQW1vdW50UGF5bWVudDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMDQKCS8vIHBvb2xLZXkgPSB0aGlzLmZpbmRQb29sRm9yU3Rha2VyKHZhbGlkYXRvcklELCBzdGFrZXIsIHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50KQoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMCAvLyBzdGFrZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWNhbGxzdWIgZmluZFBvb2xGb3JTdGFrZXIKCWZyYW1lX2J1cnkgMSAvLyBwb29sS2V5OiAodWludDY0LHVpbnQ2NCkKCgkvLyBpZjFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMDUKCS8vIHBvb2xLZXkuUG9vbElEID09PSAwCglmcmFtZV9kaWcgMSAvLyBwb29sS2V5OiAodWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgOCA4CglidG9pCglpbnQgMAoJPT0KCWJ6IGlmMV9lbmQKCgkvLyBpZjFfY29uc2VxdWVudAoJZXJyIC8vICdObyBwb29sIGF2YWlsYWJsZSB3aXRoIGZyZWUgc3Rha2UuICBWYWxpZGF0b3IgbmVlZHMgdG8gYWRkIGFub3RoZXIgcG9vbCcKCmlmMV9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMTEKCS8vIHRoaXMudXBkYXRlU3Rha2VyUG9vbFNldChzdGFrZXIsIHBvb2xLZXkpCglmcmFtZV9kaWcgMSAvLyBwb29sS2V5OiAodWludDY0LHVpbnQ2NCkKCWZyYW1lX2RpZyAwIC8vIHN0YWtlcjogYWRkcmVzcwoJY2FsbHN1YiB1cGRhdGVTdGFrZXJQb29sU2V0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjEyCgkvLyBpbmNyZWFzZU9wY29kZUJ1ZGdldCgpCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJaW50IDAKCWl0eG5fZmllbGQgRmVlCglieXRlIGI2NCBDb0VCIC8vICNwcmFnbWEgdmVyc2lvbiAxMDsgaW50IDEKCWR1cAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCWludCBEZWxldGVBcHBsaWNhdGlvbgoJaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjEzCgkvLyB0aGlzLmNhbGxQb29sQWRkU3Rha2Uoc3Rha2VkQW1vdW50UGF5bWVudCwgcG9vbEtleSkKCWZyYW1lX2RpZyAxIC8vIHBvb2xLZXk6ICh1aW50NjQsdWludDY0KQoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4bgoJY2FsbHN1YiBjYWxsUG9vbEFkZFN0YWtlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjE0CgkvLyByZXR1cm4gcG9vbEtleTsKCWZyYW1lX2RpZyAxIC8vIHBvb2xLZXk6ICh1aW50NjQsdWludDY0KQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCksdWludDY0KXZvaWQKYWJpX3JvdXRlX3N0YWtlVXBkYXRlZFZpYVJld2FyZHM6CgkvLyBhbW91bnRUb0FkZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcG9vbEtleTogKHVpbnQ2NCx1aW50NjQpCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDE2Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKCh1aW50NjQsdWludDY0KSx1aW50NjQpdm9pZAoJY2FsbHN1YiBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzCglpbnQgMQoJcmV0dXJuCgovLyBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXksIGFtb3VudFRvQWRkOiB1aW50NjQpOiB2b2lkCi8vCi8vIHN0YWtlVXBkYXRlZFZpYVJld2FyZHMgaXMgY2FsbGVkIGJ5IFN0YWtpbmcgUG9vbHMgdG8gaW5mb3JtIHRoZSB2YWxpZGF0b3IgKHVzKSB0aGF0IGEgcGFydGljdWxhciBhbW91bnQgb2YgdG90YWwgc3Rha2UgaGFzIGJlZW4gcmVtb3ZlZAovLyBmcm9tIHRoZSBzcGVjaWZpZWQgcG9vbC4gIFRoaXMgaXMgdXNlZCB0byB1cGRhdGUgdGhlIHN0YXRzIHdlIGhhdmUgaW4gb3VyIFBvb2xJbmZvIHN0b3JhZ2UuCi8vIFRoZSBjYWxsaW5nIEFwcCBJRCBpcyB2YWxpZGF0ZWQgYWdhaW5zdCBvdXIgcG9vbCBsaXN0IGFzIHdlbGwuCi8vIEBwYXJhbSBwb29sS2V5IC0gVmFsaWRhdG9yUG9vbEtleSB0eXBlIC0gW3ZhbGlkYXRvcklELCBQb29sSURdIGNvbXBvdW5kIHR5cGUKLy8gQHBhcmFtIGFtb3VudFRvQWRkCnN0YWtlVXBkYXRlZFZpYVJld2FyZHM6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIyNQoJLy8gYXNzZXJ0KHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS5leGlzdHMpCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMjYKCS8vIGFzc2VydCgocG9vbEtleS5Qb29sSUQgYXMgdWludDY0KSA8IDIgKiogMTYpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludCAyCglpbnQgMTYKCWV4cAoJPAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjI3CgkvLyBhc3NlcnQocG9vbEtleS5Qb29sSUQgPiAwICYmIChwb29sS2V5LlBvb2xJRCBhcyB1aW50MTYpIDw9IHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5TdGF0ZS5OdW1Qb29scykKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDAKCT4KCWR1cAoJYnogc2tpcF9hbmQwCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludCAxMjEKCWludCAyCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCTw9CgkmJgoKc2tpcF9hbmQwOgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjMwCgkvLyBwb29sQXBwSUQgPSB0aGlzLlZhbGlkYXRvckxpc3QocG9vbEtleS5JRCkudmFsdWUuUG9vbHNbcG9vbEtleS5Qb29sSUQgLSAxXS5Qb29sQXBwSUQKCWludCA1NDcgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnQgMQoJLQoJaW50IDIwCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludCAyIC8vIGhlYWRPZmZzZXQKCSsKCWludCA4CglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2J1cnkgMCAvLyBwb29sQXBwSUQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzMgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gQXBwbGljYXRpb24uZnJvbUlEKHBvb2xBcHBJRCkuYWRkcmVzcykKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAwIC8vIHBvb2xBcHBJRDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzQKCS8vIGFzc2VydChwb29sS2V5LklEID09PSAoQXBwbGljYXRpb24uZnJvbUlEKHBvb2xBcHBJRCkuZ2xvYmFsU3RhdGUoJ3ZhbGlkYXRvcklEJykgYXMgdWludDY0KSkKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElEOiB1aW50NjQKCWJ5dGUgMHg3NjYxNmM2OTY0NjE3NDZmNzI0OTQ0IC8vICJ2YWxpZGF0b3JJRCIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglhc3NlcnQKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzUKCS8vIGFzc2VydChwb29sS2V5LlBvb2xJRCA9PT0gKEFwcGxpY2F0aW9uLmZyb21JRChwb29sQXBwSUQpLmdsb2JhbFN0YXRlKCdwb29sSUQnKSBhcyB1aW50NjQpKQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSUQ6IHVpbnQ2NAoJYnl0ZSAweDcwNmY2ZjZjNDk0NCAvLyAicG9vbElEIgoJYXBwX2dsb2JhbF9nZXRfZXgKCWFzc2VydAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzOAoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHBvb2xLZXkuSUQpLnZhbHVlLlBvb2xzW3Bvb2xLZXkuUG9vbElEIC0gMV0uVG90YWxBbGdvU3Rha2VkICs9IGFtb3VudFRvQWRkCglpbnQgNTQ3IC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDEKCS0KCWludCAyMAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnQgMTIgLy8gaGVhZE9mZnNldAoJKwoJaW50IDU0NyAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludCAxCgktCglpbnQgMjAKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50IDEyIC8vIGhlYWRPZmZzZXQKCSsKCWludCA4CglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnRUb0FkZDogdWludDY0CgkrCglpdG9iCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzkKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5TdGF0ZS5Ub3RhbEFsZ29TdGFrZWQgKz0gYW1vdW50VG9BZGQKCWludCAxMzEKCWR1cAoJaW50IDgKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudFRvQWRkOiB1aW50NjQKCSsKCWl0b2IKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsdWludDY0LGJvb2wpdm9pZAphYmlfcm91dGVfc3Rha2VSZW1vdmVkOgoJLy8gc3Rha2VyUmVtb3ZlZDogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAxCgk9PQoJYXNzZXJ0CglpbnQgMAoJZ2V0Yml0CgoJLy8gYW1vdW50UmVtb3ZlZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gc3Rha2VyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gcG9vbEtleTogKHVpbnQ2NCx1aW50NjQpCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDE2Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFrZVJlbW92ZWQoKHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsdWludDY0LGJvb2wpdm9pZAoJY2FsbHN1YiBzdGFrZVJlbW92ZWQKCWludCAxCglyZXR1cm4KCi8vIHN0YWtlUmVtb3ZlZChwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5LCBzdGFrZXI6IEFkZHJlc3MsIGFtb3VudFJlbW92ZWQ6IHVpbnQ2NCwgc3Rha2VyUmVtb3ZlZDogYm9vbGVhbik6IHZvaWQKLy8KLy8gc3Rha2VyUmVtb3ZlZCBpcyBjYWxsZWQgYnkgU3Rha2luZyBQb29scyB0byBpbmZvcm0gdGhlIHZhbGlkYXRvciAodXMpIHRoYXQgYSBwYXJ0aWN1bGFyIGFtb3VudCBvZiB0b3RhbCBzdGFrZSBoYXMgYmVlbiByZW1vdmVkCi8vIGZyb20gdGhlIHNwZWNpZmllZCBwb29sLiAgVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgc3RhdHMgd2UgaGF2ZSBpbiBvdXIgUG9vbEluZm8gc3RvcmFnZS4KLy8gVGhlIGNhbGxpbmcgQXBwIElEIGlzIHZhbGlkYXRlZCBhZ2FpbnN0IG91ciBwb29sIGxpc3QgYXMgd2VsbC4KLy8gQHBhcmFtIHBvb2xLZXkgLSBWYWxpZGF0b3JQb29sS2V5IHR5cGUgLSBbdmFsaWRhdG9ySUQsIFBvb2xJRF0gY29tcG91bmQgdHlwZQovLyBAcGFyYW0gc3Rha2VyCi8vIEBwYXJhbSBhbW91bnRSZW1vdmVkCi8vIEBwYXJhbSBzdGFrZXJSZW1vdmVkCnN0YWtlUmVtb3ZlZDoKCXByb3RvIDQgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjUyCgkvLyBhc3NlcnQodGhpcy5WYWxpZGF0b3JMaXN0KHBvb2xLZXkuSUQpLmV4aXN0cykKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI1MwoJLy8gYXNzZXJ0KChwb29sS2V5LlBvb2xJRCBhcyB1aW50NjQpIDwgMiAqKiAxNikKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDIKCWludCAxNgoJZXhwCgk8Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTQKCS8vIGFzc2VydChwb29sS2V5LlBvb2xJRCA+IDAgJiYgKHBvb2xLZXkuUG9vbElEIGFzIHVpbnQxNikgPD0gdGhpcy5WYWxpZGF0b3JMaXN0KHBvb2xLZXkuSUQpLnZhbHVlLlN0YXRlLk51bVBvb2xzKQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnQgMAoJPgoJZHVwCglieiBza2lwX2FuZDEKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDEyMQoJaW50IDIKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJPD0KCSYmCgpza2lwX2FuZDE6Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTcKCS8vIHBvb2xBcHBJRCA9IHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5Qb29sc1twb29sS2V5LlBvb2xJRCAtIDFdLlBvb2xBcHBJRAoJaW50IDU0NyAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludCAxCgktCglpbnQgMjAKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50IDIgLy8gaGVhZE9mZnNldAoJKwoJaW50IDgKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIHBvb2xBcHBJRDogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjU5CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBBcHBsaWNhdGlvbi5mcm9tSUQocG9vbEFwcElEKS5hZGRyZXNzKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElEOiB1aW50NjQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2MQoJLy8gYXNzZXJ0KHBvb2xLZXkuSUQgPT09IChBcHBsaWNhdGlvbi5mcm9tSUQocG9vbEFwcElEKS5nbG9iYWxTdGF0ZSgndmFsaWRhdG9ySUQnKSBhcyB1aW50NjQpKQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSUQ6IHVpbnQ2NAoJYnl0ZSAweDc2NjE2YzY5NjQ2MTc0NmY3MjQ5NDQgLy8gInZhbGlkYXRvcklEIgoJYXBwX2dsb2JhbF9nZXRfZXgKCWFzc2VydAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2MgoJLy8gYXNzZXJ0KHBvb2xLZXkuUG9vbElEID09PSAoQXBwbGljYXRpb24uZnJvbUlEKHBvb2xBcHBJRCkuZ2xvYmFsU3RhdGUoJ3Bvb2xJRCcpIGFzIHVpbnQ2NCkpCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWZyYW1lX2RpZyAwIC8vIHBvb2xBcHBJRDogdWludDY0CglieXRlIDB4NzA2ZjZmNmM0OTQ0IC8vICJwb29sSUQiCglhcHBfZ2xvYmFsX2dldF9leAoJYXNzZXJ0Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjY1CgkvLyB0aGlzLlZhbGlkYXRvckxpc3QocG9vbEtleS5JRCkudmFsdWUuUG9vbHNbcG9vbEtleS5Qb29sSUQgLSAxXS5Ub3RhbEFsZ29TdGFrZWQgLT0gYW1vdW50UmVtb3ZlZAoJaW50IDU0NyAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWludCAxCgktCglpbnQgMjAKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50IDEyIC8vIGhlYWRPZmZzZXQKCSsKCWludCA1NDcgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnQgMQoJLQoJaW50IDIwCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludCAxMiAvLyBoZWFkT2Zmc2V0CgkrCglpbnQgOAoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50UmVtb3ZlZDogdWludDY0CgktCglpdG9iCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjYKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5TdGF0ZS5Ub3RhbEFsZ29TdGFrZWQgLT0gYW1vdW50UmVtb3ZlZAoJaW50IDEzMQoJZHVwCglpbnQgOAoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50UmVtb3ZlZDogdWludDY0CgktCglpdG9iCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBpZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjcKCS8vIHN0YWtlclJlbW92ZWQKCWZyYW1lX2RpZyAtNCAvLyBzdGFrZXJSZW1vdmVkOiBib29sZWFuCglieiBpZjJfZW5kCgoJLy8gaWYyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2OAoJLy8gdGhpcy5WYWxpZGF0b3JMaXN0KHBvb2xLZXkuSUQpLnZhbHVlLlBvb2xzW3Bvb2xLZXkuUG9vbElEIC0gMV0uVG90YWxTdGFrZXJzIC09IDEKCWludCA1NDcgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnQgMQoJLQoJaW50IDIwCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludCAxMCAvLyBoZWFkT2Zmc2V0CgkrCglpbnQgNTQ3IC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDEKCS0KCWludCAyMAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnQgMTAgLy8gaGVhZE9mZnNldAoJKwoJaW50IDIKCWJ5dGUgMHg3NiAvLyAidiIKCWZyYW1lX2RpZyAtMSAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDAgOAoJYnRvaQoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJaW50IDEKCS0KCWl0b2IKCWV4dHJhY3QgNiAyCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjkKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5TdGF0ZS5Ub3RhbFN0YWtlcnMgLT0gMQoJaW50IDEyMwoJZHVwCglpbnQgOAoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglpbnQgMQoJLQoJaXRvYgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjcwCgkvLyB0aGlzLnJlbW92ZUZyb21TdGFrZXJQb29sU2V0KHN0YWtlciwgPFZhbGlkYXRvclBvb2xLZXk+eyBJRDogcG9vbEtleS5JRCwgUG9vbElEOiBwb29sS2V5LlBvb2xJRCB9KQoJZnJhbWVfZGlnIC0xIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCglmcmFtZV9kaWcgLTEgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJY2FsbHN1YiByZW1vdmVGcm9tU3Rha2VyUG9vbFNldAoKaWYyX2VuZDoKCXJldHN1YgoKLy8gZmluZFBvb2xGb3JTdGFrZXIodWludDY0LGFkZHJlc3MsdWludDY0KSh1aW50NjQsdWludDY0KQphYmlfcm91dGVfZmluZFBvb2xGb3JTdGFrZXI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGFtb3VudFRvU3Rha2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHN0YWtlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIHZhbGlkYXRvcklEOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGZpbmRQb29sRm9yU3Rha2VyKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkodWludDY0LHVpbnQ2NCkKCWNhbGxzdWIgZmluZFBvb2xGb3JTdGFrZXIKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBmaW5kUG9vbEZvclN0YWtlcih2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQsIHN0YWtlcjogQWRkcmVzcywgYW1vdW50VG9TdGFrZTogdWludDY0KTogVmFsaWRhdG9yUG9vbEtleQpmaW5kUG9vbEZvclN0YWtlcjoKCXByb3RvIDMgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDMKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzYKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGUgYjY0IENvRUIgLy8gI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50IERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBpZjNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzkKCS8vIHRoaXMuU3Rha2VyUG9vbFNldChzdGFrZXIpLmV4aXN0cwoJYnl0ZSAweDczNzA3MyAvLyAic3BzIgoJZnJhbWVfZGlnIC0yIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCWJ6IGlmM19lbmQKCgkvLyBpZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjgwCgkvLyBwb29sU2V0ID0gY2xvbmUodGhpcy5TdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUpCglieXRlIDB4NzM3MDczIC8vICJzcHMiCglmcmFtZV9kaWcgLTIgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9nZXQKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0KVs0XQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI4MQoJLy8gaSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0Cgpmb3JfMDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI4MQoJLy8gaSA8IHRoaXMuU3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlLmxlbmd0aAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnQgNAoJPAoJYnogZm9yXzBfZW5kCgoJLy8gaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjgyCgkvLyBwb29sU2V0W2ldLklEID09PSB2YWxpZGF0b3JJRAoJZnJhbWVfZGlnIDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQpWzRdCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCAxNgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMAoJKwoJaW50IDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECgk9PQoJYnogaWY0X2VuZAoKCS8vIGlmNF9jb25zZXF1ZW50CgkvLyBpZjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyODUKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJRCkudmFsdWUuUG9vbHNbcG9vbFNldFtpXS5Qb29sSUQgLSAxXS5Ub3RhbEFsZ29TdGFrZWQgKwoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudFRvU3Rha2UgPAoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgTUFYX0FMR09fUEVSX1BPT0wKCWludCA1NDcgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQpWzRdCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCAxNgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgOCAvLyBoZWFkT2Zmc2V0CgkrCglpbnQgOAoJZXh0cmFjdDMKCWJ0b2kKCWludCAxCgktCglpbnQgMjAKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJaW50IDEyIC8vIGhlYWRPZmZzZXQKCSsKCWludCA4CglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50VG9TdGFrZTogdWludDY0CgkrCglpbnQgMjAwMDAwMDAwMDAwMDAKCTwKCWJ6IGlmNV9lbmQKCgkvLyBpZjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mjg5CgkvLyByZXR1cm4gcG9vbFNldFtpXTsKCWZyYW1lX2RpZyAwIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0KVs0XQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnQgMTYKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50IDE2CglleHRyYWN0MwoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKaWY1X2VuZDoKCmlmNF9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyODEKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoJYiBmb3JfMAoKZm9yXzBfZW5kOgoKaWYzX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NQoJLy8gcG9vbHMgPSBjbG9uZSh0aGlzLlZhbGlkYXRvckxpc3QodmFsaWRhdG9ySUQpLnZhbHVlLlBvb2xzKQoJaW50IDU0NyAvLyBoZWFkT2Zmc2V0CglpbnQgOTYwCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglmcmFtZV9idXJ5IDIgLy8gcG9vbHM6ICh1aW50MTYsdWludDY0LHVpbnQxNix1aW50NjQpWzQ4XQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NgoJLy8gaSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDMgLy8gaTogdWludDY0Cgpmb3JfMToKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NgoJLy8gaSA8IE1BWF9QT09MUwoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgNDgKCTwKCWJ6IGZvcl8xX2VuZAoKCS8vIGlmNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NwoJLy8gcG9vbHNbaV0uVG90YWxBbGdvU3Rha2VkICsgYW1vdW50VG9TdGFrZSA8IE1BWF9BTEdPX1BFUl9QT09MCglmcmFtZV9kaWcgMiAvLyBwb29sczogKHVpbnQxNix1aW50NjQsdWludDE2LHVpbnQ2NClbNDhdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCAyMAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMTIgLy8gaGVhZE9mZnNldAoJKwoJaW50IDgKCWV4dHJhY3QzCglidG9pCglmcmFtZV9kaWcgLTMgLy8gYW1vdW50VG9TdGFrZTogdWludDY0CgkrCglpbnQgMjAwMDAwMDAwMDAwMDAKCTwKCWJ6IGlmNl9lbmQKCgkvLyBpZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mjk4CgkvLyByZXR1cm4geyBJRDogdmFsaWRhdG9ySUQsIFBvb2xJRDogaSArIDEgfTsKCWZyYW1lX2RpZyAtMSAvLyB2YWxpZGF0b3JJRDogVmFsaWRhdG9ySUQKCWl0b2IKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWl0b2IKCWNvbmNhdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKaWY2X2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NgoJLy8gaSArPSAxCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDMgLy8gaTogdWludDY0CgliIGZvcl8xCgpmb3JfMV9lbmQ6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDIKCS8vIHJldHVybiB7IElEOiB2YWxpZGF0b3JJRCwgUG9vbElEOiAwIH07CglmcmFtZV9kaWcgLTEgLy8gdmFsaWRhdG9ySUQ6IFZhbGlkYXRvcklECglpdG9iCglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAoJY29uY2F0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyB2YWxpZGF0ZUNvbmZpZyhjb25maWc6IFZhbGlkYXRvckNvbmZpZyk6IHZvaWQKdmFsaWRhdGVDb25maWc6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDcKCS8vIGFzc2VydChjb25maWcuUGF5b3V0RXZlcnlYRGF5cyA+PSBNSU5fUEFZT1VUX0RBWVMgJiYgY29uZmlnLlBheW91dEV2ZXJ5WERheXMgPD0gTUFYX1BBWU9VVF9EQVlTKQoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDAgMgoJYnRvaQoJaW50IDEKCT49CglkdXAKCWJ6IHNraXBfYW5kMgoJZnJhbWVfZGlnIC0xIC8vIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnCglleHRyYWN0IDAgMgoJYnRvaQoJaW50IDMwCgk8PQoJJiYKCnNraXBfYW5kMjoKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMwOAoJLy8gYXNzZXJ0KGNvbmZpZy5QZXJjZW50VG9WYWxpZGF0b3IgPj0gTUlOX1BDVF9UT19WQUxJREFUT1IgJiYgY29uZmlnLlBlcmNlbnRUb1ZhbGlkYXRvciA8PSBNQVhfUENUX1RPX1ZBTElEQVRPUikKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAyIDQKCWJ0b2kKCWludCAxMDAwMAoJPj0KCWR1cAoJYnogc2tpcF9hbmQzCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMiA0CglidG9pCglpbnQgMTAwMDAwCgk8PQoJJiYKCnNraXBfYW5kMzoKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMwOQoJLy8gYXNzZXJ0KGNvbmZpZy5WYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyAhPT0gQWRkcmVzcy56ZXJvQWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCA2IDMyCglnbG9iYWwgWmVyb0FkZHJlc3MKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMTAKCS8vIGFzc2VydChjb25maWcuUG9vbHNQZXJOb2RlID4gMCAmJiBjb25maWcuUG9vbHNQZXJOb2RlIDw9IE1BWF9QT09MU19QRVJfTk9ERSkKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAzOCAxCglidG9pCglpbnQgMAoJPgoJZHVwCglieiBza2lwX2FuZDQKCWZyYW1lX2RpZyAtMSAvLyBjb25maWc6IFZhbGlkYXRvckNvbmZpZwoJZXh0cmFjdCAzOCAxCglidG9pCglpbnQgNAoJPD0KCSYmCgpza2lwX2FuZDQ6Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMTEKCS8vIGFzc2VydChjb25maWcuTWF4Tm9kZXMgPiAwICYmIGNvbmZpZy5NYXhOb2RlcyA8PSBNQVhfTk9ERVMpCglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMzkgMgoJYnRvaQoJaW50IDAKCT4KCWR1cAoJYnogc2tpcF9hbmQ1CglmcmFtZV9kaWcgLTEgLy8gY29uZmlnOiBWYWxpZGF0b3JDb25maWcKCWV4dHJhY3QgMzkgMgoJYnRvaQoJaW50IDEyCgk8PQoJJiYKCnNraXBfYW5kNToKCWFzc2VydAoJcmV0c3ViCgovLyBjYWxsUG9vbEFkZFN0YWtlKHN0YWtlZEFtb3VudFBheW1lbnQ6IFBheVR4biwgcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSk6IHZvaWQKLy8KLy8gQWRkcyBhIHN0YWtlcnMgYW1vdW50IG9mIGFsZ28gdG8gYSB2YWxpZGF0b3IgcG9vbCwgdHJhbnNmZXJpbmcgdGhlIGFsZ28gd2UgcmVjZWl2ZWQgZnJvbSB0aGVtIChhbHJlYWR5IHZlcmlmaWVkCi8vIGJ5IG91ciBjYWxsZXIpIHRvIHRoZSBzdGFraW5nIHBvb2wgYWNjb3VudCwgYW5kIHRoZW4gdGVsbGluZyBpdCBhYm91dCB0aGUgYW1vdW50IGJlaW5nIGFkZCBmb3IgdGhlIHNwZWNpZmllZAovLyBzdGFrZXIuCi8vCi8vIEBwYXJhbSB7UGF5VHhufSBzdGFrZWRBbW91bnRQYXltZW50IC0gcGF5bWVudCBjb21pbmcgZnJvbSBzdGFrZXIgdG8gcGxhY2UgaW50byBhIHBvb2wKLy8gQHBhcmFtIHtWYWxpZGF0b3JQb29sS2V5fSBwb29sS2V5IC0gVGhlIGtleSBvZiB0aGUgdmFsaWRhdG9yIHBvb2wuCi8vIEByZXR1cm5zIHt2b2lkfQpjYWxsUG9vbEFkZFN0YWtlOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMyNAoJLy8gcG9vbEFwcElEID0gdGhpcy5WYWxpZGF0b3JMaXN0KHBvb2xLZXkuSUQpLnZhbHVlLlBvb2xzW3Bvb2xLZXkuUG9vbElEIC0gMV0uUG9vbEFwcElECglpbnQgNTQ3IC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDEKCS0KCWludCAyMAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnQgMiAvLyBoZWFkT2Zmc2V0CgkrCglpbnQgOAoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9idXJ5IDAgLy8gcG9vbEFwcElEOiB1aW50NjQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMjUKCS8vIHByaW9yU3Rha2VycyA9IEFwcGxpY2F0aW9uLmZyb21JRChwb29sQXBwSUQpLmdsb2JhbFN0YXRlKCdudW1TdGFrZXJzJykgYXMgdWludDY0CglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSUQ6IHVpbnQ2NAoJYnl0ZSAweDZlNzU2ZDUzNzQ2MTZiNjU3MjczIC8vICJudW1TdGFrZXJzIgoJYXBwX2dsb2JhbF9nZXRfZXgKCWFzc2VydAoJZnJhbWVfYnVyeSAxIC8vIHByaW9yU3Rha2VyczogdWludDY0CgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzI5CgkvLyBzZW5kTWV0aG9kQ2FsbDxbSW5uZXJQYXltZW50LCBBZGRyZXNzXSwgdWludDY0Pih7CgkvLyAgICAgICAgICAgICBuYW1lOiAnYWRkU3Rha2UnLAoJLy8gICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwbGljYXRpb24uZnJvbUlEKHBvb2xBcHBJRCksCgkvLyAgICAgICAgICAgICBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgICAgICAgICAgeyBhbW91bnQ6IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50LCByZWNlaXZlcjogQXBwbGljYXRpb24uZnJvbUlEKHBvb2xBcHBJRCkuYWRkcmVzcyB9LAoJLy8gICAgICAgICAgICAgICAgIHN0YWtlZEFtb3VudFBheW1lbnQuc2VuZGVyLAoJLy8gICAgICAgICAgICAgXSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzMKCS8vIGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzMKCS8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbi5mcm9tSUQocG9vbEFwcElEKS5hZGRyZXNzCglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSUQ6IHVpbnQ2NAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCglpdHhuX25leHQKCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgImFkZFN0YWtlKHBheSxhZGRyZXNzKXVpbnQ2NCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzMxCgkvLyBhcHBsaWNhdGlvbklEOiBBcHBsaWNhdGlvbi5mcm9tSUQocG9vbEFwcElEKQoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElEOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMzMgoJLy8gbWV0aG9kQXJnczogWwoJLy8gICAgICAgICAgICAgICAgIHsgYW1vdW50OiBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCwgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uLmZyb21JRChwb29sQXBwSUQpLmFkZHJlc3MgfSwKCS8vICAgICAgICAgICAgICAgICBzdGFrZWRBbW91bnRQYXltZW50LnNlbmRlciwKCS8vICAgICAgICAgICAgIF0KCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludCAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWJ0b2kKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzgKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5Qb29sc1twb29sS2V5LlBvb2xJRCAtIDFdLlRvdGFsU3Rha2VycyA9IEFwcGxpY2F0aW9uLmZyb21JRCgKCS8vICAgICAgICAgICAgIHBvb2xBcHBJRAoJLy8gICAgICAgICApLmdsb2JhbFN0YXRlKCdudW1TdGFrZXJzJykgYXMgdWludDY0CglpbnQgNTQ3IC8vIGhlYWRPZmZzZXQKCWZyYW1lX2RpZyAtMiAvLyBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5CglleHRyYWN0IDggOAoJYnRvaQoJaW50IDEKCS0KCWludCAyMAoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCgkrCglpbnQgMTAgLy8gaGVhZE9mZnNldAoJKwoJZnJhbWVfZGlnIDAgLy8gcG9vbEFwcElEOiB1aW50NjQKCWJ5dGUgMHg2ZTc1NmQ1Mzc0NjE2YjY1NzI3MyAvLyAibnVtU3Rha2VycyIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglhc3NlcnQKCWl0b2IKCWV4dHJhY3QgNiAyCglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNDEKCS8vIHRoaXMuVmFsaWRhdG9yTGlzdChwb29sS2V5LklEKS52YWx1ZS5Qb29sc1twb29sS2V5LlBvb2xJRCAtIDFdLlRvdGFsQWxnb1N0YWtlZCA9IEFwcGxpY2F0aW9uLmZyb21JRCgKCS8vICAgICAgICAgICAgIHBvb2xBcHBJRAoJLy8gICAgICAgICApLmdsb2JhbFN0YXRlKCdzdGFrZWQnKSBhcyB1aW50NjQKCWludCA1NDcgLy8gaGVhZE9mZnNldAoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgOCA4CglidG9pCglpbnQgMQoJLQoJaW50IDIwCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWludCAxMiAvLyBoZWFkT2Zmc2V0CgkrCglmcmFtZV9kaWcgMCAvLyBwb29sQXBwSUQ6IHVpbnQ2NAoJYnl0ZSAweDczNzQ2MTZiNjU2NCAvLyAic3Rha2VkIgoJYXBwX2dsb2JhbF9nZXRfZXgKCWFzc2VydAoJaXRvYgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzQ1CgkvLyB0aGlzLlZhbGlkYXRvckxpc3QocG9vbEtleS5JRCkudmFsdWUuU3RhdGUuVG90YWxTdGFrZXJzICs9CgkvLyAgICAgICAgICAgICAoQXBwbGljYXRpb24uZnJvbUlEKHBvb2xBcHBJRCkuZ2xvYmFsU3RhdGUoJ251bVN0YWtlcnMnKSBhcyB1aW50NjQpIC0gcHJpb3JTdGFrZXJzCglpbnQgMTIzCglkdXAKCWludCA4CglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAwIC8vIHBvb2xBcHBJRDogdWludDY0CglieXRlIDB4NmU3NTZkNTM3NDYxNmI2NTcyNzMgLy8gIm51bVN0YWtlcnMiCglhcHBfZ2xvYmFsX2dldF9leAoJYXNzZXJ0CglmcmFtZV9kaWcgMSAvLyBwcmlvclN0YWtlcnM6IHVpbnQ2NAoJLQoJKwoJaXRvYgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzQ3CgkvLyB0aGlzLlZhbGlkYXRvckxpc3QocG9vbEtleS5JRCkudmFsdWUuU3RhdGUuVG90YWxBbGdvU3Rha2VkICs9IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50CglpbnQgMTMxCglkdXAKCWludCA4CglieXRlIDB4NzYgLy8gInYiCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMSAvLyBzdGFrZWRBbW91bnRQYXltZW50OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJKwoJaXRvYgoJYnl0ZSAweDc2IC8vICJ2IgoJZnJhbWVfZGlnIC0yIC8vIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIHVwZGF0ZVN0YWtlclBvb2xTZXQoc3Rha2VyOiBBZGRyZXNzLCBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5KTogdm9pZAp1cGRhdGVTdGFrZXJQb29sU2V0OgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGlmN19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM1MQoJLy8gIXRoaXMuU3Rha2VyUG9vbFNldChzdGFrZXIpLmV4aXN0cwoJYnl0ZSAweDczNzA3MyAvLyAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCSEKCWJ6IGlmN19lbmQKCgkvLyBpZjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzUyCgkvLyB0aGlzLlN0YWtlclBvb2xTZXQoc3Rha2VyKS5jcmVhdGUoKQoJYnl0ZSAweDczNzA3MyAvLyAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0CglpbnQgNjQKCWJveF9jcmVhdGUKCXBvcAoKaWY3X2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM1NAoJLy8gcG9vbFNldCA9IGNsb25lKHRoaXMuU3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlKQoJYnl0ZSAweDczNzA3MyAvLyAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cglib3hfZ2V0Cglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBwb29sU2V0OiAodWludDY0LHVpbnQ2NClbNF0KCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTUKCS8vIGkgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoKZm9yXzI6CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTUKCS8vIGkgPCB0aGlzLlN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZS5sZW5ndGgKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50IDQKCTwKCWJ6IGZvcl8yX2VuZAoKCS8vIGlmOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM1NgoJLy8gcG9vbFNldFtpXSA9PT0gcG9vbEtleQoJZnJhbWVfZGlnIDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQpWzRdCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCAxNgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMTYKCWV4dHJhY3QzCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJPT0KCWJ6IGlmOF9lbmQKCgkvLyBpZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzU4CgkvLyByZXR1cm47CglyZXRzdWIKCmlmOF9lbmQ6CgkvLyBpZjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNjAKCS8vIHBvb2xTZXRbaV0uSUQgPT09IDAKCWZyYW1lX2RpZyAwIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0KVs0XQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnQgMTYKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50IDAKCSsKCWludCA4CglleHRyYWN0MwoJYnRvaQoJaW50IDAKCT09CglieiBpZjlfZW5kCgoJLy8gaWY5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM2MQoJLy8gdGhpcy5TdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWVbaV0gPSBwb29sS2V5CglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCAxNgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJYnl0ZSAweDczNzA3MyAvLyAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM2MgoJLy8gcmV0dXJuOwoJcmV0c3ViCgppZjlfZW5kOgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzU1CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCWIgZm9yXzIKCmZvcl8yX2VuZDoKCWVyciAvLyAnTm8gZW1wdHkgc2xvdCBhdmFpbGFibGUgaW4gdGhlIHN0YWtlciBwb29sIHNldCcKCi8vIHJlbW92ZUZyb21TdGFrZXJQb29sU2V0KHN0YWtlcjogQWRkcmVzcywgcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSk6IHZvaWQKcmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQ6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzY5CgkvLyBwb29sU2V0ID0gY2xvbmUodGhpcy5TdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUpCglieXRlIDB4NzM3MDczIC8vICJzcHMiCglmcmFtZV9kaWcgLTEgLy8gc3Rha2VyOiBBZGRyZXNzCgljb25jYXQKCWJveF9nZXQKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIHBvb2xTZXQ6ICh1aW50NjQsdWludDY0KVs0XQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM3MAoJLy8gaSA9IDAKCWludCAwCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0Cgpmb3JfMzoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM3MAoJLy8gaSA8IHRoaXMuU3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlLmxlbmd0aAoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnQgNAoJPAoJYnogZm9yXzNfZW5kCgoJLy8gaWYxMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM3MQoJLy8gcG9vbFNldFtpXSA9PT0gcG9vbEtleQoJZnJhbWVfZGlnIDAgLy8gcG9vbFNldDogKHVpbnQ2NCx1aW50NjQpWzRdCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCAxNgoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnQgMTYKCWV4dHJhY3QzCglmcmFtZV9kaWcgLTIgLy8gcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleQoJPT0KCWJ6IGlmMTBfZW5kCgoJLy8gaWYxMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNzIKCS8vIHRoaXMuU3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlW2ldID0geyBJRDogMCwgUG9vbElEOiAwIH0KCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJaW50IDE2CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYnl0ZSAweDczNzA3MyAvLyAic3BzIgoJZnJhbWVfZGlnIC0xIC8vIHN0YWtlcjogQWRkcmVzcwoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM3MwoJLy8gcmV0dXJuOwoJcmV0c3ViCgppZjEwX2VuZDoKCS8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM3MAoJLy8gaSArPSAxCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgliIGZvcl8zCgpmb3JfM19lbmQ6CglyZXRzdWIKCmNyZWF0ZV9Ob09wOgoJbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbih1aW50NjQpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgpjYWxsX05vT3A6CgltZXRob2QgImdhcygpdm9pZCIKCW1ldGhvZCAiZ2V0TnVtVmFsaWRhdG9ycygpdWludDY0IgoJbWV0aG9kICJnZXRWYWxpZGF0b3JJbmZvKHVpbnQ2NCkodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpLCh1aW50MTYsdWludDY0LHVpbnQ2NCksKHVpbnQxNixieXRlWzMyXSlbMTJdLCh1aW50MTYsdWludDY0LHVpbnQxNix1aW50NjQpWzQ4XSkiCgltZXRob2QgImdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQxNix1aW50MzIsYWRkcmVzcyx1aW50OCx1aW50MTYpIgoJbWV0aG9kICJhZGRWYWxpZGF0b3IoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCwodWludDE2LHVpbnQzMixhZGRyZXNzLHVpbnQ4LHVpbnQxNikpdWludDY0IgoJbWV0aG9kICJhZGRQb29sKHVpbnQ2NCkodWludDY0LHVpbnQ2NCkiCgltZXRob2QgImdldFBvb2xBcHBJRCgodWludDY0LHVpbnQ2NCkpdWludDY0IgoJbWV0aG9kICJhZGRTdGFrZShwYXksdWludDY0KSh1aW50NjQsdWludDY0KSIKCW1ldGhvZCAic3Rha2VVcGRhdGVkVmlhUmV3YXJkcygodWludDY0LHVpbnQ2NCksdWludDY0KXZvaWQiCgltZXRob2QgInN0YWtlUmVtb3ZlZCgodWludDY0LHVpbnQ2NCksYWRkcmVzcyx1aW50NjQsYm9vbCl2b2lkIgoJbWV0aG9kICJmaW5kUG9vbEZvclN0YWtlcih1aW50NjQsYWRkcmVzcyx1aW50NjQpKHVpbnQ2NCx1aW50NjQpIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggYWJpX3JvdXRlX2dhcyBhYmlfcm91dGVfZ2V0TnVtVmFsaWRhdG9ycyBhYmlfcm91dGVfZ2V0VmFsaWRhdG9ySW5mbyBhYmlfcm91dGVfZ2V0VmFsaWRhdG9yQ29uZmlnIGFiaV9yb3V0ZV9hZGRWYWxpZGF0b3IgYWJpX3JvdXRlX2FkZFBvb2wgYWJpX3JvdXRlX2dldFBvb2xBcHBJRCBhYmlfcm91dGVfYWRkU3Rha2UgYWJpX3JvdXRlX3N0YWtlVXBkYXRlZFZpYVJld2FyZHMgYWJpX3JvdXRlX3N0YWtlUmVtb3ZlZCBhYmlfcm91dGVfZmluZFBvb2xGb3JTdGFrZXIKCWVycg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDk="
  },
  "contract": {
    "name": "ValidatorRegistry",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "args": [
          {
            "name": "poolTemplateAppID",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "gas",
        "desc": "gas is a dummy no-op call that can be used to pool-up resource references and opcode cost",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getNumValidators",
        "desc": "Returns the current number of validators",
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getValidatorInfo",
        "args": [
          {
            "name": "validatorID",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])"
        }
      },
      {
        "name": "getValidatorConfig",
        "args": [
          {
            "name": "validatorID",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(uint16,uint32,address,uint8,uint16)"
        }
      },
      {
        "name": "addValidator",
        "desc": "Adds a new validator",
        "args": [
          {
            "name": "owner",
            "type": "address",
            "desc": "The account (presumably cold-wallet) that owns the validator set"
          },
          {
            "name": "manager",
            "type": "address",
            "desc": "The account that manages the pool part. keys and triggers payouts.  Normally a hot-wallet as node sidecar needs the keys"
          },
          {
            "name": "nfdAppID",
            "type": "uint64",
            "desc": "Optional NFD App ID linking to information about the validator being added - where information about the validator and their pools can be found."
          },
          {
            "name": "config",
            "type": "(uint16,uint32,address,uint8,uint16)",
            "desc": "ValidatorConfig struct"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "addPool",
        "desc": "Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.",
        "args": [
          {
            "name": "validatorID",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(uint64,uint64)"
        }
      },
      {
        "name": "getPoolAppID",
        "args": [
          {
            "name": "poolKey",
            "type": "(uint64,uint64)"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "addStake",
        "desc": "Adds stake to a validator pool.",
        "args": [
          {
            "name": "stakedAmountPayment",
            "type": "pay",
            "desc": "payment coming from staker to place into a pool"
          },
          {
            "name": "validatorID",
            "type": "uint64",
            "desc": "The ID of the validator."
          }
        ],
        "returns": {
          "type": "(uint64,uint64)",
          "desc": "{ValidatorPoolKey}- The key of the validator pool."
        }
      },
      {
        "name": "stakeUpdatedViaRewards",
        "desc": "stakeUpdatedViaRewards is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.",
        "args": [
          {
            "name": "poolKey",
            "type": "(uint64,uint64)",
            "desc": "ValidatorPoolKey type - [validatorID, PoolID] compound type"
          },
          {
            "name": "amountToAdd",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "stakeRemoved",
        "desc": "stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.",
        "args": [
          {
            "name": "poolKey",
            "type": "(uint64,uint64)",
            "desc": "ValidatorPoolKey type - [validatorID, PoolID] compound type"
          },
          {
            "name": "staker",
            "type": "address"
          },
          {
            "name": "amountRemoved",
            "type": "uint64"
          },
          {
            "name": "stakerRemoved",
            "type": "bool"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "findPoolForStaker",
        "args": [
          {
            "name": "validatorID",
            "type": "uint64"
          },
          {
            "name": "staker",
            "type": "address"
          },
          {
            "name": "amountToStake",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(uint64,uint64)"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the ValidatorRegistry smart contract.
 */
export type ValidatorRegistry = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(uint64)void' | 'createApplication', {
      argsObj: {
        poolTemplateAppID: bigint | number
      }
      argsTuple: [poolTemplateAppID: bigint | number]
      returns: void
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'getNumValidators()uint64' | 'getNumValidators', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])' | 'getValidatorInfo', {
      argsObj: {
        validatorID: bigint | number
      }
      argsTuple: [validatorID: bigint | number]
      returns: [bigint, string, string, bigint, [number, number, string, number, number], [number, bigint, bigint], [[number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array], [number, Uint8Array]], [[number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint], [number, bigint, number, bigint]]]
    }>
    & Record<'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)' | 'getValidatorConfig', {
      argsObj: {
        validatorID: bigint | number
      }
      argsTuple: [validatorID: bigint | number]
      returns: [number, number, string, number, number]
    }>
    & Record<'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64' | 'addValidator', {
      argsObj: {
        /**
         * The account (presumably cold-wallet) that owns the validator set
         */
        owner: string
        /**
         * The account that manages the pool part. keys and triggers payouts.  Normally a hot-wallet as node sidecar needs the keys
         */
        manager: string
        /**
         * Optional NFD App ID linking to information about the validator being added - where information about the validator and their pools can be found.
         */
        nfdAppID: bigint | number
        /**
         * ValidatorConfig struct
         */
        config: [number, number, string, number, number]
      }
      argsTuple: [owner: string, manager: string, nfdAppID: bigint | number, config: [number, number, string, number, number]]
      returns: bigint
    }>
    & Record<'addPool(uint64)(uint64,uint64)' | 'addPool', {
      argsObj: {
        validatorID: bigint | number
      }
      argsTuple: [validatorID: bigint | number]
      returns: [bigint, bigint]
    }>
    & Record<'getPoolAppID((uint64,uint64))uint64' | 'getPoolAppID', {
      argsObj: {
        poolKey: [bigint | number, bigint | number]
      }
      argsTuple: [poolKey: [bigint | number, bigint | number]]
      returns: bigint
    }>
    & Record<'addStake(pay,uint64)(uint64,uint64)' | 'addStake', {
      argsObj: {
        /**
         * payment coming from staker to place into a pool
         */
        stakedAmountPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * The ID of the validator.
         */
        validatorID: bigint | number
      }
      argsTuple: [stakedAmountPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>, validatorID: bigint | number]
      /**
       * {ValidatorPoolKey}- The key of the validator pool.
       */
      returns: [bigint, bigint]
    }>
    & Record<'stakeUpdatedViaRewards((uint64,uint64),uint64)void' | 'stakeUpdatedViaRewards', {
      argsObj: {
        /**
         * ValidatorPoolKey type - [validatorID, PoolID] compound type
         */
        poolKey: [bigint | number, bigint | number]
        amountToAdd: bigint | number
      }
      argsTuple: [poolKey: [bigint | number, bigint | number], amountToAdd: bigint | number]
      returns: void
    }>
    & Record<'stakeRemoved((uint64,uint64),address,uint64,bool)void' | 'stakeRemoved', {
      argsObj: {
        /**
         * ValidatorPoolKey type - [validatorID, PoolID] compound type
         */
        poolKey: [bigint | number, bigint | number]
        staker: string
        amountRemoved: bigint | number
        stakerRemoved: boolean
      }
      argsTuple: [poolKey: [bigint | number, bigint | number], staker: string, amountRemoved: bigint | number, stakerRemoved: boolean]
      returns: void
    }>
    & Record<'findPoolForStaker(uint64,address,uint64)(uint64,uint64)' | 'findPoolForStaker', {
      argsObj: {
        validatorID: bigint | number
        staker: string
        amountToStake: bigint | number
      }
      argsTuple: [validatorID: bigint | number, staker: string, amountToStake: bigint | number]
      returns: [bigint, bigint]
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'numV'?: IntegerState
      'poolTemplateAppID'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type ValidatorRegistrySig = keyof ValidatorRegistry['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends ValidatorRegistrySig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the ValidatorRegistry smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends ValidatorRegistrySig> = ValidatorRegistry['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the ValidatorRegistry smart contract to the method's return type
 */
export type MethodReturn<TSignature extends ValidatorRegistrySig> = ValidatorRegistry['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type ValidatorRegistryCreateCalls = (typeof ValidatorRegistryCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type ValidatorRegistryCreateCallParams =
  | (TypedCallParams<'createApplication(uint64)void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type ValidatorRegistryDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: ValidatorRegistryCreateCalls) => ValidatorRegistryCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class ValidatorRegistryCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the ValidatorRegistry smart contract using the createApplication(uint64)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication(uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication(uint64)void' as const,
          methodArgs: Array.isArray(args) ? args : [args.poolTemplateAppID],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'gas()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getNumValidators()uint64 ABI method
   *
   * Returns the current number of validators
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getNumValidators(args: MethodArgs<'getNumValidators()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getNumValidators()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48]) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getValidatorInfo(args: MethodArgs<'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])' as const,
      methodArgs: Array.isArray(args) ? args : [args.validatorID],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getValidatorConfig(args: MethodArgs<'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)' as const,
      methodArgs: Array.isArray(args) ? args : [args.validatorID],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64 ABI method
   *
   * Adds a new validator
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addValidator(args: MethodArgs<'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.owner, args.manager, args.nfdAppID, args.config],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addPool(uint64)(uint64,uint64) ABI method
   *
   * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addPool(args: MethodArgs<'addPool(uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addPool(uint64)(uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.validatorID],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getPoolAppID((uint64,uint64))uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getPoolAppId(args: MethodArgs<'getPoolAppID((uint64,uint64))uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getPoolAppID((uint64,uint64))uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.poolKey],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the addStake(pay,uint64)(uint64,uint64) ABI method
   *
   * Adds stake to a validator pool.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static addStake(args: MethodArgs<'addStake(pay,uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'addStake(pay,uint64)(uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.stakedAmountPayment, args.validatorID],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stakeUpdatedViaRewards((uint64,uint64),uint64)void ABI method
   *
   * stakeUpdatedViaRewards is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stakeUpdatedViaRewards(args: MethodArgs<'stakeUpdatedViaRewards((uint64,uint64),uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stakeUpdatedViaRewards((uint64,uint64),uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.poolKey, args.amountToAdd],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the stakeRemoved((uint64,uint64),address,uint64,bool)void ABI method
   *
   * stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static stakeRemoved(args: MethodArgs<'stakeRemoved((uint64,uint64),address,uint64,bool)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'stakeRemoved((uint64,uint64),address,uint64,bool)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.poolKey, args.staker, args.amountRemoved, args.stakerRemoved],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the findPoolForStaker(uint64,address,uint64)(uint64,uint64) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static findPoolForStaker(args: MethodArgs<'findPoolForStaker(uint64,address,uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'findPoolForStaker(uint64,address,uint64)(uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.validatorID, args.staker, args.amountToStake],
      ...params,
    }
  }
}

/**
 * A client to make calls to the ValidatorRegistry smart contract
 */
export class ValidatorRegistryClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `ValidatorRegistryClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof ValidatorRegistry['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the ValidatorRegistry smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: ValidatorRegistryDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(ValidatorRegistryCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using the createApplication(uint64)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication(uint64)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication(uint64)void'>, AppCreateCallTransactionResult>(await $this.appClient.create(ValidatorRegistryCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.gas(args, params))
  }

  /**
   * Calls the getNumValidators()uint64 ABI method.
   *
   * Returns the current number of validators
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getNumValidators(args: MethodArgs<'getNumValidators()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.getNumValidators(args, params))
  }

  /**
   * Calls the getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48]) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getValidatorInfo(args: MethodArgs<'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.getValidatorInfo(args, params))
  }

  /**
   * Calls the getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getValidatorConfig(args: MethodArgs<'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.getValidatorConfig(args, params))
  }

  /**
   * Calls the addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64 ABI method.
   *
   * Adds a new validator
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public addValidator(args: MethodArgs<'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.addValidator(args, params))
  }

  /**
   * Calls the addPool(uint64)(uint64,uint64) ABI method.
   *
   * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public addPool(args: MethodArgs<'addPool(uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.addPool(args, params))
  }

  /**
   * Calls the getPoolAppID((uint64,uint64))uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getPoolAppId(args: MethodArgs<'getPoolAppID((uint64,uint64))uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.getPoolAppId(args, params))
  }

  /**
   * Calls the addStake(pay,uint64)(uint64,uint64) ABI method.
   *
   * Adds stake to a validator pool.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: {ValidatorPoolKey}- The key of the validator pool.
   */
  public addStake(args: MethodArgs<'addStake(pay,uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.addStake(args, params))
  }

  /**
   * Calls the stakeUpdatedViaRewards((uint64,uint64),uint64)void ABI method.
   *
   * stakeUpdatedViaRewards is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stakeUpdatedViaRewards(args: MethodArgs<'stakeUpdatedViaRewards((uint64,uint64),uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.stakeUpdatedViaRewards(args, params))
  }

  /**
   * Calls the stakeRemoved((uint64,uint64),address,uint64,bool)void ABI method.
   *
   * stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public stakeRemoved(args: MethodArgs<'stakeRemoved((uint64,uint64),address,uint64,bool)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.stakeRemoved(args, params))
  }

  /**
   * Calls the findPoolForStaker(uint64,address,uint64)(uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public findPoolForStaker(args: MethodArgs<'findPoolForStaker(uint64,address,uint64)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(ValidatorRegistryCallFactory.findPoolForStaker(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<ValidatorRegistry['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get numV() {
        return ValidatorRegistryClient.getIntegerState(state, 'numV')
      },
      get poolTemplateAppID() {
        return ValidatorRegistryClient.getIntegerState(state, 'poolTemplateAppID')
      },
    }
  }

  public compose(): ValidatorRegistryComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      gas(args: MethodArgs<'gas()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.gas(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getNumValidators(args: MethodArgs<'getNumValidators()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getNumValidators(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getValidatorInfo(args: MethodArgs<'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getValidatorInfo(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getValidatorConfig(args: MethodArgs<'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getValidatorConfig(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addValidator(args: MethodArgs<'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addValidator(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addPool(args: MethodArgs<'addPool(uint64)(uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addPool(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getPoolAppId(args: MethodArgs<'getPoolAppID((uint64,uint64))uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getPoolAppId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addStake(args: MethodArgs<'addStake(pay,uint64)(uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.addStake(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stakeUpdatedViaRewards(args: MethodArgs<'stakeUpdatedViaRewards((uint64,uint64),uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stakeUpdatedViaRewards(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      stakeRemoved(args: MethodArgs<'stakeRemoved((uint64,uint64),address,uint64,bool)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.stakeRemoved(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      findPoolForStaker(args: MethodArgs<'findPoolForStaker(uint64,address,uint64)(uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.findPoolForStaker(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as ValidatorRegistryComposer
  }
}
export type ValidatorRegistryComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(args: MethodArgs<'gas()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'gas()void'>]>

  /**
   * Calls the getNumValidators()uint64 ABI method.
   *
   * Returns the current number of validators
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNumValidators(args: MethodArgs<'getNumValidators()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'getNumValidators()uint64'>]>

  /**
   * Calls the getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48]) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorInfo(args: MethodArgs<'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'getValidatorInfo(uint64)(uint64,address,address,uint64,(uint16,uint32,address,uint8,uint16),(uint16,uint64,uint64),(uint16,byte[32])[12],(uint16,uint64,uint16,uint64)[48])'>]>

  /**
   * Calls the getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorConfig(args: MethodArgs<'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'getValidatorConfig(uint64)(uint16,uint32,address,uint8,uint16)'>]>

  /**
   * Calls the addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64 ABI method.
   *
   * Adds a new validator
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addValidator(args: MethodArgs<'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'addValidator(address,address,uint64,(uint16,uint32,address,uint8,uint16))uint64'>]>

  /**
   * Calls the addPool(uint64)(uint64,uint64) ABI method.
   *
   * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addPool(args: MethodArgs<'addPool(uint64)(uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'addPool(uint64)(uint64,uint64)'>]>

  /**
   * Calls the getPoolAppID((uint64,uint64))uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPoolAppId(args: MethodArgs<'getPoolAppID((uint64,uint64))uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'getPoolAppID((uint64,uint64))uint64'>]>

  /**
   * Calls the addStake(pay,uint64)(uint64,uint64) ABI method.
   *
   * Adds stake to a validator pool.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addStake(args: MethodArgs<'addStake(pay,uint64)(uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'addStake(pay,uint64)(uint64,uint64)'>]>

  /**
   * Calls the stakeUpdatedViaRewards((uint64,uint64),uint64)void ABI method.
   *
   * stakeUpdatedViaRewards is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeUpdatedViaRewards(args: MethodArgs<'stakeUpdatedViaRewards((uint64,uint64),uint64)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'stakeUpdatedViaRewards((uint64,uint64),uint64)void'>]>

  /**
   * Calls the stakeRemoved((uint64,uint64),address,uint64,bool)void ABI method.
   *
   * stakerRemoved is called by Staking Pools to inform the validator (us) that a particular amount of total stake has been removedfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.The calling App ID is validated against our pool list as well.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeRemoved(args: MethodArgs<'stakeRemoved((uint64,uint64),address,uint64,bool)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'stakeRemoved((uint64,uint64),address,uint64,bool)void'>]>

  /**
   * Calls the findPoolForStaker(uint64,address,uint64)(uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  findPoolForStaker(args: MethodArgs<'findPoolForStaker(uint64,address,uint64)(uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, MethodReturn<'findPoolForStaker(uint64,address,uint64)(uint64,uint64)'>]>

  /**
   * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): ValidatorRegistryComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): ValidatorRegistryComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<ValidatorRegistryComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<ValidatorRegistryComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type ValidatorRegistryComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type ValidatorRegistryComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
