@startuml
actor "Staker" as staker
actor "Validator" as validator
actor "Master Contract" as master
database "Staking pool(*)" as pool
group get mbr data
validator -> master: [SIMULATE] getMbrAmounts()(uint64,uint64,uint64)
master->validator: returns MBRs to add Validator, new Pool, new first-time Staker
end
group Add self as new validator
autonumber 0
validator -> master: [payment of Validator MBR for new validator]
validator -> master: addValidator(mbrPayment: PayTxn, nfdName: string, config: ValidatorConfig): uint64
autonumber stop
master -> validator: initializes new validator record, returns validator ID
end
group Add pool for validator
autonumber 0
validator -> master: [payment of mbr for new pool]
validator -> master: addPool(mbrPayment: PayTxn, validatorID: ValidatorID): ValidatorPoolKey
autonumber stop
master -> pool: [itxn] creates new staking pool contract instance
master -> validator: returns {Validator ID, Pool ID, Pool App ID}
end
group Add stake to validator
autonumber 0
staker -> master: [payment of stake (portion stays as MBR if first-time in protocol)
staker -> master:  addStake(stakedAmountPayment: PayTxn, validatorID: ValidatorID): ValidatorPoolKey
autonumber stop
master -> master: checks stakers existing staked pools w/ validator\nthen checks avail pools
autonumber 0
master -> pool: [itxn] [payment of user stake minus MBR portion had\nto be left behind in vaidator]
master -> pool: [itxn] addStake(stakedAmountPayment: PayTxn, staker: Address): uint64
autonumber stop
pool -> pool: updates 'ledger' for staker updating balance
end
group Remove stake from pool
autonumber 0
staker -> pool: removeStake(amountToUnstake: uint64)
autonumber 0
pool -> staker: [itxn] [payment of amountToUnstake from pool, updating ledger balance as welll]
pool -> master: [itxn] stakeRemoved(poolKey: ValidatorPoolKey, staker: Address,\namountRemoved: uint64, stakerRemoved: boolean)
note left: updates totals for validator for removed stake/staker
end
@enduml
